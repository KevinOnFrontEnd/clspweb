import { JacobianPoint, PrivateKey } from "chia-bls";
export class ParserError extends Error {
    constructor(message: string);
}
type Operator = (args: Program) => ProgramOutput;
interface Operators {
    operators: Record<string, Operator>;
    unknown: (operator: Program, args: Program) => ProgramOutput;
    quote: string;
    apply: string;
}
declare const operators: {
    i: Operator;
    c: Operator;
    f: Operator;
    r: Operator;
    l: Operator;
    x: Operator;
    '=': Operator;
    sha256: Operator;
    '+': Operator;
    '-': Operator;
    '*': Operator;
    divmod: Operator;
    '/': Operator;
    '>': Operator;
    '>s': Operator;
    pubkey_for_exp: Operator;
    point_add: Operator;
    strlen: Operator;
    substr: Operator;
    concat: Operator;
    ash: Operator;
    lsh: Operator;
    logand: Operator;
    logior: Operator;
    logxor: Operator;
    lognot: Operator;
    not: Operator;
    any: Operator;
    all: Operator;
    softfork: Operator;
};
declare class Position {
    line: number;
    column: number;
    constructor(source: string, index: number);
    toString(): string;
}
export interface ProgramOutput {
    value: Program;
    cost: bigint;
}
export interface RunOptions {
    maxCost?: bigint;
    operators: Operators;
    strict: boolean;
}
export interface CompileOptions extends RunOptions {
    includeFilePaths: Record<string, Record<string, string>>;
}
export type Cons = [Program, Program];
export type Value = Cons | Uint8Array;
export class Program {
    static cost: number;
    static true: Program;
    static false: Program;
    static nil: Program;
    readonly value: Value;
    position?: Position;
    get atom(): Uint8Array;
    get cons(): Cons;
    get first(): Program;
    get rest(): Program;
    get isAtom(): boolean;
    get isCons(): boolean;
    get isNull(): boolean;
    static cons(first: Program, rest: Program): Program;
    static fromBytes(bytes: Uint8Array): Program;
    static fromJacobianPoint(jacobianPoint: JacobianPoint): Program;
    static fromPrivateKey(privateKey: PrivateKey): Program;
    static fromHex(hex: string): Program;
    static fromBool(value: boolean): Program;
    static fromInt(value: number): Program;
    static fromBigInt(value: bigint): Program;
    static fromText(text: string): Program;
    static fromSource(source: string): Program;
    static fromList(programs: Program[]): Program;
    static deserialize(bytes: Uint8Array): Program;
    static deserializeHex(hex: string): Program;
    constructor(value: Value);
    get positionSuffix(): string;
    at(position: Position): this;
    curry(args: Program[]): Program;
    uncurry(): [Program, Program[]] | null;
    hash(): Uint8Array;
    hashHex(): string;
    define(program: Program): Program;
    defineAll(programs: Program[]): Program;
    compile(options?: Partial<CompileOptions>): ProgramOutput;
    run(environment: Program, options?: Partial<RunOptions>): ProgramOutput;
    toBytes(): Uint8Array;
    toJacobianPoint(): JacobianPoint;
    toPrivateKey(): PrivateKey;
    toHex(): string;
    toBool(): boolean;
    toInt(): number;
    toBigInt(): bigint;
    toText(): string;
    toSource(showKeywords?: boolean): string;
    toList(strict?: boolean): Program[];
    serialize(): Uint8Array;
    serializeHex(): string;
    equals(value: Program): boolean;
    toString(): string;
}

//# sourceMappingURL=index.d.ts.map
