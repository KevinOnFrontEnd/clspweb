{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAO,MAAM,kDAAoB;IAC7B,YAAY,OAAe,CAAE;QACzB,KAAK,CAAC;QACN,OAAO,cAAc,CAAC,IAAI,EAAE,0CAAY,SAAS;IACrD;AACJ;;;;AELO,MAAM,4CAAW;IACpB,GAAG,KAAK;IACR,GAAG,KAAK;IACR,GAAG,KAAK;IACR,GAAG,KAAK;IACR,GAAG,KAAK;IACR,GAAG,KAAK;IACR,GAAG,KAAK;IACR,GAAG,KAAK;IACR,KAAK,KAAK;IACV,MAAM,KAAK;IACX,QAAQ,KAAK;IACb,QAAQ,KAAK;IACb,QAAQ,KAAK;IACb,QAAQ,KAAK;IACb,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,KAAK;IACV,QAAQ,KAAK;IACb,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,KAAK;IACV,QAAQ,KAAK;IACb,QAAQ,KAAK;IACb,QAAQ,KAAK;IACb,QAAQ,KAAK;IACb,WAAW,KAAK;IAChB,gBAAgB,KAAK;IACrB,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,KAAK;IACV,UAAU,KAAK;AACnB;;;AClCO,MAAM,4CAAY,CAAC;;EAExB,CAAC;;;;;;AECI,MAAM,4CAAY,CAAA,GAAA,2BAAW,EAAE,CAAA,GAAA,yCAAO,CAAC,CAAC,IAAI;AAC5C,MAAM,4CAAY,CAAA,GAAA,2BAAW,EAAE,CAAA,GAAA,yCAAO,CAAC,CAAC,IAAI;AAC5C,MAAM,4CAAY,CAAA,GAAA,2BAAW,EAAE,CAAA,GAAA,yCAAO,CAAC,CAAC,IAAI;AAC5C,MAAM,4CAAW,CAAA,GAAA,2BAAW,EAAE,CAAA,GAAA,yCAAO,CAAC,CAAC,IAAI;AAC3C,MAAM,4CAAW,CAAA,GAAA,2BAAW,EAAE,CAAA,GAAA,yCAAO,CAAC,CAAC,IAAI;AAC3C,MAAM,4CAAY,CAAA,GAAA,2BAAW,EAAE,CAAA,GAAA,yCAAO,CAAC,CAAC,IAAI;;;;ACR5C,MAAM,kDAAqB;IACvB,WAAW,GAAW,EAAW;QACpC,KAAK,MAAM,QAAQ,IAAK,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,OAAO;QACpD,OAAO;IACX;IAEO,SAAS,GAAW,EAAW;QAClC,KAAK,MAAM,QAAQ,IAAI,CAAE,IAAI,CAAC,IAAI,GAAG,CAAC,OAAO,OAAO;QACpD,OAAO;IACX;IAEO,iBAAiB,GAAW,EAAW;QAC1C,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC;IAClD;IAEO,eAAe,GAAW,EAAW;QACxC,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC;IAClD;IAEO,OAAO,GAAW,EAAW;QAChC,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,IAAI,CAAC,UAAU,CAAC;IACjD;IAEO,MAAM,GAAW,EAAgB;QACpC,MAAM,QAAQ,IAAI,0CAAU,IAAI;QAChC,KAAK,MAAM,QAAQ,IAAK,MAAM,GAAG,CAAC;QAClC,OAAO;IACX;IAEO,aAAa,GAAW,EAAgB;QAC3C,MAAM,eAAe,IAAI;QACzB,KAAK,MAAM,QAAQ,IAAK,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,aAAa,GAAG,CAAC;QAC7D,OAAO;IACX;IAEO,oBAAoB,GAAW,EAAgB;QAClD,MAAM,aAAa,IAAI,0CAAa,IAAI;QACxC,KAAK,MAAM,QAAQ,IACf,IAAI,WAAW,GAAG,CAAC,OAAO,WAAW,MAAM,CAAC;aACvC,WAAW,GAAG,CAAC;QACxB,OAAO;IACX;IAEO,WAAW,GAAW,EAAgB;QACzC,MAAM,aAAa,IAAI,0CAAa,IAAI;QACxC,KAAK,MAAM,QAAQ,IAAK,WAAW,MAAM,CAAC;QAC1C,OAAO;IACX;IAEO,OAAO,GAAW,EAAQ;QAC7B,KAAK,MAAM,QAAQ,IAAK,IAAI,CAAC,GAAG,CAAC;QACjC,OAAO,IAAI;IACf;IAEO,iBAAiB,GAAW,EAAQ;QACvC,KAAK,MAAM,QAAQ,IAAK,IAAI,CAAC,MAAM,CAAC;QACpC,OAAO,IAAI;IACf;IAEO,0BAA0B,GAAW,EAAQ;QAChD,KAAK,MAAM,QAAQ,IACf,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,IAAI,CAAC,MAAM,CAAC;aAC3B,IAAI,CAAC,GAAG,CAAC;QAClB,OAAO,IAAI;IACf;IAEO,mBAAmB,GAAW,EAAQ;QACzC,KAAK,MAAM,QAAQ,IAAI,CAAE,IAAI,CAAC,IAAI,GAAG,CAAC,OAAO,IAAI,CAAC,MAAM,CAAC;QACzD,OAAO,IAAI;IACf;IAEO,KAAK,MAA+B,EAAgB;QACvD,OAAO,IAAI,0CAAU;eAAI,IAAI;SAAC,CAAC,IAAI,CAAC;IACxC;IAEO,IACH,MAA2D,EAC/C;QACZ,MAAM,SAAS,IAAI;QACnB,IAAI,QAAQ;QACZ,KAAK,MAAM,QAAQ,IAAI,CAAE,OAAO,GAAG,CAAC,OAAO,MAAM,SAAS,IAAI;QAC9D,OAAO;IACX;IAEO,OACH,SAAoE,EACxD;QACZ,MAAM,SAAS,IAAI;QACnB,IAAI,QAAQ;QACZ,KAAK,MAAM,QAAQ,IAAI,CACnB,IAAI,UAAU,MAAM,SAAS,IAAI,GAAG,OAAO,GAAG,CAAC;QACnD,OAAO;IACX;AACJ;;;;AC3FO,SAAS,0CAAa,IAAY,EAAE,KAAa;IACpD,IAAI,OAAO,EAAE;IACb,IAAI,WAAW;IACf,MAAO,WAAW,EAAE,CAAE;QAClB,UAAU,EAAE;QACZ,SAAS,EAAE;QACX,aAAa,EAAE;IACnB;IACA,QAAQ,EAAE;IACV,OAAO,QAAS,OAAO;AAC3B;AAEO,MAAM;IACT,OAAc,MAAgB,IAAI,4CAAW;IAC7C,OAAc,OAAiB,0CAAS,GAAG,CAAC,KAAK,GAAG;IACpD,OAAc,QAAkB,0CAAS,GAAG,CAAC,IAAI,GAAG;IAE5C,MAAc;IAEtB,YAAY,QAAgB,EAAE,CAAE;QAC5B,IAAI,QAAQ,EAAE,EAAE;YACZ,MAAM,YAAY,AAAC,CAAA,GAAA,8BAAc,EAAE,SAAS,KAAM;YAClD,MAAM,OAAO,CAAA,GAAA,4BAAY,EAAE,OAAO,WAAW,OAAO;YACpD,QAAQ,CAAA,GAAA,4BAAY,EAAE,WAAW,IAAI,CAAC;gBAAC;mBAAM;aAAK,GAAG,OAAO;QAChE;QACA,IAAI,CAAC,KAAK,GAAG;IACjB;IAEO,SAAqB;QACxB,MAAM,YAAY,AAAC,CAAA,GAAA,8BAAc,EAAE,IAAI,CAAC,KAAK,IAAI,KAAM;QACvD,OAAO,CAAA,GAAA,4BAAY,EAAE,IAAI,CAAC,KAAK,EAAE,WAAW;IAChD;IAEO,IAAI,KAAe,EAAY;QAClC,OAAO,IAAI,0CAAS,0CAAa,IAAI,CAAC,KAAK,EAAE,MAAM,KAAK;IAC5D;IAEO,QAAkB;QACrB,OAAO,IAAI,0CAAS,IAAI,CAAC,KAAK,GAAG,EAAE;IACvC;IAEO,OAAiB;QACpB,OAAO,IAAI,0CAAS,IAAI,CAAC,KAAK,GAAG,EAAE,GAAG,EAAE;IAC5C;IAEO,WAAmB;QACtB,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IACpC;AACJ;;;;;;;AC3CO,SAAS,0CAAe,OAAgB;IAC3C,OAAO,CAAA,GAAA,yCAAM,EAAE,IAAI,CAAC,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,CAAA,GAAA,yCAAO,CAAC,CAAC,IAAI,GAAG;AAC3D;AAEO,SAAS,0CAAc,OAAgB,EAAE,IAAa;IACzD,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAC,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,CAAA,GAAA,yCAAO,CAAC,CAAC,IAAI;QAAG;QAAS;KAAK;AAC9E;AAEO,SAAS,0CAAa,OAAgB,EAAE,WAAoB;IAC/D,OAAO,0CACH,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QACb,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QACjB;QACA,0CAAe;KAClB,GACD,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO,EAAE,GAAG,CAAC,MAAM;AAE7C;AAEO,SAAS,0CAAc,OAAgB,EAAE,IAAa;IACzD,OAAO,0CAAc,0CAAe,UAAU,0CAAe;AACjE;;;;ACzBA,MAAM,4CAAsB;IACxB,CAAC;;;;;;;;;;;;;IAaD,CAAC;IACD,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;IAyBD,CAAC;IACD,CAAC;;;6CAGwC,CAAC;IAC1C,CAAC;;;;;gBAKW,CAAC;IACb,CAAC,4DAA4D,CAAC;CACjE;AAED,IAAI;AAEJ,SAAS,8CAAwB,aAAmB;IAChD,MAAM,MAAM,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;IAC/B,KAAK,MAAM,eAAe,0CAAqB;QAC3C,MAAM,eAAe,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;QACxC,MAAM,MAAM,CAAA,GAAA,yCAAM,EAAE,IAAI,CAAC,cAAc;QACvC,MAAM,WAAW,cAAc,KAAK,KAAK,KAAK;QAC9C,kDAA4B,CAAA,GAAA,yCAAM,EAAE,IAAI,CACpC,UACA;IAER;IACA,OAAO;AACX;AAEO,SAAS,0CAAmB,aAAmB;IAClD,IAAI,CAAC,mDAA6B,gDAA0B,MAAM,EAAE;QAChE,kDAA4B,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC,EAAE;QAC/C,8CAAwB;IAC5B;IACA,OAAO;AACX;;;;;;;AE/EO,SAAS,0CAAe,CAAS,EAAE,CAAS;IAC/C,OAAO,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI;AACpC;;;;;;;;;;;AEEA,MAAM,kCAAY,IAAI,cAAc,MAAM,CAAC;AAC3C,MAAM,kCAAY,IAAI,cAAc,MAAM,CAAC;AAEpC,SAAS,0CACZ,QAAe,EACf,GAAW,EACX,YAAqB;IAErB,IAAI,OAAO,UAAU;QACjB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,eAAe,OAAO;QAChD,OAAO;IACX;IACA,OAAO;QAAE,GAAG,QAAQ;QAAE,CAAC,IAAI,EAAE;IAAa;AAC9C;AAEO,SAAS,0CACZ,OAAgB,EAChB,IAAa,EACb,gBAAuB,CAAC,CAAC;IAEzB,IAAI,CAAC,QAAQ,MAAM,EAAE;QACjB,IAAI,KAAK,MAAM,EAAE,OAAO;QACxB,OAAO,CAAA,GAAA,yBAAS,EAAE,QAAQ,IAAI,EAAE,KAAK,IAAI,IAAI,gBAAgB;IACjE;IACA,MAAM,OAAO,QAAQ,KAAK;IAC1B,MAAM,QAAQ,QAAQ,IAAI;IAC1B,IAAI,KAAK,MAAM,IAAI,CAAA,GAAA,yBAAS,EAAE,KAAK,IAAI,EAAE,kCAAY;QACjD,IAAI,KAAK,MAAM,EAAE,OAAO;QACxB,IAAI,MAAM,MAAM,IAAI,CAAA,GAAA,yBAAS,EAAE,MAAM,IAAI,EAAE,kCAAY;YACnD,IAAI,CAAA,GAAA,yBAAS,EAAE,KAAK,IAAI,EAAE,kCAAY,OAAO,CAAC;YAC9C,OAAO;QACX;QACA,OAAO,0CAAc,eAAe,MAAM,MAAM,IAAI;IACxD;IACA,IAAI,KAAK,MAAM,IAAI,CAAA,GAAA,yBAAS,EAAE,KAAK,IAAI,EAAE,kCAAY;QACjD,IAAI,MAAM,MAAM,IAAI,CAAA,GAAA,yBAAS,EAAE,MAAM,IAAI,EAAE,kCAAY;YACnD,IAAI,CAAA,GAAA,yBAAS,EAAE,KAAK,IAAI,EAAE,kCAAY,OAAO,CAAC;YAC9C,OAAO;QACX;QACA,OAAO,0CAAc,eAAe,MAAM,MAAM,IAAI;IACxD;IACA,IAAI,CAAC,KAAK,MAAM,EAAE,OAAO;IACzB,MAAM,cAAc,0CAAM,MAAM,KAAK,KAAK,EAAE;IAC5C,IAAI,CAAC,aAAa,OAAO;IACzB,OAAO,0CAAM,OAAO,KAAK,IAAI,EAAE;AACnC;;;ADxCO,SAAS,0CAAc,OAAgB;IAC1C,IAAI,CAAC,QAAQ,MAAM,EAAE,OAAO,QAAQ,MAAM;IAC1C,MAAM,WAAW,QAAQ,KAAK;IAC9B,IAAI,CAAC,SAAS,MAAM,EAAE;QAClB,MAAM,QAAQ,SAAS,IAAI;QAC3B,IAAI,CAAA,GAAA,yBAAS,EAAE,OAAO,CAAA,GAAA,yCAAQ,IAAI,OAAO;aACpC,IAAI,CAAA,GAAA,yBAAS,EAAE,OAAO,CAAA,GAAA,yCAAQ,IAAI,OAAO;IAClD,OAAO,IAAI,CAAC,0CAAc,WAAW,OAAO;IAC5C,OAAO,QAAQ,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC,OAAS,0CAAc;AAC/D;AAEO,SAAS,0CACZ,OAAgB,EAChB,aAAmB;IAEnB,IAAI,0CAAc,YAAY,CAAC,QAAQ,MAAM,EAAE;QAC3C,MAAM,aAAa,cAAc,SAAS,CAAA,GAAA,yCAAM,EAAE,GAAG,EAAE,KAAK;QAC5D,UAAU,CAAA,GAAA,yCAAa,EAAE;IAC7B;IACA,OAAO;AACX;AAEO,SAAS,0CAAW,OAAgB;IACvC,OAAO,QAAQ,MAAM,IAAI,QAAQ,QAAQ,OAAO,EAAE;AACtD;AAEO,SAAS,0CACZ,OAAgB,EAChB,cAAoB;IAEpB,MAAM,UAAU,CAAA,GAAA,yCAAI,EAChB,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,oCACnB;IAEJ,IAAI,WAAW,0CAAW,OAAO,CAAC,OAAO,GACrC,OAAO,OAAO,CAAC,OAAO;IAE1B,OAAO;AACX;AAEO,SAAS,0CAAU,IAAa;IACnC,MAAM,UAAU,CAAA,GAAA,yCAAI,EAChB,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,+BACnB;IAEJ,IAAI,SACA,OAAO,OAAO,CAAC,QAAQ;IAE3B,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAC,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,CAAA,GAAA,yCAAO,CAAC,CAAC,IAAI;QAAG;KAAK;AACrE;AAEO,SAAS,0CAAS,IAAa;IAClC,MAAM,UAAU,CAAA,GAAA,yCAAI,EAChB,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,+BACnB;IAEJ,IAAI,SACA,OAAO,OAAO,CAAC,OAAO;IAE1B,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAC,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,CAAA,GAAA,yCAAO,CAAC,CAAC,IAAI;QAAG;KAAK;AACrE;AAEO,SAAS,0CAAa,OAAgB,EAAE,IAAa;IACxD,MAAM,QAAQ,QAAQ,QAAQ;IAC9B,IAAI,SAAS,EAAE,EACX,OAAO;IAEX,UAAU,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,SAAS,EAAE;IACxC,IAAI,QAAQ,EAAE,EACV,OAAO,0CAAa,SAAS,0CAAS;IAE1C,OAAO,0CAAa,SAAS,0CAAU;AAC3C;AAEO,SAAS,0CAAQ,OAAgB,EAAE,IAAa;IACnD,IAAI,CAAC,QAAQ,MAAM,EACf,OAAO,0CAAa,SAAS;IAEjC,IAAI,QAAQ,QAAQ,KAAK;IACzB,IAAI,MAAM,MAAM,EAAE,QAAQ,0CAAQ,OAAO;SACpC,IAAI,CAAA,GAAA,yBAAS,EAAE,MAAM,IAAI,EAAE,CAAA,GAAA,yCAAQ,IACpC,OAAO;IAEX,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QACpB;WACG,QAAQ,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,OAAS,0CAAQ,MAAM;KACxD;AACL;AAEO,SAAS,0CACZ,OAAgB,EAChB,aAAmB;IAEnB,MAAM,UAAU,CAAA,GAAA,yCAAI,EAChB,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,oCACnB;IAEJ,IAAI,CAAC,SACD,OAAO;IAEX,MAAM,eAAe,OAAO,CAAC,OAAO;IACpC,MAAM,eAAe,OAAO,CAAC,OAAO;IACpC,MAAM,qBAAqB,0CAAQ,cAAc;IACjD,IAAI,0CAAc,qBACd,OAAO,wCAAgB,oBAAoB;IAE/C,MAAM,cAAc,mBAAmB,MAAM;IAC7C,MAAM,cAAc,YAAY,GAAG,CAAC,CAAC,OACjC,wCAAgB,MAAM;IAE1B,MAAM,mBAAmB,YAAY,MAAM,CACvC,CAAC,OACG,KAAK,MAAM,IACV,CAAA,KAAK,KAAK,CAAC,MAAM,IAAI,CAAC,CAAA,GAAA,yBAAS,EAAE,KAAK,KAAK,CAAC,IAAI,EAAE,CAAA,GAAA,yCAAQ,EAAC,GAClE,MAAM;IACR,IAAI,mBAAmB,GACnB,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;IAE5B,OAAO;AACX;AAEO,SAAS,0CACZ,OAAgB,EAChB,aAAmB;IAEnB,IAAI,CAAC,QAAQ,MAAM,EACf,OAAO;IAEX,MAAM,WAAW,QAAQ,KAAK;IAC9B,IAAI,SAAS,MAAM,IAAI,CAAA,GAAA,yBAAS,EAAE,SAAS,IAAI,EAAE,CAAA,GAAA,yCAAQ,IACrD,OAAO;IAEX,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CACnB,QAAQ,MAAM,GAAG,GAAG,CAAC,CAAC,OAAS,wCAAgB,MAAM;AAE7D;AAEO,SAAS,0CAAc,OAAgB,EAAE,cAAoB;IAChE,IAAI,UAAU,CAAA,GAAA,yCAAI,EACd,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,mCACnB;IAEJ,IAAI,SACA,OAAO,OAAO,CAAC,QAAQ;IAE3B,UAAU,CAAA,GAAA,yCAAI,EACV,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,mCACnB;IAEJ,IAAI,SACA,OAAO,OAAO,CAAC,OAAO;IAE1B,OAAO;AACX;AAEO,SAAS,0CAAc,OAAgB,EAAE,cAAoB;IAChE,IAAI,UAAU,CAAA,GAAA,yCAAI,EAAE,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,mBAAmB;IAC1D,IAAI,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE;QACpC,MAAM,OAAO,IAAI,CAAA,GAAA,yCAAO,EAAE,OAAO,CAAC,OAAO,CAAC,QAAQ,IAAI,GAAG,CACrD,CAAA,GAAA,yCAAO,EAAE,IAAI;QAEjB,OAAO,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,KAAK,MAAM;IACxC;IACA,UAAU,CAAA,GAAA,yCAAI,EAAE,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,mBAAmB;IACtD,IAAI,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE;QACpC,MAAM,OAAO,IAAI,CAAA,GAAA,yCAAO,EAAE,OAAO,CAAC,OAAO,CAAC,QAAQ,IAAI,GAAG,CACrD,CAAA,GAAA,yCAAO,EAAE,KAAK;QAElB,OAAO,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,KAAK,MAAM;IACxC;IACA,OAAO;AACX;AAEO,SAAS,0CACZ,OAAgB,EAChB,cAAoB;IAEpB,MAAM,UAAU,CAAA,GAAA,yCAAI,EAAE,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,YAAY;IACrD,IAAI,SACA,OAAO,CAAA,GAAA,yCAAM,EAAE,GAAG;IAEtB,OAAO;AACX;AAEO,SAAS,0CACZ,OAAgB,EAChB,cAAoB;IAEpB,MAAM,UAAU,CAAA,GAAA,yCAAI,EAAE,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,uBAAuB;IAChE,IAAI,SACA,OAAO,CAAA,GAAA,yCAAM,EAAE,GAAG;IAEtB,OAAO;AACX;AAEO,SAAS,wCACZ,OAAgB,EAChB,aAAmB;IAEnB,IAAI,QAAQ,MAAM,EACd,OAAO;IAEX,MAAM,aAAa;QACf;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACH;IACD,MAAO,QAAQ,MAAM,CAAE;QACnB,MAAM,eAAe;QACrB,KAAK,MAAM,aAAa,WAAY;YAChC,UAAU,UAAU,SAAS;YAC7B,IAAI,CAAC,aAAa,MAAM,CAAC,UAAU;QACvC;QACA,IAAI,aAAa,MAAM,CAAC,UACpB,OAAO;IAEf;IACA,OAAO;AACX;AAEO,SAAS,0CAAU,UAAgB;IACtC,OAAO,CAAC;QACJ,OAAO;YACH,OAAO,wCAAgB,KAAK,KAAK,EAAE;YACnC,MAAM,EAAE;QACZ;IACJ;AACJ;;;AFzOA,MAAM,iCAAW;AAEV,SAAS,0CAAU,KAAgB;IACtC,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO,CAAA,GAAA,yCAAM,EAAE,GAAG;SACrC,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO,KAAK,CAAC,EAAE;IAC5C,MAAM,WAAW,MAAM,MAAM,IAAI;IACjC,OAAO,CAAA,GAAA,yCAAM,EAAE,IAAI,CACf,0CAAU,MAAM,KAAK,CAAC,GAAG,YACzB,0CAAU,MAAM,KAAK,CAAC;AAE9B;AAEO,SAAS,0CAAiB,KAAgB;IAC7C,IAAI,MAAM,MAAM,KAAK,GACjB,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAC,CAAA,GAAA,yCAAa,EAAE,CAAA,GAAA,yCAAM,EAAE,GAAG;KAAE;SACpD,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO,KAAK,CAAC,EAAE;IAC5C,MAAM,WAAW,MAAM,MAAM,IAAI;IACjC,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QACpB,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO;QACzB,0CAAiB,MAAM,KAAK,CAAC,GAAG;QAChC,0CAAiB,MAAM,KAAK,CAAC;KAChC;AACL;AAEO,SAAS,0CAAQ,OAAgB;IACpC,IAAI,QAAQ,MAAM,EACd,OAAO;WAAI,0CAAQ,QAAQ,KAAK;WAAM,0CAAQ,QAAQ,IAAI;KAAE;SAC3D,OAAO;QAAC,QAAQ,MAAM;KAAG;AAClC;AAEO,SAAS,0CACZ,SAAgB,EAChB,SAAgB,EAChB,MAAiB;IAEjB,MAAM,eAAsB,CAAC;IAC7B,KAAK,MAAM,QAAQ,OAAQ,YAAY,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,GAAG;IACpE,MAAM,kBAAkB,IAAI,CAAA,GAAA,yCAAQ,EAAE,OAAO,IAAI,CAAC;IAClD,gBAAgB,MAAM,CAAC,IAAI,CAAA,GAAA,yCAAQ,EAAE,OAAO,IAAI,CAAC;IACjD,IAAI,WAAW,IAAI,CAAA,GAAA,yCAAQ,EAAE;QAAC;KAAS;IACvC,MAAM,YAAY,IAAI,CAAA,GAAA,yCAAQ,EAAE;IAChC,MAAO,SAAS,IAAI,CAAE;QAClB,MAAM,gBAAgB,IAAI,CAAA,GAAA,yCAAQ,EAAE;QACpC,WAAW,IAAI,CAAA,GAAA,yCAAQ;QACvB,KAAK,MAAM,QAAQ,cAAe;YAC9B,KAAK,MAAM,SAAS;gBAAC;gBAAW;aAAa,CACzC,IAAI,QAAQ,OACR,SAAS,MAAM,CAAC,IAAI,CAAA,GAAA,yCAAQ,EAAE,0CAAQ,KAAK,CAAC,KAAK;QAE7D;QACA,SAAS,gBAAgB,CAAC;QAC1B,UAAU,MAAM,CAAC;IACrB;IACA,UAAU,kBAAkB,CAAC;IAC7B,UAAU,MAAM,CAAC;IACjB,OAAO,UAAU,IAAI,CAAC,CAAC,GAAG,IAAM,CAAA,GAAA,yCAAa,EAAE,GAAG;AACtD;AAEO,SAAS,0CACZ,IAAa,EACb,SAA4B,EAC5B,SAAgB,EAChB,SAAgB,EAChB,MAAiB,EACjB,UAAgB;IAEhB,MAAM,UAAU,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;IACnC,MAAM,SAAS,WAAW,SAAS,MAAM,KAAK;IAC9C,KAAK,MAAM,QAAQ,OAAO,MAAM,GAC5B,0CACI,MACA,WACA,WACA,WACA,QACA;AAEZ;AAEO,SAAS,0CAAY,OAAgB,EAAE,IAAc;IACxD,IAAI,QAAQ,MAAM,EACd,OAAO,CAAA,GAAA,yCAAM,EAAE,IAAI,CACf,0CAAY,QAAQ,KAAK,EAAE,OAC3B,0CAAY,QAAQ,IAAI,EAAE;SAE3B,IAAI,KAAK,QAAQ,CAAC,QAAQ,MAAM,KACnC,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAC,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAY;KAAQ;IAElE,OAAO;AACX;AAEO,SAAS,0CAAmB,OAAgB;IAC/C,MAAM,SAAS,QAAQ,IAAI;IAC3B,MAAM,QAAQ,OAAO,IAAI;IACzB,MAAM,QAAQ;QAAC,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAa,OAAO,KAAK;QAAE,MAAM,KAAK;KAAC;IACvE,MAAM,OAAO,MAAM,IAAI,CAAC,KAAK;IAC7B,MAAM,OAAO,0CAAQ,MAAM,KAAK,EAAE,MAAM,CAAC,CAAC,OAAS,KAAK,MAAM;IAC9D,MAAM,eAAe,0CAAY,MAAM;IACvC,MAAM,IAAI,CAAC,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAC,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAO;KAAa;IAClE,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;AAC5B;AAEO,SAAS,0CACZ,kBAA2B,EAC3B,SAA4B,EAC5B,SAAgB,EAChB,SAAgB,EAChB,MAAiB,EACjB,UAAgB;IAEhB,MAAM,KAAK,mBAAmB,KAAK,CAAC,MAAM;IAC1C,MAAM,cAAc,mBAAmB,IAAI,CAAC,KAAK;IACjD,IAAI,OAAO,WAAW;QAClB,0CACI,aACA,WACA,WACA,WACA,QACA;QAEJ;IACJ;IACA,MAAM,OAAO,YAAY,MAAM;IAC/B,IAAI,UAAU,GAAG,CAAC,OACd,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,KAAK,SAAS,CAAC,MAAM,WAAW,CAAC;IAE/D,UAAU,GAAG,CAAC;IACd,IAAI,OAAO,YACP,OAAO,IAAI,CAAC;SACT,IAAI,OAAO,SACd,SAAS,CAAC,KAAK,GAAG,mBAAmB,IAAI,CAAC,IAAI;SAC3C,IAAI,OAAO,gBACd,OAAO,IAAI,CAAC,0CAAmB;SAC5B,IAAI,OAAO,eACd,SAAS,CAAC,KAAK,GAAG,CAAA,GAAA,yCAAa,EAAE,mBAAmB,IAAI,CAAC,IAAI,CAAC,KAAK;SAEnE,MAAM,IAAI,MACN,CAAC,wEAAwE,EAAE,KAAK,SAAS,CACrF,IACF,CAAC,CAAC;AAGhB;AAEO,SAAS,0CACZ,IAAa,EACb,UAAgB;IAEhB,MAAM,YAAmB,CAAC;IAC1B,MAAM,YAAmB,CAAC;IAC1B,MAAM,SAAyB,EAAE;IACjC,MAAM,qBAAqB,KAAK,KAAK;IACrC,MAAM,YAAY,IAAI,CAAA,GAAA,yCAAQ;IAC9B,MAAO,KAAM;QACT,OAAO,KAAK,IAAI;QAChB,IAAI,KAAK,IAAI,CAAC,MAAM,EAAE;QACtB,0CACI,KAAK,KAAK,EACV,WACA,WACA,WACA,QACA;IAER;IACA,MAAM,iBAAiB,KAAK,KAAK;IACjC,SAAS,CAAC,+BAAS,GAAG,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QACnC;QACA;KACH;IACD,OAAO;QAAC;QAAW;QAAW;KAAO;AACzC;AAEO,SAAS,0CAAmB,IAAa,EAAE,QAAkB;IAChE,IAAI,KAAK,MAAM,EAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,GAAG;SAC9B,IAAI,CAAC,KAAK,MAAM,EACjB,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QACpB,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YAAC;YAAM,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,SAAS,MAAM;SAAI;KAChE;IACL,MAAM,OAAO,0CAAmB,KAAK,KAAK,EAAE,SAAS,GAAG,CAAC,CAAA,GAAA,yCAAO,EAAE,IAAI;IACtE,MAAM,QAAQ,0CAAmB,KAAK,IAAI,EAAE,SAAS,GAAG,CAAC,CAAA,GAAA,yCAAO,EAAE,KAAK;IACvE,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;WAAI,KAAK,MAAM;WAAO,MAAM,MAAM;KAAG;AACjE;AAEO,SAAS,0CACZ,WAAoB,EACpB,MAAiB,EACjB,UAAgB;IAEhB,IAAI,qBAAqB,CAAA,GAAA,yCAAa,EAAE;IACxC,KAAK,MAAM,SAAS,OAAQ;QACxB,qBAAqB,CAAA,GAAA,yCAAY,EAC7B,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YACb,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YACjB,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;gBACb,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;gBACjB,CAAA,GAAA,yCAAa,EACT,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;oBACb,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO;oBACzB;oBACA;iBACH;gBAEL;aACH;SACJ,GACD,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO,EAAE,GAAG,CAAC,MAAM;QAEzC,qBAAqB,CAAA,GAAA,uCAAc,EAAE,oBAAoB;IAC7D;IACA,OAAO;AACX;AAEO,SAAS,0CACZ,SAAgB,EAChB,kBAA2B,EAC3B,mBAA4B,EAC5B,YAAsB;IAEtB,MAAM,oBAA2B,CAAC;IAClC,KAAK,MAAM,CAAC,MAAM,iBAAiB,IAAI,OAAO,OAAO,CAAC,WAAY;QAC9D,MAAM,mBAAmB,0CACrB,iBAAiB,KAAK,EACtB;QAEJ,MAAM,aAAa,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;eAC7B,iBAAiB,MAAM;eACvB,oBAAoB,MAAM;SAChC;QACD,iBAAiB,CAAC,KAAK,GAAG,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YACvC,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YACjB,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;gBACb,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;gBACjB,CAAA,GAAA,yCAAa,EAAE,iBAAiB,IAAI,CAAC,KAAK;gBAC1C;gBACA,CAAA,GAAA,yCAAa,EAAE;aAClB;SACJ;IACL;IACA,OAAO;AACX;AAEO,SAAS,0CACZ,IAAa,EACb,WAAoB,EACpB,YAAqB,EACrB,UAAgB;IAEhB,MAAM,CAAC,WAAW,WAAW,OAAO,GAAG,0CAAiB,MAAM;IAC9D,MAAM,qBAAqB,0CACvB,aACA,QACA;IAEJ,MAAM,mBAAmB,0CACrB,WACA,WACA;IAEJ,MAAM,kBAAkB,iBAAiB,IAAI,GAAG;IAChD,MAAM,eAAe,0CAAU;WACxB,iBAAiB,GAAG,CAAC,CAAC,OAAS,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;KACtD;IACD,MAAM,mBAAmB,CAAA,GAAA,yCAAO,EAAE,IAAI;IACtC,MAAM,eAAe,kBAAkB,CAAA,GAAA,yCAAO,EAAE,KAAK,GAAG,CAAA,GAAA,yCAAO,EAAE,GAAG;IACpE,MAAM,sBAAsB,0CACxB,cACA;IAEJ,MAAM,oBAAoB,0CACtB,WACA,oBACA,qBACA;IAEJ,MAAM,iBAAiB,iBAAiB,CAAC,+BAAS,CAAC,QAAQ;IAC3D,IAAI;IACJ,IAAI,iBAAiB;QACjB,MAAM,qBAA4B,CAAC;QACnC,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,mBACtC,IAAI,iBAAiB,GAAG,CAAC,MAAM,kBAAkB,CAAC,IAAI,GAAG;QAC7D,OAAO,MAAM,CAAC,oBAAoB;QAClC,MAAM,mBAAmB;eAAI;SAAiB,CAAC,GAAG,CAC9C,CAAC,OAAS,kBAAkB,CAAC,KAAK;QAEtC,MAAM,0BAA0B,0CAAiB;QACjD,MAAM,yBAAyB,wBAAwB,QAAQ;QAC/D,gBAAgB,CAAC,GAAG,EAAE,uBAAuB,GAAG,CAAC;IACrD,OACI,gBAAgB;IAEpB,OAAO,CAAA,GAAA,yCAAM,EAAE,UAAU,CACrB,CAAC,aAAa,EAAE,eAAe,CAAC,EAAE,cAAc,GAAG,CAAC;AAE5D;;;ANpSA,MAAM,6CAAuB,IAAI,CAAA,GAAA,yCAAQ,EAAE;OACpC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAO,GAAG,GAAG,CAAC,CAAC,QAAU,CAAA,GAAA,oBAAI,EAAE,CAAA,GAAA,2BAAW,EAAE;IAC7D,CAAA,GAAA,oBAAI,EAAE,IAAI,cAAc,MAAM,CAAC;IAC/B,CAAA,GAAA,oBAAI,EAAE,IAAI,cAAc,MAAM,CAAC;CAClC;AAEM,SAAS,0CACZ,IAAa,EACb,WAAoB,EACpB,WAAoB,EACpB,UAAgB,EAChB,QAAgB,CAAC;IAEjB,SAAS,IAAI,OAAgB;QACzB,OAAO,0CAAa,SAAS,aAAa,aAAa;IAC3D;IAEA,MAAM,UAAU,KAAK,KAAK;IAC1B,IAAI,CAAC,QAAQ,MAAM,EACf,OAAO,CAAA,GAAA,yCAAa,EAAE;IAE1B,IAAI,CAAC,QAAQ,KAAK,CAAC,MAAM,EAAE;QACvB,MAAM,KAAK,QAAQ,KAAK,CAAC,MAAM;QAC/B,IAAI,OAAO,MAAM;YACb,MAAM,aAAa,0CACf,QAAQ,IAAI,EACZ,aACA,aACA,YACA,QAAQ;YAEZ,OAAO,IACH,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;gBACb,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO;gBACzB,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;gBACjB,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;oBACb,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO;oBACzB;oBACA,CAAA,GAAA,yCAAa,EAAE,CAAA,GAAA,yCAAM,EAAE,GAAG;iBAC7B;aACJ;QAET,OAAO,IAAI,OAAO,WAAW;YACzB,IAAI,UAAU,GACV,OAAO,IAAI,QAAQ,IAAI,CAAC,KAAK;YAEjC,MAAM,aAAa,0CACf,QAAQ,IAAI,EACZ,aACA,aACA,YACA,QAAQ;YAEZ,OAAO,IACH,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;gBACb,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO;gBACzB,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;gBACjB,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;oBACb,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO;oBACzB;oBACA,CAAA,GAAA,yCAAa,EAAE,CAAA,GAAA,yCAAM,EAAE,GAAG;iBAC7B;aACJ;QAET;IACJ;IACA,MAAM,QAAQ,IACV,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAC,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAO,QAAQ,KAAK;KAAC;IAE5D,MAAM,OAAO,IAAI,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAC,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAO,QAAQ,IAAI;KAAC;IACxE,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAC,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO;QAAI;QAAO;KAAK;AACtE;AAEO,SAAS,0CACZ,KAAc,EACd,WAAoB,EACpB,YAAqB,EACrB,WAAiB;IAEjB,OAAO,CAAA,GAAA,yCAAa,EAAE;AAC1B;AAEO,SAAS,0CACZ,KAAc,EACd,YAAqB,EACrB,WAAoB,EACpB,WAAiB;IAEjB,OAAO,CAAA,GAAA,yCAAa,EAAE;AAC1B;AAEO,MAAM,4CAAkB;IAC3B,IAAI;IACJ,QAAQ;IACR,SAAS;IACT,QAAQ,CAAA,GAAA,yCAAS;IACjB,KAAK,CAAA,GAAA,yCAAS;AAClB;AAEO,SAAS,0CACZ,OAAgB,EAChB,YAAsB,EACtB,YAAsB,EACtB,WAAkB;IAElB,IAAI,QAAQ,MAAM,EACd,OAAO;SACJ,IAAI,QAAQ,KAAK,CAAC,MAAM,IAAI,QAAQ,KAAK,CAAC,MAAM,OAAO,SAAS;QACnE,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,MAAM,EACzB,MAAM,IAAI,MACN,CAAC,kCAAkC,EAAE,QAAQ,kCAAkC,EAAE,QAAQ,cAAc,CAAC,CAAC,CAAC;QAElH,OAAO,CAAA,GAAA,yCAAa,EAAE,0CAAW,QAAQ,IAAI,CAAC,KAAK;IACvD,OACI,OAAO,CAAA,GAAA,yCAAM,EAAE,IAAI,CACf,0CAAW,QAAQ,KAAK,GACxB,0CAAW,QAAQ,IAAI;AAEnC;AAEO,SAAS,0CACZ,OAAgB,EAChB,WAAoB,EACpB,WAAoB,EACpB,UAAgB;IAEhB,UAAU,0CAAW,SAAS,aAAa,aAAa;IACxD,IAAI,CAAC,QAAQ,MAAM,EAAE;QACjB,MAAM,OAAO,QAAQ,MAAM;QAC3B,IAAI,SAAS,KACT,OAAO,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO,EAAE,GAAG,CAAC,MAAM;QAEhD,KAAK,MAAM,QAAQ,YAAY,MAAM,GAAI;YACrC,MAAM,SAAS,KAAK,KAAK;YACzB,MAAM,QAAQ,KAAK,IAAI,CAAC,KAAK;YAC7B,IAAI,OAAO,MAAM,IAAI,OAAO,MAAM,OAAO,MACrC,OAAO;QAEf;QACA,OAAO,CAAA,GAAA,yCAAa,EAAE;IAC1B;IACA,MAAM,WAAW,QAAQ,KAAK;IAC9B,IAAI,SAAS,MAAM,EAAE;QACjB,MAAM,QAAQ,CAAA,GAAA,yCAAY,EACtB,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YACb,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YACjB,CAAA,GAAA,yCAAa,EAAE;YACf,CAAA,GAAA,yCAAa,EAAE;YACf,CAAA,GAAA,yCAAa,EAAE;SAClB,GACD,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO,EAAE,GAAG,CAAC,MAAM;QAEzC,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YAAC;SAAM;IACnC;IACA,MAAM,OAAO,SAAS,MAAM;IAC5B,KAAK,MAAM,aAAa,YAAY,MAAM,GACtC,IAAI,UAAU,KAAK,CAAC,MAAM,IAAI,UAAU,KAAK,CAAC,MAAM,OAAO,MAAM;QAC7D,MAAM,YAAY,UAAU,IAAI,CAAC,KAAK;QACtC,MAAM,cAAc,CAAA,GAAA,yCAAY,EAAE,WAAW,QAAQ,IAAI;QACzD,MAAM,SAAS,CAAA,GAAA,yCAAY,EACvB,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YACb,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YACjB;YACA,CAAA,GAAA,yCAAa,EAAE;YACf,CAAA,GAAA,yCAAa,EAAE;SAClB,GACD,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO,EAAE,GAAG,CAAC,MAAM;QAEzC,OAAO;IACX;IAEJ,IAAI,QAAQ,2CAAiB;QACzB,MAAM,WAAW,yCAAe,CAAC,KAAqC;QACtE,MAAM,cAAc,SAChB,QAAQ,IAAI,EACZ,aACA,aACA;QAEJ,OAAO,CAAA,GAAA,yCAAY,EACf,CAAA,GAAA,yCAAa,EAAE,cACf,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO,EAAE,GAAG,CAAC,MAAM;IAE7C;IACA,IAAI,CAAA,GAAA,yBAAS,EAAE,SAAS,IAAI,EAAE,CAAA,GAAA,yCAAQ,IAClC,OAAO;IAEX,MAAM,eAAe,QAAQ,IAAI,CAC5B,MAAM,GACN,GAAG,CAAC,CAAC,OACF,0CAAa,MAAM,aAAa,aAAa;IAErD,IAAI,SAAS,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;QAAC;WAAa;KAAa;IACzD,IACI,2CAAqB,GAAG,CAAC,CAAA,GAAA,oBAAI,EAAE,IAAI,cAAc,MAAM,CAAC,WACxD,KAAK,UAAU,CAAC,MAEhB,OAAO;IAEX,KAAK,MAAM,QAAQ,YAAY,MAAM,GAAI;QACrC,MAAM,CAAC,QAAQ,MAAM,GAAG,KAAK,MAAM;QACnC,IAAI,CAAC,OAAO,MAAM,EAAE;QACpB,MAAM,aAAa,OAAO,MAAM;QAChC,IAAI,eAAe,KACf,OAAO;aACJ,IAAI,eAAe,MAAM;YAC5B,MAAM,UAAU,CAAA,GAAA,yCAAY,EACxB,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;gBACb,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;gBACjB,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;oBACb,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;oBACjB,CAAA,GAAA,yCAAa,EACT,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;wBACb,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;2BACd,QAAQ,IAAI,CAAC,MAAM;qBACzB;oBAEL,CAAA,GAAA,yCAAa,EAAE;oBACf,CAAA,GAAA,yCAAa,EAAE;iBAClB;aACJ,GACD,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO,EAAE,GAAG,CAAC,MAAM;YAEzC,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;gBACpB,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAQ;gBAC1B;gBACA,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;oBACb,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO;oBACzB,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,yCAAO,EAAE,IAAI,CAAC,MAAM;oBACtC;iBACH;aACJ;QACL;IACJ;IACA,MAAM,IAAI,MACN,CAAC,+BAA+B,EAAE,QAAQ,EAAE,QAAQ,cAAc,CAAC,CAAC,CAAC;AAE7E;AAEO,SAAS,0CAAU,UAAgB;IACtC,OAAO,CAAC;QACJ,MAAM,OAAO,KAAK,KAAK;QACvB,IAAI,cAAc,CAAA,GAAA,yCAAM,EAAE,GAAG;QAC7B,IAAI;QACJ,IAAI,CAAC,KAAK,IAAI,CAAC,MAAM,EAAE;YACnB,cAAc,KAAK,IAAI,CAAC,KAAK;YAC7B,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,cAAc,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK;QAClE,OACI,cAAc,CAAA,GAAA,yCAAiB,EAAE;QAErC,OAAO;YACH,OAAO,0CAAa,MAAM,aAAa,aAAa;YACpD,MAAM,EAAE;QACZ;IACJ;AACJ;;;;;AW1QO,MAAM,4CAAQ;IACjB,IAAI,GAAG;IACP,MAAM,GAAG;IACT,OAAO,GAAG;IACV,MAAM,GAAG;IACT,OAAO,GAAG;IACV,eAAe,GAAG;IAClB,WAAW,GAAG;IACd,cAAc,EAAE;IAChB,aAAa,IAAI;IACjB,SAAS,IAAI;IACb,YAAY,EAAE;IACd,WAAW,IAAI;IACf,SAAS,IAAI;IACb,YAAY,EAAE;IACd,QAAQ,IAAI;IACZ,WAAW,EAAE;IACb,QAAQ,IAAI;IACZ,WAAW,EAAE;IACb,YAAY,KAAK;IACjB,eAAe,EAAE;IACjB,SAAS,IAAI;IACb,YAAY,EAAE;IACd,YAAY,GAAG;IACf,eAAe,EAAE;IACjB,cAAc,IAAI;IAClB,cAAc,OAAO;IACrB,gBAAgB,QAAQ;IACxB,YAAY,QAAQ;IACpB,eAAe,GAAG;IAClB,SAAS,GAAG;IACZ,UAAU,IAAI;IACd,kBAAkB,EAAE;IACpB,yBAAyB,IAAI;IAC7B,YAAY,IAAI;IAChB,eAAe,EAAE;IACjB,gBAAgB,GAAG;IACnB,kBAAkB,EAAE;IACpB,uBAAuB,EAAE;IACzB,YAAY,IAAI;IAChB,eAAe,EAAE;IACjB,cAAc,IAAI;IAClB,UAAU,IAAI;IACd,YAAY,IAAI;IAChB,YAAY,IAAI;IAChB,eAAe,EAAE;IACjB,YAAY,IAAI;IAChB,eAAe,EAAE;IACjB,YAAY,IAAI;IAChB,eAAe,EAAE;IACjB,OAAO,GAAG;IACV,OAAO,GAAG;AACd;;;;;;ACjDO,SAAS,0CAAQ,IAAY;IAChC,QAAQ,QAAQ;IAChB,QAAQ,QAAQ;IAChB,QAAQ,QAAQ;IAChB,OAAO,AAAC,OAAO,KAAM;AACzB;AAEO,SAAS,0CACZ,KAAc,EACd,WAAoB;IAEpB,IAAI,OAAO,CAAA,GAAA,yCAAI,EAAE,cAAc,GAAG,CAAA,GAAA,yCAAI,EAAE,gBAAgB;IACxD,IAAI,MAAM,MAAM,EAAE,OAAO;QAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,GAAG;cAAE;IAAK;IACpD,IAAI,gBAAgB;IACpB,MAAM,OAAO,MAAM,IAAI;IACvB,MAAO,gBAAgB,KAAK,MAAM,IAAI,IAAI,CAAC,cAAc,KAAK,EAC1D;IACJ,QAAQ,OAAO,iBAAiB,CAAA,GAAA,yCAAI,EAAE,qBAAqB;IAC3D,IAAI,kBAAkB,KAAK,MAAM,EAAE,OAAO;QAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,GAAG;cAAE;IAAK;IACrE,MAAM,aAAa,0CAAQ,IAAI,CAAC,cAAc;IAC9C,IAAI,aAAa,KAAK,MAAM,GAAG;IAC/B,IAAI,UAAU;IACd,MAAO,aAAa,iBAAiB,UAAU,WAAY;QACvD,IAAI,YAAY,MAAM,EAClB,MAAM,IAAI,MACN,CAAC,qBAAqB,EAAE,YAAY,EAAE,YAAY,cAAc,CAAC,CAAC,CAAC;QAE3E,IAAI,AAAC,CAAA,IAAI,CAAC,WAAW,GAAG,OAAM,MAAO,GAAG,cAAc,YAAY,IAAI;aACjE,cAAc,YAAY,KAAK;QACpC,QAAQ,CAAA,GAAA,yCAAI,EAAE,gBAAgB;QAC9B,YAAY;QACZ,IAAI,YAAY,OAAO;YACnB;YACA,UAAU;QACd;IACJ;IACA,OAAO;QAAE,OAAO;cAAa;IAAK;AACtC;;;;;;;AChBO,MAAM,4CAAY;IACrB,GAAI,CAAC;QACD,MAAM,OAAO,yCAAO,MAAM,KAAK;QAC/B,OAAO;YAAE,OAAO,IAAI,CAAC,EAAE,CAAC,MAAM,GAAG,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE;YAAE,MAAM,CAAA,GAAA,yCAAI,EAAE,EAAE;QAAC;IACvE;IACA,GAAI,CAAC;QACD,MAAM,OAAO,yCAAO,MAAM,KAAK;QAC/B,OAAO;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE;YAAG,MAAM,CAAA,GAAA,yCAAI,EAAE,IAAI;QAAC;IACrE;IACA,GAAI,CAAC;QACD,MAAM,OAAO,yCAAO,MAAM,KAAK,GAAG;QAClC,OAAO;YAAE,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK;YAAE,MAAM,CAAA,GAAA,yCAAI,EAAE,KAAK;QAAC;IACrD;IACA,GAAI,CAAC;QACD,MAAM,OAAO,yCAAO,MAAM,KAAK,GAAG;QAClC,OAAO;YAAE,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI;YAAE,MAAM,CAAA,GAAA,yCAAI,EAAE,IAAI;QAAC;IACnD;IACA,GAAI,CAAC;QACD,MAAM,OAAO,yCAAO,MAAM,KAAK;QAC/B,OAAO;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM;YAAG,MAAM,CAAA,GAAA,yCAAI,EAAE,KAAK;QAAC;IACxE;IACA,GAAI,CAAC;QACD,MAAM,IAAI,MAAM,CAAC,UAAU,EAAE,KAAK,WAAW,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;IACzE;IACA,KAAM,CAAC;QACH,MAAM,OAAO,yCAAO,MAAM,KAAK,GAAG;QAClC,OAAO;YACH,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC,CAAA,GAAA,yBAAS,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI;YAC7D,MACI,CAAA,GAAA,yCAAI,EAAE,MAAM,GACZ,AAAC,CAAA,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAA,IACrD,CAAA,GAAA,yCAAI,EAAE,SAAS;QAC3B;IACJ;IACA,QAAS,CAAC;QACN,MAAM,OAAO,yCAAO,MAAM,UAAU,WAAW;QAC/C,IAAI,OAAO,CAAA,GAAA,yCAAI,EAAE,UAAU;QAC3B,IAAI,YAAY;QAChB,MAAM,QAAuB,EAAE;QAC/B,KAAK,MAAM,QAAQ,KAAM;YACrB,KAAK,MAAM,QAAQ,KAAK,IAAI,CAAE,MAAM,IAAI,CAAC;YACzC,aAAa,KAAK,IAAI,CAAC,MAAM;YAC7B,QAAQ,CAAA,GAAA,yCAAI,EAAE,YAAY;QAC9B;QACA,QAAQ,OAAO,aAAa,CAAA,GAAA,yCAAI,EAAE,aAAa;QAC/C,OAAO,0CAAW;YACd,OAAO,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,CAAA,GAAA,sBAAM,EAAE,WAAW,IAAI,CAAC;kBACjD;QACJ;IACJ;IACA,KAAM,CAAC;QACH,MAAM,OAAO,yCAAO,MAAM,KAAK,WAAW;QAC1C,IAAI,QAAQ,EAAE;QACd,IAAI,OAAO,CAAA,GAAA,yCAAI,EAAE,SAAS;QAC1B,IAAI,UAAU;QACd,KAAK,MAAM,QAAQ,KAAM;YACrB,SAAS,KAAK,QAAQ;YACtB,WAAW,KAAK,IAAI,CAAC,MAAM;YAC3B,QAAQ,CAAA,GAAA,yCAAI,EAAE,WAAW;QAC7B;QACA,QAAQ,OAAO,WAAW,CAAA,GAAA,yCAAI,EAAE,YAAY;QAC5C,OAAO,0CAAW;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;kBAAQ;QAAK;IAC/D;IACA,KAAM,CAAC;QACH,IAAI,OAAO,CAAA,GAAA,yCAAI,EAAE,SAAS;QAC1B,IAAI,KAAK,MAAM,EAAE,OAAO;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,GAAG;YAAE,MAAM;QAAK;QACzD,MAAM,OAAO,yCAAO,MAAM,KAAK,WAAW;QAC1C,IAAI,QAAQ,EAAE;QACd,IAAI,OAAO,EAAE;QACb,IAAI,UAAU;QACd,KAAK,MAAM,QAAQ,KAAM;YACrB,SAAS,OAAO,KAAK,QAAQ;YAC7B,OAAO,CAAC,EAAE;YACV,WAAW,KAAK,IAAI,CAAC,MAAM;YAC3B,QAAQ,CAAA,GAAA,yCAAI,EAAE,WAAW;QAC7B;QACA,QAAQ,OAAO,WAAW,CAAA,GAAA,yCAAI,EAAE,YAAY;QAC5C,OAAO,0CAAW;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;kBAAQ;QAAK;IAC/D;IACA,KAAM,CAAC;QACH,MAAM,OAAO,yCAAO,MAAM,KAAK,WAAW;QAC1C,IAAI,OAAO,CAAA,GAAA,yCAAI,EAAE,OAAO;QACxB,IAAI,CAAC,KAAK,MAAM,EAAE,OAAO,0CAAW;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,IAAI;kBAAE;QAAK;QAChE,IAAI,QAAQ,IAAI,CAAC,EAAE,CAAC,QAAQ;QAC5B,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM;QAC9B,KAAK,MAAM,QAAQ,KAAK,KAAK,CAAC,GAAI;YAC9B,QACI,CAAA,GAAA,yCAAI,EAAE,QAAQ,GACd,AAAC,CAAA,OAAO,KAAK,IAAI,CAAC,MAAM,IAAI,OAAO,KAAI,IACnC,CAAA,GAAA,yCAAI,EAAE,gBAAgB,GAC1B,AAAC,OAAO,KAAK,IAAI,CAAC,MAAM,IAAI,OAAO,QAC/B,CAAA,GAAA,yCAAI,EAAE,uBAAuB;YACrC,SAAS,KAAK,QAAQ;YACtB,OAAO,0CAAe;QAC1B;QACA,OAAO,0CAAW;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;kBAAQ;QAAK;IAC/D;IACA,QAAS,CAAC;QACN,MAAM,OAAO,yCAAO,MAAM,UAAU,GAAG;QACvC,IAAI,OAAO,CAAA,GAAA,yCAAI,EAAE,UAAU;QAC3B,MAAM,YAAY,IAAI,CAAC,EAAE,CAAC,QAAQ;QAClC,MAAM,cAAc,IAAI,CAAC,EAAE,CAAC,QAAQ;QACpC,IAAI,gBAAgB,EAAE,EAClB,MAAM,IAAI,MACN,CAAC,0CAA0C,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QAE3E,QACI,AAAC,CAAA,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAA,IACzD,CAAA,GAAA,yCAAI,EAAE,aAAa;QACvB,IAAI,gBAAgB,YAAY;QAChC,MAAM,iBAAiB,CAAA,GAAA,kBAAE,EAAE,WAAW;QACtC,IAAI,YAAY,EAAE,KAAK,cAAc,EAAE,IAAI,mBAAmB,EAAE,EAC5D,iBAAiB,EAAE;QACvB,MAAM,WAAW,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;QACpC,MAAM,YAAY,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;QACrC,QACI,AAAC,CAAA,OAAO,SAAS,IAAI,CAAC,MAAM,IAAI,OAAO,UAAU,IAAI,CAAC,MAAM,CAAA,IAC5D,CAAA,GAAA,yCAAI,EAAE,aAAa;QACvB,OAAO;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,IAAI,CAAC,UAAU;kBAAY;QAAK;IAC5D;IACA,KAAM,CAAC;QACH,MAAM,OAAO,yCAAO,MAAM,KAAK,GAAG;QAClC,IAAI,OAAO,CAAA,GAAA,yCAAI,EAAE,OAAO;QACxB,MAAM,YAAY,IAAI,CAAC,EAAE,CAAC,QAAQ;QAClC,MAAM,cAAc,IAAI,CAAC,EAAE,CAAC,QAAQ;QACpC,IAAI,gBAAgB,EAAE,EAClB,MAAM,IAAI,MACN,CAAC,qCAAqC,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QAEtE,QACI,AAAC,CAAA,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAA,IACzD,CAAA,GAAA,yCAAI,EAAE,UAAU;QACpB,IAAI,gBAAgB,YAAY;QAChC,MAAM,iBAAiB,CAAA,GAAA,kBAAE,EAAE,WAAW;QACtC,IAAI,YAAY,EAAE,KAAK,cAAc,EAAE,IAAI,gBAAgB,EAAE,EACzD,iBAAiB,EAAE;QACvB,MAAM,WAAW,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;QACpC,OAAO,0CAAW;YAAE,OAAO;kBAAU;QAAK;IAC9C;IACA,KAAM,CAAC;QACH,MAAM,OAAO,yCAAO,MAAM,KAAK,GAAG;QAClC,MAAM,OACF,CAAA,GAAA,yCAAI,EAAE,MAAM,GACZ,AAAC,CAAA,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAA,IACrD,CAAA,GAAA,yCAAI,EAAE,SAAS;QACvB,OAAO;YACH,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,KAAK,IAAI,CAAC,EAAE,CAAC,QAAQ;kBAC7D;QACJ;IACJ;IACA,MAAO,CAAC;QACJ,MAAM,OAAO,yCAAO,MAAM,MAAM,GAAG;QACnC,MAAM,OACF,CAAA,GAAA,yCAAI,EAAE,OAAO,GACb,AAAC,CAAA,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAA,IACrD,CAAA,GAAA,yCAAI,EAAE,UAAU;QACxB,OAAO;YACH,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CACnB,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,aAAa,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,QAAQ;kBAEvD;QACJ;IACJ;IACA,gBAAiB,CAAC;QACd,MAAM,OAAO,yCAAO,MAAM,kBAAkB,GAAG;QAC/C,MAAM,QAAQ,CAAA,GAAA,kBAAE,EAAE,IAAI,CAAC,EAAE,CAAC,QAAQ,IAAI,CAAA,GAAA,wBAAQ,EAAE,CAAC;QACjD,MAAM,WAAW,CAAA,GAAA,yBAAS,EAAE,SAAS,CAAC,CAAA,GAAA,4BAAY,EAAE,OAAO,IAAI;QAC/D,MAAM,OACF,CAAA,GAAA,yCAAI,EAAE,UAAU,GAChB,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,CAAA,GAAA,yCAAI,EAAE,aAAa;QACrD,OAAO,0CAAW;YACd,OAAO,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,SAAS,KAAK,GAAG,OAAO;kBACjD;QACJ;IACJ;IACA,WAAY,CAAC;QACT,MAAM,OAAO,yCAAO,MAAM,aAAa,WAAW;QAClD,IAAI,OAAO,CAAA,GAAA,yCAAI,EAAE,YAAY;QAC7B,IAAI,QAAQ,CAAA,GAAA,4BAAY,EAAE,UAAU;QACpC,KAAK,MAAM,QAAQ,KAAM;YACrB,QAAQ,MAAM,GAAG,CAAC,CAAA,GAAA,4BAAY,EAAE,SAAS,CAAC,KAAK,IAAI,EAAE;YACrD,QAAQ,CAAA,GAAA,yCAAI,EAAE,cAAc;QAChC;QACA,OAAO,0CAAW;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,MAAM,OAAO;kBAAK;QAAK;IACxE;IACA,QAAS,CAAC;QACN,MAAM,OAAO,yCAAO,MAAM,UAAU,GAAG;QACvC,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM;QAChC,MAAM,OAAO,CAAA,GAAA,yCAAI,EAAE,UAAU,GAAG,OAAO,QAAQ,CAAA,GAAA,yCAAI,EAAE,aAAa;QAClE,OAAO,0CAAW;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,OAAO,CAAC;kBAAO;QAAK;IAC3D;IACA,QAAS,CAAC;QACN,MAAM,OAAO,yCAAO,MAAM,UAAU;YAAC;YAAG;SAAE,EAAE;QAC5C,MAAM,QAAQ,IAAI,CAAC,EAAE,CAAC,IAAI;QAC1B,IACI,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,GAAG,KACrB,KAAK,MAAM,KAAK,KAAK,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,GAAG,GAE5C,MAAM,IAAI,MACN,CAAC,4CAA4C,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QAE7E,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK;QAC1B,MAAM,KAAK,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,EAAE,CAAC,KAAK,KAAK,MAAM,MAAM;QAC7D,IAAI,KAAK,MAAM,MAAM,IAAI,KAAK,QAAQ,KAAK,KAAK,OAAO,GACnD,MAAM,IAAI,MACN,CAAC,oCAAoC,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QAErE,OAAO;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,MAAM,KAAK,CAAC,MAAM;YAAM,MAAM,EAAE;QAAC;IACvE;IACA,QAAS,CAAC;QACN,MAAM,OAAO,yCAAO,MAAM,UAAU,WAAW;QAC/C,IAAI,OAAO,CAAA,GAAA,yCAAI,EAAE,UAAU;QAC3B,MAAM,QAAuB,EAAE;QAC/B,KAAK,MAAM,QAAQ,KAAM;YACrB,KAAK,MAAM,QAAQ,KAAK,IAAI,CAAE,MAAM,IAAI,CAAC;YACzC,QAAQ,CAAA,GAAA,yCAAI,EAAE,YAAY;QAC9B;QACA,QAAQ,OAAO,MAAM,MAAM,IAAI,CAAA,GAAA,yCAAI,EAAE,aAAa;QAClD,OAAO,0CAAW;YACd,OAAO,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,WAAW,IAAI,CAAC;kBACzC;QACJ;IACJ;IACA,KAAM,CAAC;QACH,MAAM,OAAO,yCAAO,MAAM,OAAO,GAAG;QACpC,IAAI,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,GAAG,GACtB,MAAM,IAAI,MACN,CAAC,uCAAuC,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QAExE,MAAM,QAAQ,IAAI,CAAC,EAAE,CAAC,QAAQ;QAC9B,IAAI,AAAC,CAAA,QAAQ,EAAE,GAAG,CAAC,QAAQ,KAAI,IAAK,MAAM,EACtC,MAAM,IAAI,MACN,CAAC,iCAAiC,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QAElE,IAAI,QAAQ,IAAI,CAAC,EAAE,CAAC,QAAQ;QAC5B,IAAI,SAAS,GAAG,UAAU;aACrB,UAAU,CAAC;QAChB,MAAM,OACF,CAAA,GAAA,yCAAI,EAAE,UAAU,GAChB,AAAC,CAAA,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,OAAO,0CAAe,OAAM,IACvD,CAAA,GAAA,yCAAI,EAAE,aAAa;QAC3B,OAAO,0CAAW;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;kBAAQ;QAAK;IAC/D;IACA,KAAM,CAAC;QACH,MAAM,OAAO,yCAAO,MAAM,OAAO,GAAG;QACpC,IAAI,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,GAAG,GACtB,MAAM,IAAI,MACN,CAAC,uCAAuC,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QAExE,MAAM,QAAQ,IAAI,CAAC,EAAE,CAAC,QAAQ;QAC9B,IAAI,AAAC,CAAA,QAAQ,EAAE,GAAG,CAAC,QAAQ,KAAI,IAAK,MAAM,EACtC,MAAM,IAAI,MACN,CAAC,iCAAiC,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QAElE,IAAI,QAAQ,CAAA,GAAA,4BAAY,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,OAAO;QAC/C,IAAI,QAAQ,EAAE,EAAE,QAAQ,CAAC;QACzB,IAAI,SAAS,GAAG,UAAU;aACrB,UAAU,CAAC;QAChB,MAAM,OACF,CAAA,GAAA,yCAAI,EAAE,UAAU,GAChB,AAAC,CAAA,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,OAAO,0CAAe,OAAM,IACvD,CAAA,GAAA,yCAAI,EAAE,aAAa;QAC3B,OAAO,0CAAW;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;kBAAQ;QAAK;IAC/D;IACA,QAAS,CAAC,OACN,0CAAe,UAAU,CAAC,EAAE,EAAE,MAAM,CAAC,GAAG,IAAM,IAAI;IACtD,QAAS,CAAC,OACN,0CAAe,UAAU,EAAE,EAAE,MAAM,CAAC,GAAG,IAAM,IAAI;IACrD,QAAS,CAAC,OACN,0CAAe,UAAU,EAAE,EAAE,MAAM,CAAC,GAAG,IAAM,IAAI;IACrD,QAAS,CAAC;QACN,MAAM,QAAQ,yCAAO,MAAM,UAAU,GAAG;QACxC,MAAM,OACF,CAAA,GAAA,yCAAI,EAAE,UAAU,GAChB,OAAO,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,CAAA,GAAA,yCAAI,EAAE,aAAa;QACtD,OAAO,0CAAW;YACd,OAAO,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,QAAQ;kBAC5C;QACJ;IACJ;IACA,KAAM,CAAC;QACH,MAAM,QAAQ,yCAAO,MAAM,OAAO;QAClC,MAAM,OAAO,CAAA,GAAA,yCAAI,EAAE,QAAQ;QAC3B,OAAO;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM;YAAG,MAAM;QAAK;IAClE;IACA,KAAM,CAAC;QACH,MAAM,OAAO,yCAAO,MAAM;QAC1B,MAAM,OAAO,CAAA,GAAA,yCAAI,EAAE,QAAQ,GAAG,OAAO,KAAK,MAAM,IAAI,CAAA,GAAA,yCAAI,EAAE,UAAU;QACpE,IAAI,SAAS;QACb,KAAK,MAAM,QAAQ,KACf,IAAI,CAAC,KAAK,MAAM,EAAE;YACd,SAAS;YACT;QACJ;QAEJ,OAAO;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YAAS,MAAM;QAAK;IACzD;IACA,KAAM,CAAC;QACH,MAAM,OAAO,yCAAO,MAAM;QAC1B,MAAM,OAAO,CAAA,GAAA,yCAAI,EAAE,QAAQ,GAAG,OAAO,KAAK,MAAM,IAAI,CAAA,GAAA,yCAAI,EAAE,UAAU;QACpE,IAAI,SAAS;QACb,KAAK,MAAM,QAAQ,KACf,IAAI,KAAK,MAAM,EAAE;YACb,SAAS;YACT;QACJ;QAEJ,OAAO;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC;YAAS,MAAM;QAAK;IACzD;IACA,UAAW,CAAC;QACR,MAAM,OAAO,yCAAO,MAAM,YAAY;YAAC;YAAG;SAAS;QACnD,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,EACf,MAAM,IAAI,MACN,CAAC,iDAAiD,EAAE,IAAI,CAAC,EAAE,CAAC,cAAc,CAAC,CAAC,CAAC;QAErF,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC,QAAQ;QAC7B,IAAI,OAAO,EAAE,EACT,MAAM,IAAI,MACN,CAAC,qDAAqD,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QAEtF,OAAO;YAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,KAAK;YAAE,MAAM;QAAK;IAC9C;AACJ;AAEO,MAAM,4CAAmB;eAC5B;IACA,SAAS;IACT,OAAO;IACP,OAAO;AACX;AAEO,SAAS;IACZ,OAAO;QACH,GAAG,yCAAgB;QACnB,WAAW;YAAE,GAAG,0CAAiB,SAAS;QAAC;IAC/C;AACJ;AAEO,SAAS,yCACZ,OAAgB,EAChB,IAAY,EACZ,MAAkC,EAClC,IAAsB;IAEtB,MAAM,OAAO,QAAQ,MAAM;IAC3B,IAAI,OAAO,WAAW,YAAY,KAAK,MAAM,KAAK,QAC9C,MAAM,IAAI,MACN,CAAC,SAAS,EAAE,OAAO,cAAc,EAAE,KAAK,SAAS,CAAC,MAAM,SAAS,EAC7D,QAAQ,cAAc,CACzB,CAAC,CAAC;SAEN,IACD,MAAM,OAAO,CAAC,WACb,CAAA,KAAK,MAAM,GAAG,MAAM,CAAC,EAAE,IAAI,KAAK,MAAM,GAAG,MAAM,CAAC,EAAE,AAAD,GAElD,MAAM,IAAI,MACN,CAAC,SAAS,EACN,MAAM,CAAC,EAAE,KAAK,WACR,CAAC,SAAS,EAAE,MAAM,CAAC,EAAE,CAAC,CAAC,GACvB,CAAC,QAAQ,EAAE,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE,CAAC,CAAC,CAChD,cAAc,EAAE,KAAK,SAAS,CAAC,MAAM,SAAS,EAC3C,QAAQ,cAAc,CACzB,CAAC,CAAC;IAEX,IAAI,SAAS,WACT,KAAK,OAAO,CAAC,CAAC;QACV,IACI,AAAC,SAAS,UAAU,CAAC,KAAK,MAAM,IAC/B,SAAS,UAAU,CAAC,KAAK,MAAM,EAEhC,MAAM,IAAI,MACN,CAAC,SAAS,EAAE,KAAK,aAAa,EAAE,KAAK,SAAS,CAC1C,MACF,SAAS,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;IAE/C;IACJ,OAAO;AACX;AAEO,SAAS,0CAAe,KAAa;IACxC,IAAI,SACA,UAAU,EAAE,GAAG,IAAI,AAAC,CAAA,QAAQ,EAAE,GAAG,CAAC,QAAQ,KAAI,EAAG,QAAQ,CAAC,GAAG,MAAM;IACvE,IAAI,QAAQ,EAAE,EAAE;IAChB,OAAO,AAAC,SAAS,KAAM;AAC3B;AAEO,SAAS,0CAAW,MAAqB;IAC5C,OAAO;QACH,OAAO,OAAO,KAAK;QACnB,MACI,OAAO,IAAI,GACX,OAAO,OAAO,KAAK,CAAC,IAAI,CAAC,MAAM,IAAI,CAAA,GAAA,yCAAI,EAAE,aAAa;IAC9D;AACJ;AAEO,SAAS,0CACZ,MAAc,EACd,YAAoB,EACpB,IAAa,EACb,UAA4C;IAE5C,IAAI,QAAQ;IACZ,IAAI,UAAU;IACd,IAAI,OAAO,CAAA,GAAA,yCAAI,EAAE,OAAO;IACxB,KAAK,MAAM,QAAQ,KAAK,MAAM,GAAG,GAAG,CAAC,CAAC;QAClC,IAAI,CAAC,KAAK,MAAM,EACZ,MAAM,IAAI,MACN,CAAC,0BAA0B,EAAE,KAAK,SAAS,CAAC,QAAQ,SAAS,EACzD,KAAK,cAAc,CACtB,CAAC,CAAC;QAEX,OAAO;IACX,GAAI;QACA,QAAQ,WAAW,OAAO,KAAK,QAAQ;QACvC,WAAW,KAAK,IAAI,CAAC,MAAM;QAC3B,QAAQ,CAAA,GAAA,yCAAI,EAAE,SAAS;IAC3B;IACA,QAAQ,OAAO,WAAW,CAAA,GAAA,yCAAI,EAAE,UAAU;IAC1C,OAAO,0CAAW;QAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC;cAAQ;IAAK;AAC/D;AAEO,SAAS,yCACZ,EAAW,EACX,IAAa;IAEb,IACI,CAAC,GAAG,IAAI,CAAC,MAAM,IACf,CAAA,GAAA,yBAAS,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,WAAW,IAAI,CAAC;QAAC;QAAM;KAAK,IAE5D,MAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,GAAG,cAAc,CAAC,CAAC,CAAC;IAC5D,IAAI,GAAG,IAAI,CAAC,MAAM,GAAG,GACjB,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,GAAG,cAAc,CAAC,CAAC,CAAC;IAC3D,MAAM,eAAe,AAAC,CAAA,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,EAAE,GAAG,IAAG,KAAM;IAC7D,MAAM,iBACF,CAAA,GAAA,yBAAS,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,SAAS;IAC9D,IAAI;IACJ,IAAI,iBAAiB,GAAG,OAAO,EAAE;SAC5B,IAAI,iBAAiB,GAAG;QACzB,OAAO,CAAA,GAAA,yCAAI,EAAE,SAAS;QACtB,IAAI,UAAU;QACd,KAAK,MAAM,QAAQ,KAAK,MAAM,GAAI;YAC9B,IAAI,CAAC,KAAK,MAAM,EACZ,MAAM,IAAI,MACN,CAAC,sBAAsB,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;YAEvD,WAAW,KAAK,IAAI,CAAC,MAAM;YAC3B,QAAQ,CAAA,GAAA,yCAAI,EAAE,WAAW;QAC7B;QACA,QAAQ,OAAO,WAAW,CAAA,GAAA,yCAAI,EAAE,YAAY;IAChD,OAAO,IAAI,iBAAiB,GAAG;QAC3B,OAAO,CAAA,GAAA,yCAAI,EAAE,OAAO;QACpB,MAAM,UAAU,KAAK,MAAM;QAC3B,IAAI,QAAQ,MAAM,EAAE;YAChB,MAAM,QAAQ,OAAO,CAAC,EAAE;YACxB,IAAI,CAAC,MAAM,MAAM,EACb,MAAM,IAAI,MACN,CAAC,sBAAsB,EAAE,MAAM,cAAc,CAAC,CAAC,CAAC;YAExD,IAAI,UAAU,MAAM,IAAI,CAAC,MAAM;YAC/B,KAAK,MAAM,QAAQ,QAAQ,KAAK,CAAC,GAAI;gBACjC,IAAI,CAAC,KAAK,MAAM,EACZ,MAAM,IAAI,MACN,CAAC,sBAAsB,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;gBAEvD,QACI,CAAA,GAAA,yCAAI,EAAE,QAAQ,GACd,AAAC,CAAA,OAAO,KAAK,IAAI,CAAC,MAAM,IAAI,OAAO,QAAO,IACtC,CAAA,GAAA,yCAAI,EAAE,gBAAgB,GAC1B,AAAC,OAAO,KAAK,IAAI,CAAC,MAAM,IAAI,OAAO,WAC/B,CAAA,GAAA,yCAAI,EAAE,uBAAuB;gBACrC,WAAW,KAAK,IAAI,CAAC,MAAM;YAC/B;QACJ;IACJ,OAAO,IAAI,iBAAiB,GAAG;QAC3B,OAAO,CAAA,GAAA,yCAAI,EAAE,UAAU;QACvB,IAAI,SAAS;QACb,KAAK,MAAM,QAAQ,KAAK,MAAM,GAAI;YAC9B,IAAI,CAAC,KAAK,MAAM,EACZ,MAAM,IAAI,MACN,CAAC,sBAAsB,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;YAEvD,QAAQ,CAAA,GAAA,yCAAI,EAAE,YAAY;YAC1B,UAAU,KAAK,IAAI,CAAC,MAAM;QAC9B;QACA,QAAQ,OAAO,UAAU,CAAA,GAAA,yCAAI,EAAE,aAAa;IAChD,OAAO,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,GAAG,cAAc,CAAC,CAAC,CAAC;IACnE,QAAQ,OAAO;IACf,IAAI,QAAQ,EAAE,IAAI,GAAG,EACjB,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,GAAG,cAAc,CAAC,CAAC,CAAC;IAC3D,OAAO;QAAE,OAAO,CAAA,GAAA,yCAAM,EAAE,GAAG;QAAE,MAAM;IAAK;AAC5C;AAEO,SAAS,0CACZ,EAAW,EACX,IAAa,EACb,OAAmB;IAEnB,MAAM,SAAS,GAAG,QAAQ;IAC1B,MAAM,UACF,OAAO,OAAO,CAAC,CAAA,GAAA,yCAAO,GAAG,IAAI,CAAC,CAAC,QAAU,KAAK,CAAC,EAAE,KAAK,SAAS,CAAC,EAAE,IAClE,GAAG,MAAM;IACb,IAAI,WAAW,QAAQ,SAAS,CAAC,SAAS,EAAE;QACxC,MAAM,SAAS,QAAQ,SAAS,CAAC,SAAS,CAAC,QAAQ,CAAC;QACpD,OAAO;IACX,OAAO,OAAO,QAAQ,SAAS,CAAC,OAAO,CAAC,IAAI;AAChD;;;AH1gBO,MAAM,4CAAe;IACxB,MAAO,CAAC,mBAAmB,OAAO;QAC9B,MAAM,SAAS,MAAM,GAAG;QACxB,MAAM,QAAQ,MAAM,GAAG;QACvB,MAAM,IAAI,CAAC,QAAQ;QACnB,OAAO,EAAE;IACb;IACA,MAAO,CAAC,mBAAmB,OAAO;QAC9B,MAAM,QAAQ,MAAM,GAAG;QACvB,MAAM,SAAS,MAAM,GAAG;QACxB,MAAM,IAAI,CAAC,CAAA,GAAA,yCAAM,EAAE,IAAI,CAAC,OAAO;QAC/B,OAAO,EAAE;IACb;IACA,MAAO,CAAC,kBAAkB,OAAO;QAC7B,MAAM,OAAO,MAAM,GAAG;QACtB,MAAM,UAAU,KAAK,KAAK;QAC1B,MAAM,OAAO,KAAK,IAAI;QACtB,IAAI,QAAQ,MAAM,EAAE;YAChB,MAAM,SAAS,CAAA,GAAA,yCAAW,EAAE,SAAS;YACrC,MAAM,IAAI,CAAC,OAAO,KAAK;YACvB,OAAO,OAAO,IAAI;QACtB;QACA,MAAM,KAAK,QAAQ,KAAK;QACxB,IAAI,GAAG,MAAM,EAAE;YACX,MAAM,CAAC,aAAa,UAAU,GAAG,GAAG,IAAI;YACxC,IAAI,YAAY,MAAM,IAAI,CAAC,UAAU,MAAM,EACvC,MAAM,IAAI,MACN,CAAC,mDAAmD,EAAE,GAAG,cAAc,CAAC,CAAC,CAAC;YAElF,MAAM,iBAAiB,QAAQ,IAAI;YACnC,MAAM,IAAI,CAAC,aAAa;YACxB,iBAAiB,IAAI,CAAC,0CAAa,KAAK;YACxC,OAAO,CAAA,GAAA,yCAAI,EAAE,KAAK;QACtB;QACA,IAAI,cAAc,QAAQ,IAAI;QAC9B,IAAI,CAAA,GAAA,yBAAS,EAAE,GAAG,IAAI,EAAE,CAAA,GAAA,yCAAQ,IAAI;YAChC,MAAM,IAAI,CAAC;YACX,OAAO,CAAA,GAAA,yCAAI,EAAE,KAAK;QACtB;QACA,iBAAiB,IAAI,CAAC,0CAAa,KAAK;QACxC,MAAM,IAAI,CAAC;QACX,MAAO,CAAC,YAAY,MAAM,CAAE;YACxB,MAAM,IAAI,CAAC,CAAA,GAAA,yCAAM,EAAE,IAAI,CAAC,YAAY,KAAK,EAAE;YAC3C,iBAAiB,IAAI,CACjB,0CAAa,IAAI,EACjB,0CAAa,IAAI,EACjB,0CAAa,IAAI;YAErB,cAAc,YAAY,IAAI;QAClC;QACA,MAAM,IAAI,CAAC,CAAA,GAAA,yCAAM,EAAE,GAAG;QACtB,OAAO,EAAE;IACb;IACA,OAAQ,CAAC,kBAAkB,OAAO;QAC9B,MAAM,cAAc,MAAM,GAAG;QAC7B,MAAM,KAAK,MAAM,GAAG;QACpB,IAAI,GAAG,MAAM,EACT,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,GAAG,cAAc,CAAC,CAAC,CAAC;QACrE,IAAI,CAAA,GAAA,yBAAS,EAAE,GAAG,IAAI,EAAE,CAAA,GAAA,yCAAQ,IAAI;YAChC,MAAM,OAAO,YAAY,MAAM;YAC/B,IAAI,KAAK,MAAM,KAAK,GAChB,MAAM,IAAI,MACN,CAAC,oCAAoC,EAAE,YAAY,cAAc,CAAC,CAAC,CAAC;YAE5E,MAAM,IAAI,CAAC,CAAA,GAAA,yCAAM,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE;YACxC,iBAAiB,IAAI,CAAC,0CAAa,IAAI;YACvC,OAAO,CAAA,GAAA,yCAAI,EAAE,KAAK;QACtB;QACA,MAAM,SAAS,CAAA,GAAA,yCAAU,EAAE,IAAI,aAAa;QAC5C,MAAM,IAAI,CAAC,OAAO,KAAK;QACvB,OAAO,OAAO,IAAI;IACtB;AACJ;;;;;;AI3EO,SAAS,0CAAY,OAAiB;IACzC,MAAM,YAA2B,EAAE;IACnC,IAAI,OAAO,CAAC,EAAE,IAAI,MACd,OAAO,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,WAAW,IAAI,CAAC;QAAC,OAAO,CAAC,EAAE;KAAC;SACpD,IAAI,OAAO,CAAC,EAAE,IAAI,MAAM,UAAU,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG;SACpD,IAAI,OAAO,CAAC,EAAE,IAAI,MAAM;QACzB,UAAU,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG;QAC5B,QAAQ,KAAK;QACb,IAAI,CAAC,QAAQ,MAAM,EACf,MAAM,IAAI,CAAA,GAAA,yCAAU,EAAE;QAC1B,UAAU,IAAI,CAAC,OAAO,CAAC,EAAE;IAC7B,OAAO,IAAI,OAAO,CAAC,EAAE,IAAI,MAAM;QAC3B,UAAU,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG;QAC5B,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YACxB,QAAQ,KAAK;YACb,IAAI,CAAC,QAAQ,MAAM,EACf,MAAM,IAAI,CAAA,GAAA,yCAAU,EAAE;YAC1B,UAAU,IAAI,CAAC,OAAO,CAAC,EAAE;QAC7B;IACJ,OAAO,IAAI,OAAO,CAAC,EAAE,IAAI,MAAM;QAC3B,UAAU,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG;QAC5B,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YACxB,QAAQ,KAAK;YACb,IAAI,CAAC,QAAQ,MAAM,EACf,MAAM,IAAI,CAAA,GAAA,yCAAU,EAAE;YAC1B,UAAU,IAAI,CAAC,OAAO,CAAC,EAAE;QAC7B;IACJ,OAAO,IAAI,OAAO,CAAC,EAAE,IAAI,MAAM;QAC3B,UAAU,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG;QAC5B,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YACxB,QAAQ,KAAK;YACb,IAAI,CAAC,QAAQ,MAAM,EACf,MAAM,IAAI,CAAA,GAAA,yCAAU,EAAE;YAC1B,UAAU,IAAI,CAAC,OAAO,CAAC,EAAE;QAC7B;IACJ,OAAO,IAAI,OAAO,CAAC,EAAE,KAAK,MAAM;QAC5B,QAAQ,KAAK;QACb,IAAI,CAAC,QAAQ,MAAM,EACf,MAAM,IAAI,CAAA,GAAA,yCAAU,EAAE;QAC1B,MAAM,QAAQ,0CAAY;QAC1B,QAAQ,KAAK;QACb,IAAI,CAAC,QAAQ,MAAM,EACf,MAAM,IAAI,CAAA,GAAA,yCAAU,EAAE;QAC1B,MAAM,OAAO,0CAAY;QACzB,OAAO,CAAA,GAAA,yCAAM,EAAE,IAAI,CAAC,OAAO;IAC/B,OAAO,MAAM,IAAI,CAAA,GAAA,yCAAU,EAAE;IAC7B,MAAM,OAAO,CAAA,GAAA,wBAAQ,EAAE,WAAW,IAAI,CAAC;IACvC,IAAI,QAAuB,EAAE;IAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,IAAK;QAC3B,QAAQ,KAAK;QACb,IAAI,CAAC,QAAQ,MAAM,EACf,MAAM,IAAI,CAAA,GAAA,yCAAU,EAAE;QAE1B,MAAM,IAAI,CAAC,OAAO,CAAC,EAAE;IACzB;IACA,OAAO,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,WAAW,IAAI,CAAC;AAC7C;;;;;;;;AE5DO,MAAM;IACF,KAAa;IACb,OAAe;IAEtB,YAAY,MAAc,EAAE,KAAa,CAAE;QACvC,SAAS,OAAO,UAAU,CAAC,QAAQ;QACnC,IAAI,OAAO;QACX,IAAI,SAAS;QACb,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IACvB,IAAI,MAAM,CAAC,EAAE,KAAK,MAAM;YACpB;YACA,SAAS;QACb,OACI;QAGR,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;IAClB;IAEO,WAAmB;QACtB,OAAO,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;IACxC;AACJ;;;;ADjBO,SAAS,0CAAK,MAAe;IAChC,OAAO,KAAK;IACZ,OAAO,MAAM,CAAC,EAAE;AACpB;AAEO,SAAS,0CAAO,MAAc,EAAE,MAAe;IAClD,MAAM,QAAQ,MAAM,CAAC,EAAE;IACvB,IAAI,CAAC,0CAAK,SACN,MAAM,IAAI,CAAA,GAAA,yCAAU,EAChB,CAAC,4BAA4B,EAAE,IAAI,CAAA,GAAA,yCAAO,EAAE,QAAQ,MAAM,KAAK,EAAE,CAAC,CAAC;AAE/E;AAEO,SAAS,0CAAQ,IAAY;IAChC,OAAO,oGAAoG,IAAI,CAC3G;AAER;AAEO,SAAS,0CAAkB,IAAY,EAAE,KAAa;IACzD,MAAO,KAAM;QACT,MAAO,QAAQ,KAAK,MAAM,IAAI,0CAAQ,IAAI,CAAC,MAAM,EAAG;QACpD,IAAI,SAAS,KAAK,MAAM,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK;QACjD,MAAO,QAAQ,KAAK,MAAM,IAAI,CAAC,OAAO,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAG;IACjE;IACA,OAAO;AACX;AAEO,SAAS,0CAAuB,IAAY,EAAE,KAAa;IAC9D,MAAM,QAAQ;IACd,MAAO,QAAQ,KAAK,MAAM,IAAI,CAAC,0CAAQ,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,KAAK,IACnE;IACJ,OAAO;QAAE,MAAM,KAAK,KAAK,CAAC,OAAO;eAAQ;IAAM;AACnD;AAEO,SAAS,0CAAa,MAAc,EAAE,MAAe;IACxD,IAAI,QAAQ,MAAM,CAAC,EAAE;IACrB,IAAI,MAAM,IAAI,KAAK,KACf,OAAO,CAAA,GAAA,yCAAM,EAAE,SAAS,CAAC,WAAW,IAAI,CAAC,EAAE,GAAG,EAAE,CAC5C,IAAI,CAAA,GAAA,yCAAO,EAAE,QAAQ,MAAM,KAAK;IAExC,MAAM,YAAY,MAAM,KAAK;IAC7B,MAAM,QAAQ,0CAAa,QAAQ;IACnC,0CAAO,QAAQ;IACf,QAAQ,MAAM,CAAC,EAAE;IACjB,IAAI;IACJ,IAAI,MAAM,IAAI,KAAK,KAAK;QACpB,MAAM,WAAW,MAAM,KAAK;QAC5B,0CAAO,QAAQ;QACf,QAAQ,MAAM,CAAC,EAAE;QACjB,OAAO,0CAAa,QAAQ;QAC5B,0CAAO,QAAQ;QACf,QAAQ,MAAM,CAAC,EAAE;QACjB,IAAI,MAAM,IAAI,KAAK,KACf,MAAM,IAAI,CAAA,GAAA,yCAAU,EAChB,CAAC,0BAA0B,EAAE,IAAI,CAAA,GAAA,yCAAO,EAAE,QAAQ,UAAU,CAAC,CAAC;IAE1E,OAAO,OAAO,0CAAa,QAAQ;IACnC,OAAO,CAAA,GAAA,yCAAM,EAAE,IAAI,CAAC,OAAO,MAAM,EAAE,CAAC,IAAI,CAAA,GAAA,yCAAO,EAAE,QAAQ;AAC7D;AAEO,SAAS,0CAAY,MAAc,EAAE,KAAY;IACpD,OAAO,6BAA6B,IAAI,CAAC,MAAM,IAAI,IAC7C,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,KAAK,MAAM,EAAE,CACzD,IAAI,CAAA,GAAA,yCAAO,EAAE,QAAQ,MAAM,KAAK,KAEpC;AACV;AAEO,SAAS,0CAAY,MAAc,EAAE,KAAY;IACpD,IACI,MAAM,IAAI,CAAC,MAAM,IAAI,KACrB,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,WAAW,OAAO,MAC3C;QACE,IAAI,MAAM,MAAM,IAAI,CAAC,KAAK,CAAC;QAC3B,IAAI,IAAI,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC;QACzC,IAAI;YACA,OAAO,CAAA,GAAA,yCAAM,EAAE,OAAO,CAAC,KAAK,EAAE,CAAC,IAAI,CAAA,GAAA,yCAAO,EAAE,QAAQ,MAAM,KAAK;QACnE,EAAE,OAAO,GAAG;YACR,MAAM,IAAI,CAAA,GAAA,yCAAU,EAChB,CAAC,YAAY,EAAE,KAAK,SAAS,CAAC,MAAM,IAAI,EAAE,IAAI,EAAE,IAAI,CAAA,GAAA,yCAAO,EACvD,QACA,MAAM,KAAK,EACb,CAAC,CAAC;QAEZ;IACJ,OAAO,OAAO;AAClB;AAEO,SAAS,0CAAe,MAAc,EAAE,KAAY;IACvD,IAAI,MAAM,IAAI,CAAC,MAAM,GAAG,GAAG,OAAO;IAClC,MAAM,QAAQ,MAAM,IAAI,CAAC,EAAE;IAC3B,IAAI,CAAC,MAAM,QAAQ,CAAC,QAAQ,OAAO;IACnC,IAAI,MAAM,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,GAAG,EAAE,KAAK,OACtC,MAAM,IAAI,CAAA,GAAA,yCAAU,EAChB,CAAC,oBAAoB,EAAE,KAAK,SAAS,CACjC,MAAM,IAAI,EACZ,IAAI,EAAE,IAAI,CAAA,GAAA,yCAAO,EAAE,QAAQ,MAAM,KAAK,EAAE,CAAC,CAAC;IAEpD,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC,MAAM,GAAG,IAAI,EAAE,CAClE,IAAI,CAAA,GAAA,yCAAO,EAAE,QAAQ,MAAM,KAAK;AAExC;AAEO,SAAS,0CAAe,MAAc,EAAE,KAAY;IACvD,IAAI,OAAO,MAAM,IAAI;IACrB,IAAI,KAAK,UAAU,CAAC,MAAM,OAAO,KAAK,KAAK,CAAC;IAC5C,MAAM,UAA8B,CAAA,GAAA,yCAAO,CAAC,CAAC,KAA8B;IAC3E,OAAO,AACH,CAAA,YAAY,YACN,CAAA,GAAA,yCAAM,EAAE,QAAQ,CAAC,QACjB,CAAA,GAAA,yCAAM,EAAE,UAAU,CAAC,QAAO,EAClC,EAAE,CAAC,IAAI,CAAA,GAAA,yCAAO,EAAE,QAAQ,MAAM,KAAK;AACzC;AAEO,SAAS,0CAAa,MAAc,EAAE,MAAe;IACxD,MAAM,QAAQ,MAAM,CAAC,EAAE;IACvB,IAAI,MAAM,IAAI,KAAK,KAAK;QACpB,0CAAO,QAAQ;QACf,OAAO,0CAAa,QAAQ;IAChC;IACA,MAAM,SACF,0CAAY,QAAQ,UACpB,0CAAY,QAAQ,UACpB,0CAAe,QAAQ,UACvB,0CAAe,QAAQ;IAC3B,IAAI,CAAC,QACD,MAAM,IAAI,CAAA,GAAA,yCAAU,EAChB,CAAC,mBAAmB,EAAE,KAAK,SAAS,CAAC,MAAM,IAAI,EAAE,IAAI,EAAE,IAAI,CAAA,GAAA,yCAAO,EAC9D,QACA,MAAM,KAAK,EACb,CAAC,CAAC;IAEZ,OAAO;AACX;AAEO,UAAU,0CAAY,MAAc;IACvC,IAAI,QAAQ;IACZ,MAAO,QAAQ,OAAO,MAAM,CAAE;QAC1B,QAAQ,0CAAkB,QAAQ;QAClC,IAAI,SAAS,OAAO,MAAM,EAAE;QAC5B,MAAM,OAAO,MAAM,CAAC,MAAM;QAC1B,IAAI,MAAM,QAAQ,CAAC,OAAO;YACtB,MAAM;gBAAE,MAAM;uBAAM;YAAM;YAC1B;YACA;QACJ;QACA,IAAI,MAAM,QAAQ,CAAC,OAAO;YACtB,MAAM,QAAQ;YACd,MAAM,QAAQ,MAAM,CAAC,MAAM;YAC3B;YACA,MAAO,QAAQ,OAAO,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,MAAO;YACzD,IAAI,QAAQ,OAAO,MAAM,EAAE;gBACvB,MAAM;oBAAE,MAAM,OAAO,KAAK,CAAC,OAAO,QAAQ;oBAAI,OAAO;gBAAM;gBAC3D;gBACA;YACJ,OACI,MAAM,IAAI,CAAA,GAAA,yCAAU,EAChB,CAAC,uBAAuB,EAAE,IAAI,CAAA,GAAA,yCAAO,EAAE,QAAQ,OAAO,CAAC,CAAC;QAEpE;QACA,MAAM,QAAQ,0CAAuB,QAAQ;QAC7C,MAAM;YAAE,MAAM,MAAM,IAAI;mBAAE;QAAM;QAChC,QAAQ,MAAM,KAAK;IACvB;AACJ;;;;AlB1HO,MAAM;IACT,OAAc,OAAO,YAAY;IACjC,OAAc,OAAO,0CAAQ,SAAS,CAAC,WAAW,IAAI,CAAC;QAAC;KAAE,GAAG;IAC7D,OAAc,QAAQ,0CAAQ,SAAS,CAAC,WAAW,IAAI,CAAC,EAAE,GAAG;IAC7D,OAAc,MAAM,0CAAQ,KAAK,CAAC;IAElB,MAAa;IACtB,SAAoB;IAE3B,IAAW,OAAmB;QAC1B,IAAI,CAAC,IAAI,CAAC,MAAM,EACZ,MAAM,IAAI,MAAM,CAAC,aAAa,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;QAC1D,OAAO,IAAI,CAAC,KAAK;IACrB;IAEA,IAAW,OAAa;QACpB,IAAI,CAAC,IAAI,CAAC,MAAM,EACZ,MAAM,IAAI,MAAM,CAAC,aAAa,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;QAC1D,OAAO,IAAI,CAAC,KAAK;IACrB;IAEA,IAAW,QAAiB;QACxB,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE;IACvB;IAEA,IAAW,OAAgB;QACvB,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE;IACvB;IAEA,IAAW,SAAS;QAChB,OAAO,IAAI,CAAC,KAAK,YAAY;IACjC;IAEA,IAAW,SAAS;QAChB,OAAO,MAAM,OAAO,CAAC,IAAI,CAAC,KAAK;IACnC;IAEA,IAAW,SAAkB;QACzB,OAAO,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK;IAChD;IAEA,OAAc,KAAK,KAAc,EAAE,IAAa,EAAW;QACvD,OAAO,IAAI,0CAAQ;YAAC;YAAO;SAAK;IACpC;IAEA,OAAc,UAAU,KAAiB,EAAW;QAChD,OAAO,IAAI,0CAAQ;IACvB;IAEA,OAAc,kBAAkB,aAA4B,EAAW;QACnE,OAAO,IAAI,0CAAQ,cAAc,OAAO;IAC5C;IAEA,OAAc,eAAe,UAAsB,EAAW;QAC1D,OAAO,IAAI,0CAAQ,WAAW,OAAO;IACzC;IAEA,OAAc,QAAQ,GAAW,EAAW;QACxC,OAAO,IAAI,0CAAQ,CAAA,GAAA,sBAAM,EAAE;IAC/B;IAEA,OAAc,SAAS,KAAc,EAAW;QAC5C,OAAO,QAAQ,0CAAQ,IAAI,GAAG,0CAAQ,KAAK;IAC/C;IAEA,OAAc,QAAQ,KAAa,EAAW;QAC1C,OAAO,IAAI,0CAAQ,CAAA,GAAA,wBAAQ,EAAE;IACjC;IAEA,OAAc,WAAW,KAAa,EAAW;QAC7C,OAAO,IAAI,0CAAQ,CAAA,GAAA,2BAAW,EAAE;IACpC;IAEA,OAAc,SAAS,IAAY,EAAW;QAC1C,OAAO,IAAI,0CAAQ,IAAI,cAAc,MAAM,CAAC;IAChD;IAEA,OAAc,WAAW,MAAc,EAAW;QAC9C,MAAM,SAAS,CAAA,GAAA,yCAAU,EAAE;QAC3B,MAAM,SAAS;eAAI;SAAO;QAC1B,IAAI,OAAO,MAAM,EAAE,OAAO,CAAA,GAAA,yCAAW,EAAE,QAAQ;aAC1C,MAAM,IAAI,CAAA,GAAA,yCAAU,EAAE;IAC/B;IAEA,OAAc,SAAS,QAAmB,EAAW;QACjD,IAAI,SAAS,0CAAQ,GAAG;QACxB,KAAK,MAAM,WAAW,SAAS,OAAO,GAClC,SAAS,0CAAQ,IAAI,CAAC,SAAS;QACnC,OAAO;IACX;IAEA,OAAc,YAAY,KAAiB,EAAW;QAClD,MAAM,UAAU;eAAI;SAAM;QAC1B,IAAI,CAAC,QAAQ,MAAM,EAAE,MAAM,IAAI,CAAA,GAAA,yCAAU,EAAE;QAC3C,OAAO,CAAA,GAAA,yCAAU,EAAE;IACvB;IAEA,OAAc,eAAe,GAAW,EAAW;QAC/C,OAAO,0CAAQ,WAAW,CAAC,CAAA,GAAA,sBAAM,EAAE;IACvC;IAEA,YAAY,KAAY,CAAE;QACtB,IAAI,CAAC,KAAK,GAAG;IACjB;IAEA,IAAW,iBAAyB;QAChC,OAAO,IAAI,CAAC,QAAQ,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG;IACpD;IAEO,GAAG,QAAkB,EAAQ;QAChC,IAAI,CAAC,QAAQ,GAAG;QAChB,OAAO,IAAI;IACf;IAEO,MAAM,IAAe,EAAW;QACnC,OAAO,0CAAQ,UAAU,CACrB,iMACF,GAAG,CAAC,0CAAQ,IAAI,CAAC,IAAI,EAAE,0CAAQ,QAAQ,CAAC,QAAQ,KAAK;IAC3D;IAEO,UAAuC;QAC1C,MAAM,yBAAyB,0CAAQ,UAAU,CAC7C;QAEJ,MAAM,qBAAqB,0CAAQ,UAAU,CACzC;QAGJ,IAAI,SAAS,CAAA,GAAA,yCAAI,EAAE,wBAAwB,IAAI;QAC/C,IAAI,CAAC,QAAQ,OAAO;QAEpB,MAAM,KAAK,OAAO,QAAQ;QAC1B,IAAI,OAAO,OAAO,IAAI;QAEtB,MAAM,OAAuB,EAAE;QAE/B,MAAO,KAAM;YACT,SAAS,CAAA,GAAA,yCAAI,EAAE,oBAAoB;YACnC,IAAI,CAAC,QAAQ;YAEb,KAAK,IAAI,CAAC,OAAO,IAAI;YACrB,OAAO,OAAO,IAAI;QACtB;QAEA,IAAI,KAAK,MAAM,IAAI,KAAK,QAAQ,OAAO,EAAE,EAAE,OAAO;YAAC;YAAI;SAAK;QAC5D,OAAO;IACX;IAEO,OAAmB;QACtB,OAAO,IAAI,CAAC,MAAM,GACZ,CAAA,GAAA,sBAAM,EAAE,CAAA,GAAA,0BAAU,EAAE,WAAW,IAAI,CAAC;YAAC;SAAE,GAAG,IAAI,CAAC,IAAI,KACnD,CAAA,GAAA,sBAAM,EACF,CAAA,GAAA,0BAAU,EACN,WAAW,IAAI,CAAC;YAAC;SAAE,GACnB,IAAI,CAAC,KAAK,CAAC,IAAI,IACf,IAAI,CAAC,IAAI,CAAC,IAAI;IAGhC;IAEO,UAAkB;QACrB,OAAO,CAAA,GAAA,oBAAI,EAAE,IAAI,CAAC,IAAI;IAC1B;IAEO,OAAO,OAAgB,EAAW;QACrC,IAAI,SAAkB,IAAI;QAC1B,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,OAAO,OAC5D,SAAS,0CAAQ,QAAQ,CAAC;YACtB,0CAAQ,QAAQ,CAAC;YACjB,0CAAQ,GAAG;YACX,IAAI;SACP;QACL,MAAM,QAAQ,OAAO,MAAM;QAC3B,MAAM,MAAM,CAAC,GAAG,GAAG;QACnB,OAAO,0CAAQ,QAAQ,CAAC;IAC5B;IAEO,UAAU,QAAmB,EAAW;QAC3C,IAAI,SAAkB,IAAI;QAC1B,KAAK,MAAM,WAAW,SAAS,OAAO,GAClC,SAAS,OAAO,MAAM,CAAC;QAC3B,OAAO;IACX;IAEO,QAAQ,UAAmC,CAAC,CAAC,EAAiB;QACjE,MAAM,cAA8B;YAChC,QAAQ;YACR,WAAW,CAAA,GAAA,yCAAmB;YAC9B,kBAAkB,CAAC;YACnB,GAAG,OAAO;QACd;QACA,IAAI,YAAY,MAAM,EAClB,YAAY,SAAS,CAAC,OAAO,GAAG,CAAC,WAAW;YACxC,MAAM,IAAI,MACN,CAAC,sBAAsB,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QAEvD;QACJ,SAAS,kBAAkB,IAAa;YACpC,MAAM,WAAW,KAAK,KAAK,CAAC,MAAM;YAClC,KAAK,MAAM,CAAC,MAAM,MAAM,IAAI,OAAO,OAAO,CACtC,YAAY,gBAAgB,EAC7B;gBACC,IAAI,YAAY,OACZ,OAAO;oBACH,OAAO,0CAAQ,QAAQ,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,SAAS,CAAC;oBAC7C,MAAM,EAAE;gBACZ;YACR;YACA,MAAM,IAAI,MAAM,CAAC,WAAW,EAAE,SAAS,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QACnE;QACA,SAAS,OAAO,IAAa;YACzB,MAAM,WAAW,KAAK,KAAK,CAAC,MAAM;YAClC,IAAI,SAAwB;YAC5B,KAAK,MAAM,CAAC,MAAM,MAAM,IAAI,OAAO,OAAO,CACtC,YAAY,gBAAgB,EAC7B;gBACC,KAAK,MAAM,CAAC,MAAM,QAAQ,IAAI,OAAO,OAAO,CAAC,OACzC,IAAI,aAAa,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,SAAS;YAErD;YACA,IAAI,WAAW,MACX,MAAM,IAAI,MACN,CAAC,WAAW,EAAE,SAAS,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;YAEvD,OAAO;gBAAE,OAAO,0CAAQ,UAAU,CAAC;gBAAS,MAAM,EAAE;YAAC;QACzD;QACA,iEAAiE;QACjE,SAAS,QAAQ,KAAc;YAC3B,OAAO;gBAAE,OAAO,0CAAQ,GAAG;gBAAE,MAAM,EAAE;YAAC;QAC1C;QAEA,SAAS,WAAW,OAAgB,EAAE,IAAa;YAC/C,OAAO,QAAQ,GAAG,CAAC,MAAM;QAC7B;QACA,MAAM,WAAW;YACb,KAAK,CAAA,GAAA,yCAAQ,EAAE;YACf,KAAK,CAAA,GAAA,yCAAQ,EAAE;YACf,qBAAqB;YACrB,OAAO;YACP,QAAQ;QACZ;QACA,OAAO,MAAM,CAAC,YAAY,SAAS,CAAC,SAAS,EAAE;QAC/C,OAAO,WACH,0CAAQ,UAAU,CAAC,wBACnB,0CAAQ,QAAQ,CAAC;YAAC,IAAI;SAAC;IAE/B;IAEO,IACH,WAAoB,EACpB,UAA+B,CAAC,CAAC,EACpB;QACb,MAAM,cAA0B;YAC5B,QAAQ;YACR,WAAW,CAAA,GAAA,yCAAmB;YAC9B,GAAG,OAAO;QACd;QACA,IAAI,YAAY,MAAM,EAClB,YAAY,SAAS,CAAC,OAAO,GAAG,CAAC,WAAW;YACxC,MAAM,IAAI,MACN,CAAC,sBAAsB,EAAE,KAAK,cAAc,CAAC,CAAC,CAAC;QAEvD;QACJ,MAAM,mBAAuC;YAAC,CAAA,GAAA,yCAAW,EAAE,IAAI;SAAC;QAChE,MAAM,QAAwB;YAAC,0CAAQ,IAAI,CAAC,IAAI,EAAE;SAAa;QAC/D,IAAI,OAAO,EAAE;QACb,MAAO,iBAAiB,MAAM,CAAE;YAC5B,MAAM,cAAc,iBAAiB,GAAG;YACxC,QAAQ,YAAY,kBAAkB,OAAO;YAC7C,IAAI,YAAY,OAAO,KAAK,aAAa,OAAO,YAAY,OAAO,EAC/D,MAAM,IAAI,MACN,CAAC,iBAAiB,EAAE,YAAY,OAAO,CAAC,EACpC,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,CAAC,cAAc,CACzC,CAAC,CAAC;QAEf;QACA,OAAO;YACH,OAAO,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE;kBAC9B;QACJ;IACJ;IAEO,UAAsB;QACzB,IAAI,IAAI,CAAC,MAAM,EACX,MAAM,IAAI,MACN,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,GAAG,OAAO,EACrC,IAAI,CAAC,cAAc,CACtB,CAAC,CAAC;QAEX,OAAO,IAAI,CAAC,IAAI;IACpB;IAEO,kBAAiC;QACpC,IAAI,IAAI,CAAC,MAAM,IAAK,IAAI,CAAC,IAAI,CAAC,MAAM,KAAK,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,KAAK,IAChE,MAAM,IAAI,MACN,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,GAAG,iBAAiB,EAC/C,IAAI,CAAC,cAAc,CACtB,CAAC,CAAC;QAEX,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,KAAK,KACtB,CAAA,GAAA,4BAAY,EAAE,WAAW,CAAC,IAAI,CAAC,IAAI,IACnC,CAAA,GAAA,4BAAY,EAAE,WAAW,CAAC,IAAI,CAAC,IAAI;IAC7C;IAEO,eAA2B;QAC9B,IAAI,IAAI,CAAC,MAAM,EACX,MAAM,IAAI,MACN,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,GAAG,eAAe,EAC7C,IAAI,CAAC,cAAc,CACtB,CAAC,CAAC;QAEX,OAAO,CAAA,GAAA,yBAAS,EAAE,SAAS,CAAC,IAAI,CAAC,IAAI;IACzC;IAEO,QAAgB;QACnB,IAAI,IAAI,CAAC,MAAM,EACX,MAAM,IAAI,MACN,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,GAAG,OAAO,EACrC,IAAI,CAAC,cAAc,CACtB,CAAC,CAAC;QAEX,OAAO,CAAA,GAAA,oBAAI,EAAE,IAAI,CAAC,IAAI;IAC1B;IAEO,SAAkB;QACrB,IAAI,IAAI,CAAC,MAAM,EACX,MAAM,IAAI,MACN,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,GAAG,QAAQ,EACtC,IAAI,CAAC,cAAc,CACtB,CAAC,CAAC;QAEX,OAAO,CAAC,IAAI,CAAC,MAAM;IACvB;IAEO,QAAgB;QACnB,IAAI,IAAI,CAAC,MAAM,EACX,MAAM,IAAI,MACN,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,GAAG,OAAO,EACrC,IAAI,CAAC,cAAc,CACtB,CAAC,CAAC;QAEX,OAAO,CAAA,GAAA,wBAAQ,EAAE,IAAI,CAAC,IAAI;IAC9B;IAEO,WAAmB;QACtB,IAAI,IAAI,CAAC,MAAM,EACX,MAAM,IAAI,MACN,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,GAAG,UAAU,EACxC,IAAI,CAAC,cAAc,CACtB,CAAC,CAAC;QAEX,OAAO,CAAA,GAAA,2BAAW,EAAE,IAAI,CAAC,IAAI;IACjC;IAEO,SAAiB;QACpB,IAAI,IAAI,CAAC,MAAM,EACX,MAAM,IAAI,MACN,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,GAAG,QAAQ,EACtC,IAAI,CAAC,cAAc,CACtB,CAAC,CAAC;QAEX,OAAO,IAAI,cAAc,MAAM,CAAC,IAAI,CAAC,IAAI;IAC7C;IAEO,SAAS,eAAwB,IAAI,EAAU;QAClD,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,IAAI,IAAI,CAAC,MAAM,EAAE,OAAO;iBACnB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,GACzB,IAAI;gBACA,MAAM,SAAS,IAAI,CAAC,MAAM;gBAC1B,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAK;oBACpC,IAAI,CAAC,CAAA,GAAA,yCAAQ,EAAE,QAAQ,CAAC,MAAM,CAAC,EAAE,GAC7B,OAAO,CAAC,EAAE,EAAE,IAAI,CAAC,KAAK,GAAG,CAAC;gBAClC;gBACA,IAAI,OAAO,QAAQ,CAAC,QAAQ,OAAO,QAAQ,CAAC,MACxC,OAAO,CAAC,EAAE,EAAE,IAAI,CAAC,KAAK,GAAG,CAAC;gBAC9B,MAAM,QAAQ,OAAO,QAAQ,CAAC,OAAO,MAAM;gBAC3C,OAAO,QAAQ,SAAS;YAC5B,EAAE,OAAM;gBACJ,OAAO,CAAC,EAAE,EAAE,IAAI,CAAC,KAAK,GAAG,CAAC;YAC9B;iBACG,IAAI,CAAA,GAAA,yBAAS,EAAE,CAAA,GAAA,wBAAQ,EAAE,CAAA,GAAA,wBAAQ,EAAE,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,GAC5D,OAAO,CAAA,GAAA,wBAAQ,EAAE,IAAI,CAAC,IAAI,EAAE,QAAQ;iBACnC,OAAO,CAAC,EAAE,EAAE,IAAI,CAAC,KAAK,GAAG,CAAC;QACnC,OAAO;YACH,IAAI,SAAS;YACb,IAAI,gBAAgB,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;gBACnC,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ;gBACjC,MAAM,UAAU,OAAO,IAAI,CAAC,CAAA,GAAA,yCAAO,GAAG,IAAI,CACtC,CAAC,UACG,CAAA,GAAA,yCAAO,CAAC,CAAC,QAAiC,KAAK;gBAEvD,UAAU,UAAU,UAAU,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;YACtD,OAAO,UAAU,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;YACrC,IAAI,UAAU,IAAI,CAAC,IAAI,CAAC,EAAE;YAC1B,MAAO,QAAQ,MAAM,CAAE;gBACnB,UAAU,CAAC,CAAC,EAAE,QAAQ,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC;gBACpD,UAAU,QAAQ,IAAI,CAAC,EAAE;YAC7B;YACA,UACI,AAAC,CAAA,QAAQ,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,QAAQ,QAAQ,CAAC,cAAc,CAAC,AAAD,IAC5D;YACJ,OAAO;QACX;IACJ;IAEO,OAAO,SAAkB,KAAK,EAAa;QAC9C,MAAM,SAAyB,EAAE;QACjC,IAAI,UAAmB,IAAI;QAC3B,MAAO,QAAQ,MAAM,CAAE;YACnB,MAAM,OAAO,QAAQ,KAAK;YAC1B,OAAO,IAAI,CAAC;YACZ,UAAU,QAAQ,IAAI;QAC1B;QACA,IAAI,CAAC,QAAQ,MAAM,IAAI,QACnB,MAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;QACjE,OAAO;IACX;IAEO,YAAwB;QAC3B,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,IAAI,IAAI,CAAC,MAAM,EAAE,OAAO,WAAW,IAAI,CAAC;gBAAC;aAAK;iBACzC,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,KAAK,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,MAC/C,OAAO,IAAI,CAAC,IAAI;iBACf;gBACD,MAAM,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM;gBAC7B,MAAM,SAAwB,EAAE;gBAChC,IAAI,OAAO,MAAM,OAAO,IAAI,CAAC,OAAO;qBAC/B,IAAI,OAAO,QAAQ;oBACpB,OAAO,IAAI,CAAC,OAAQ,QAAQ;oBAC5B,OAAO,IAAI,CAAC,AAAC,QAAQ,IAAK;gBAC9B,OAAO,IAAI,OAAO,UAAU;oBACxB,OAAO,IAAI,CAAC,OAAQ,QAAQ;oBAC5B,OAAO,IAAI,CAAC,AAAC,QAAQ,IAAK;oBAC1B,OAAO,IAAI,CAAC,AAAC,QAAQ,IAAK;gBAC9B,OAAO,IAAI,OAAO,WAAW;oBACzB,OAAO,IAAI,CAAC,OAAQ,QAAQ;oBAC5B,OAAO,IAAI,CAAC,AAAC,QAAQ,KAAM;oBAC3B,OAAO,IAAI,CAAC,AAAC,QAAQ,IAAK;oBAC1B,OAAO,IAAI,CAAC,AAAC,QAAQ,IAAK;gBAC9B,OAAO,IAAI,OAAO,aAAa;oBAC3B,OAAO,IAAI,CAAC,OAAQ,QAAQ;oBAC5B,OAAO,IAAI,CAAC,AAAC,QAAQ,KAAM;oBAC3B,OAAO,IAAI,CAAC,AAAC,QAAQ,KAAM;oBAC3B,OAAO,IAAI,CAAC,AAAC,QAAQ,IAAK;oBAC1B,OAAO,IAAI,CAAC,AAAC,QAAQ,IAAK;gBAC9B,OACI,MAAM,IAAI,WACN,CAAC,iBAAiB,EAAE,IAAI,CAAC,QAAQ,GAAG,8CAA8C,EAC9E,IAAI,CAAC,cAAc,CACtB,CAAC,CAAC;gBAEX,KAAK,MAAM,QAAQ,IAAI,CAAC,IAAI,CAAE,OAAO,IAAI,CAAC;gBAC1C,OAAO,WAAW,IAAI,CAAC;YAC3B;QACJ,OAAO;YACH,MAAM,SAAS;gBAAC;aAAK;YACrB,KAAK,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,SAAS,GAAI,OAAO,IAAI,CAAC;YACvD,KAAK,MAAM,QAAQ,IAAI,CAAC,IAAI,CAAC,SAAS,GAAI,OAAO,IAAI,CAAC;YACtD,OAAO,WAAW,IAAI,CAAC;QAC3B;IACJ;IAEO,eAAuB;QAC1B,OAAO,CAAA,GAAA,oBAAI,EAAE,IAAI,CAAC,SAAS;IAC/B;IAEO,OAAO,KAAc,EAAW;QACnC,OACI,IAAI,CAAC,MAAM,KAAK,MAAM,MAAM,IAC3B,CAAA,IAAI,CAAC,MAAM,GACN,CAAA,GAAA,yBAAS,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM,IAAI,IAChC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,KAAK,KAC7B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,CAAA;IAEzC;IAEO,WAAmB;QACtB,OAAO,IAAI,CAAC,QAAQ;IACxB;AACJ;;","sources":["src/index.ts","src/types/ParserError.ts","src/types/Program.ts","src/constants/keywords.ts","src/constants/printable.ts","src/utils/compile.ts","src/constants/atoms.ts","src/types/BetterSet.ts","src/types/NodePath.ts","src/utils/helpers.ts","src/utils/macros.ts","src/utils/mod.ts","src/utils/compare.ts","src/utils/optimize.ts","src/utils/match.ts","src/utils/instructions.ts","src/constants/costs.ts","src/utils/environment.ts","src/utils/operators.ts","src/utils/ir.ts","src/utils/parser.ts","src/types/Position.ts"],"sourcesContent":["export * from './types/ParserError';\nexport {\n    Program,\n    type CompileOptions,\n    type Cons,\n    type ProgramOutput,\n    type RunOptions,\n    type Value,\n} from './types/Program';\n","export class ParserError extends Error {\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, ParserError.prototype);\n    }\n}\n","import {\n    bytesEqual,\n    concatBytes,\n    decodeBigInt,\n    decodeInt,\n    encodeBigInt,\n    encodeInt,\n    fromHex,\n    hash256,\n    JacobianPoint,\n    PrivateKey,\n    toHex,\n} from 'chia-bls';\nimport { keywords } from '../constants/keywords';\nimport { printable } from '../constants/printable';\nimport { makeDoCom } from '../utils/compile';\nimport { instructions } from '../utils/instructions';\nimport { deserialize } from '../utils/ir';\nimport { match } from '../utils/match';\nimport { makeDefaultOperators, Operators } from '../utils/operators';\nimport { makeDoOpt } from '../utils/optimize';\nimport { tokenizeExpr, tokenStream } from '../utils/parser';\nimport { ParserError } from './ParserError';\nimport { Position } from './Position';\n\nexport interface ProgramOutput {\n    value: Program;\n    cost: bigint;\n}\n\nexport interface RunOptions {\n    maxCost?: bigint;\n    operators: Operators;\n    strict: boolean;\n}\n\nexport interface CompileOptions extends RunOptions {\n    includeFilePaths: Record<string, Record<string, string>>;\n}\n\nexport type Cons = [Program, Program];\nexport type Value = Cons | Uint8Array;\n\nexport type Instruction = (\n    instructions: Instruction[],\n    stack: Program[],\n    options: RunOptions\n) => bigint;\n\nexport class Program {\n    public static cost = 11000000000;\n    public static true = Program.fromBytes(Uint8Array.from([1]));\n    public static false = Program.fromBytes(Uint8Array.from([]));\n    public static nil = Program.false;\n\n    public readonly value: Value;\n    public position?: Position;\n\n    public get atom(): Uint8Array {\n        if (!this.isAtom)\n            throw new Error(`Expected atom${this.positionSuffix}.`);\n        return this.value as Uint8Array;\n    }\n\n    public get cons(): Cons {\n        if (!this.isCons)\n            throw new Error(`Expected cons${this.positionSuffix}.`);\n        return this.value as Cons;\n    }\n\n    public get first(): Program {\n        return this.cons[0];\n    }\n\n    public get rest(): Program {\n        return this.cons[1];\n    }\n\n    public get isAtom() {\n        return this.value instanceof Uint8Array;\n    }\n\n    public get isCons() {\n        return Array.isArray(this.value);\n    }\n\n    public get isNull(): boolean {\n        return this.isAtom && this.value.length === 0;\n    }\n\n    public static cons(first: Program, rest: Program): Program {\n        return new Program([first, rest]);\n    }\n\n    public static fromBytes(bytes: Uint8Array): Program {\n        return new Program(bytes);\n    }\n\n    public static fromJacobianPoint(jacobianPoint: JacobianPoint): Program {\n        return new Program(jacobianPoint.toBytes());\n    }\n\n    public static fromPrivateKey(privateKey: PrivateKey): Program {\n        return new Program(privateKey.toBytes());\n    }\n\n    public static fromHex(hex: string): Program {\n        return new Program(fromHex(hex));\n    }\n\n    public static fromBool(value: boolean): Program {\n        return value ? Program.true : Program.false;\n    }\n\n    public static fromInt(value: number): Program {\n        return new Program(encodeInt(value));\n    }\n\n    public static fromBigInt(value: bigint): Program {\n        return new Program(encodeBigInt(value));\n    }\n\n    public static fromText(text: string): Program {\n        return new Program(new TextEncoder().encode(text));\n    }\n\n    public static fromSource(source: string): Program {\n        const stream = tokenStream(source);\n        const tokens = [...stream];\n        if (tokens.length) return tokenizeExpr(source, tokens);\n        else throw new ParserError('Unexpected end of source.');\n    }\n\n    public static fromList(programs: Program[]): Program {\n        let result = Program.nil;\n        for (const program of programs.reverse())\n            result = Program.cons(program, result);\n        return result;\n    }\n\n    public static deserialize(bytes: Uint8Array): Program {\n        const program = [...bytes];\n        if (!program.length) throw new ParserError('Unexpected end of source.');\n        return deserialize(program);\n    }\n\n    public static deserializeHex(hex: string): Program {\n        return Program.deserialize(fromHex(hex));\n    }\n\n    constructor(value: Value) {\n        this.value = value;\n    }\n\n    public get positionSuffix(): string {\n        return this.position ? ` at ${this.position}` : '';\n    }\n\n    public at(position: Position): this {\n        this.position = position;\n        return this;\n    }\n\n    public curry(args: Program[]): Program {\n        return Program.fromSource(\n            '(a (q #a 4 (c 2 (c 5 (c 7 0)))) (c (q (c (q . 2) (c (c (q . 1) 5) (c (a 6 (c 2 (c 11 (q 1)))) 0))) #a (i 5 (q 4 (q . 4) (c (c (q . 1) 9) (c (a 6 (c 2 (c 13 (c 11 0)))) 0))) (q . 11)) 1) 1))'\n        ).run(Program.cons(this, Program.fromList(args))).value;\n    }\n\n    public uncurry(): [Program, Program[]] | null {\n        const uncurryPatternFunction = Program.fromSource(\n            '(a (q . (: . function)) (: . core))'\n        );\n        const uncurryPatternCore = Program.fromSource(\n            '(c (q . (: . parm)) (: . core))'\n        );\n\n        let result = match(uncurryPatternFunction, this);\n        if (!result) return null;\n\n        const fn = result.function;\n        let core = result.core;\n\n        const args: Array<Program> = [];\n\n        while (true) {\n            result = match(uncurryPatternCore, core);\n            if (!result) break;\n\n            args.push(result.parm);\n            core = result.core;\n        }\n\n        if (core.isAtom && core.toBigInt() === 1n) return [fn, args];\n        return null;\n    }\n\n    public hash(): Uint8Array {\n        return this.isAtom\n            ? hash256(concatBytes(Uint8Array.from([1]), this.atom))\n            : hash256(\n                  concatBytes(\n                      Uint8Array.from([2]),\n                      this.first.hash(),\n                      this.rest.hash()\n                  )\n              );\n    }\n\n    public hashHex(): string {\n        return toHex(this.hash());\n    }\n\n    public define(program: Program): Program {\n        let result: Program = this;\n        if (this.isAtom || this.first.isCons || this.first.toText() !== 'mod')\n            result = Program.fromList([\n                Program.fromText('mod'),\n                Program.nil,\n                this,\n            ]);\n        const items = result.toList();\n        items.splice(2, 0, program);\n        return Program.fromList(items);\n    }\n\n    public defineAll(programs: Program[]): Program {\n        let result: Program = this;\n        for (const program of programs.reverse())\n            result = result.define(program);\n        return result;\n    }\n\n    public compile(options: Partial<CompileOptions> = {}): ProgramOutput {\n        const fullOptions: CompileOptions = {\n            strict: false,\n            operators: makeDefaultOperators(),\n            includeFilePaths: {},\n            ...options,\n        };\n        if (fullOptions.strict)\n            fullOptions.operators.unknown = (_operator, args) => {\n                throw new Error(\n                    `Unimplemented operator${args.positionSuffix}.`\n                );\n            };\n        function doFullPathForName(args: Program): ProgramOutput {\n            const fileName = args.first.toText();\n            for (const [path, files] of Object.entries(\n                fullOptions.includeFilePaths\n            )) {\n                if (fileName in files)\n                    return {\n                        value: Program.fromText(`${path}/${fileName}`),\n                        cost: 1n,\n                    };\n            }\n            throw new Error(`Can't open ${fileName}${args.positionSuffix}.`);\n        }\n        function doRead(args: Program): ProgramOutput {\n            const fileName = args.first.toText();\n            let source: string | null = null;\n            for (const [path, files] of Object.entries(\n                fullOptions.includeFilePaths\n            )) {\n                for (const [file, content] of Object.entries(files)) {\n                    if (fileName === `${path}/${file}`) source = content;\n                }\n            }\n            if (source === null)\n                throw new Error(\n                    `Can't open ${fileName}${args.positionSuffix}.`\n                );\n            return { value: Program.fromSource(source), cost: 1n };\n        }\n        // Not functional, due to browser support. May reimplement later.\n        function doWrite(_args: Program): ProgramOutput {\n            return { value: Program.nil, cost: 1n };\n        }\n\n        function runProgram(program: Program, args: Program): ProgramOutput {\n            return program.run(args, fullOptions);\n        }\n        const bindings = {\n            com: makeDoCom(runProgram),\n            opt: makeDoOpt(runProgram),\n            _full_path_for_name: doFullPathForName,\n            _read: doRead,\n            _write: doWrite,\n        };\n        Object.assign(fullOptions.operators.operators, bindings);\n        return runProgram(\n            Program.fromSource('(a (opt (com 2)) 3)'),\n            Program.fromList([this])\n        );\n    }\n\n    public run(\n        environment: Program,\n        options: Partial<RunOptions> = {}\n    ): ProgramOutput {\n        const fullOptions: RunOptions = {\n            strict: false,\n            operators: makeDefaultOperators(),\n            ...options,\n        };\n        if (fullOptions.strict)\n            fullOptions.operators.unknown = (_operator, args) => {\n                throw new Error(\n                    `Unimplemented operator${args.positionSuffix}.`\n                );\n            };\n        const instructionStack: Array<Instruction> = [instructions.eval];\n        const stack: Array<Program> = [Program.cons(this, environment)];\n        let cost = 0n;\n        while (instructionStack.length) {\n            const instruction = instructionStack.pop()!;\n            cost += instruction(instructionStack, stack, fullOptions);\n            if (fullOptions.maxCost !== undefined && cost > fullOptions.maxCost)\n                throw new Error(\n                    `Exceeded cost of ${fullOptions.maxCost}${\n                        stack[stack.length - 1].positionSuffix\n                    }.`\n                );\n        }\n        return {\n            value: stack[stack.length - 1],\n            cost,\n        };\n    }\n\n    public toBytes(): Uint8Array {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to hex${\n                    this.positionSuffix\n                }.`\n            );\n        return this.atom;\n    }\n\n    public toJacobianPoint(): JacobianPoint {\n        if (this.isCons || (this.atom.length !== 48 && this.atom.length !== 96))\n            throw new Error(\n                `Cannot convert ${this.toString()} to JacobianPoint${\n                    this.positionSuffix\n                }.`\n            );\n        return this.atom.length === 48\n            ? JacobianPoint.fromBytesG1(this.atom)\n            : JacobianPoint.fromBytesG2(this.atom);\n    }\n\n    public toPrivateKey(): PrivateKey {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to private key${\n                    this.positionSuffix\n                }.`\n            );\n        return PrivateKey.fromBytes(this.atom);\n    }\n\n    public toHex(): string {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to hex${\n                    this.positionSuffix\n                }.`\n            );\n        return toHex(this.atom);\n    }\n\n    public toBool(): boolean {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to bool${\n                    this.positionSuffix\n                }.`\n            );\n        return !this.isNull;\n    }\n\n    public toInt(): number {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to int${\n                    this.positionSuffix\n                }.`\n            );\n        return decodeInt(this.atom);\n    }\n\n    public toBigInt(): bigint {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to bigint${\n                    this.positionSuffix\n                }.`\n            );\n        return decodeBigInt(this.atom);\n    }\n\n    public toText(): string {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to text${\n                    this.positionSuffix\n                }.`\n            );\n        return new TextDecoder().decode(this.atom);\n    }\n\n    public toSource(showKeywords: boolean = true): string {\n        if (this.isAtom) {\n            if (this.isNull) return '()';\n            else if (this.value.length > 2) {\n                try {\n                    const string = this.toText();\n                    for (let i = 0; i < string.length; i++) {\n                        if (!printable.includes(string[i]))\n                            return `0x${this.toHex()}`;\n                    }\n                    if (string.includes('\"') && string.includes(\"'\"))\n                        return `0x${this.toHex()}`;\n                    const quote = string.includes('\"') ? \"'\" : '\"';\n                    return quote + string + quote;\n                } catch {\n                    return `0x${this.toHex()}`;\n                }\n            } else if (bytesEqual(encodeInt(decodeInt(this.atom)), this.atom))\n                return decodeInt(this.atom).toString();\n            else return `0x${this.toHex()}`;\n        } else {\n            let result = '(';\n            if (showKeywords && this.first.isAtom) {\n                const value = this.first.toBigInt();\n                const keyword = Object.keys(keywords).find(\n                    (keyword) =>\n                        keywords[keyword as keyof typeof keywords] === value\n                );\n                result += keyword ? keyword : this.first.toSource(showKeywords);\n            } else result += this.first.toSource(showKeywords);\n            let current = this.cons[1];\n            while (current.isCons) {\n                result += ` ${current.first.toSource(showKeywords)}`;\n                current = current.cons[1];\n            }\n            result +=\n                (current.isNull ? '' : ` . ${current.toSource(showKeywords)}`) +\n                ')';\n            return result;\n        }\n    }\n\n    public toList(strict: boolean = false): Program[] {\n        const result: Array<Program> = [];\n        let current: Program = this;\n        while (current.isCons) {\n            const item = current.first;\n            result.push(item);\n            current = current.rest;\n        }\n        if (!current.isNull && strict)\n            throw new Error(`Expected strict list${this.positionSuffix}.`);\n        return result;\n    }\n\n    public serialize(): Uint8Array {\n        if (this.isAtom) {\n            if (this.isNull) return Uint8Array.from([0x80]);\n            else if (this.atom.length === 1 && this.atom[0] <= 0x7f)\n                return this.atom;\n            else {\n                const size = this.atom.length;\n                const result: Array<number> = [];\n                if (size < 0x40) result.push(0x80 | size);\n                else if (size < 0x2000) {\n                    result.push(0xc0 | (size >> 8));\n                    result.push((size >> 0) & 0xff);\n                } else if (size < 0x100000) {\n                    result.push(0xe0 | (size >> 16));\n                    result.push((size >> 8) & 0xff);\n                    result.push((size >> 0) & 0xff);\n                } else if (size < 0x8000000) {\n                    result.push(0xf0 | (size >> 24));\n                    result.push((size >> 16) & 0xff);\n                    result.push((size >> 8) & 0xff);\n                    result.push((size >> 0) & 0xff);\n                } else if (size < 0x400000000) {\n                    result.push(0xf8 | (size >> 32));\n                    result.push((size >> 24) & 0xff);\n                    result.push((size >> 16) & 0xff);\n                    result.push((size >> 8) & 0xff);\n                    result.push((size >> 0) & 0xff);\n                } else\n                    throw new RangeError(\n                        `Cannot serialize ${this.toString()} as it is 17,179,869,184 or more bytes in size${\n                            this.positionSuffix\n                        }.`\n                    );\n                for (const byte of this.atom) result.push(byte);\n                return Uint8Array.from(result);\n            }\n        } else {\n            const result = [0xff];\n            for (const byte of this.first.serialize()) result.push(byte);\n            for (const byte of this.rest.serialize()) result.push(byte);\n            return Uint8Array.from(result);\n        }\n    }\n\n    public serializeHex(): string {\n        return toHex(this.serialize());\n    }\n\n    public equals(value: Program): boolean {\n        return (\n            this.isAtom === value.isAtom &&\n            (this.isAtom\n                ? bytesEqual(this.atom, value.atom)\n                : this.first.equals(value.first) &&\n                  this.rest.equals(value.rest))\n        );\n    }\n\n    public toString(): string {\n        return this.toSource();\n    }\n}\n","export const keywords = {\n    q: 0x01n,\n    a: 0x02n,\n    i: 0x03n,\n    c: 0x04n,\n    f: 0x05n,\n    r: 0x06n,\n    l: 0x07n,\n    x: 0x08n,\n    '=': 0x09n,\n    '>s': 0x0an,\n    sha256: 0x0bn,\n    substr: 0x0cn,\n    strlen: 0x0dn,\n    concat: 0x0en,\n    '+': 0x10n,\n    '-': 0x11n,\n    '*': 0x12n,\n    '/': 0x13n,\n    divmod: 0x14n,\n    '>': 0x15n,\n    ash: 0x16n,\n    lsh: 0x17n,\n    logand: 0x18n,\n    logior: 0x19n,\n    logxor: 0x1an,\n    lognot: 0x1bn,\n    point_add: 0x1dn,\n    pubkey_for_exp: 0x1en,\n    not: 0x20n,\n    any: 0x21n,\n    all: 0x22n,\n    '.': 0x23n,\n    softfork: 0x24n,\n};\n","export const printable = `0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+,-./:;<=>?@[\\]^_\\`{|}~ \t\n\n\u000b\f`;\n","import { bytesEqual, encodeBigInt, toHex } from 'chia-bls';\nimport { applyAtom, consAtom, quoteAtom } from '../constants/atoms';\nimport { keywords } from '../constants/keywords';\nimport { BetterSet } from '../types/BetterSet';\nimport { NodePath } from '../types/NodePath';\nimport { Program, ProgramOutput } from '../types/Program';\nimport { brunAsProgram, Eval, evalAsProgram, quoteAsProgram } from './helpers';\nimport { defaultMacroLookup } from './macros';\nimport { compileMod } from './mod';\nimport { Operator } from './operators';\n\nconst passThroughOperators = new BetterSet([\n    ...Object.values(keywords).map((value) => toHex(encodeBigInt(value))),\n    toHex(new TextEncoder().encode('com')),\n    toHex(new TextEncoder().encode('opt')),\n]);\n\nexport function compileQq(\n    args: Program,\n    macroLookup: Program,\n    symbolTable: Program,\n    runProgram: Eval,\n    level: number = 1\n): Program {\n    function com(program: Program): Program {\n        return doComProgram(program, macroLookup, symbolTable, runProgram);\n    }\n\n    const program = args.first;\n    if (!program.isCons) {\n        return quoteAsProgram(program);\n    }\n    if (!program.first.isCons) {\n        const op = program.first.toText();\n        if (op === 'qq') {\n            const expression = compileQq(\n                program.rest,\n                macroLookup,\n                symbolTable,\n                runProgram,\n                level + 1\n            );\n            return com(\n                Program.fromList([\n                    Program.fromBytes(consAtom),\n                    Program.fromText(op),\n                    Program.fromList([\n                        Program.fromBytes(consAtom),\n                        expression,\n                        quoteAsProgram(Program.nil),\n                    ]),\n                ])\n            );\n        } else if (op === 'unquote') {\n            if (level === 1) {\n                return com(program.rest.first);\n            }\n            const expression = compileQq(\n                program.rest,\n                macroLookup,\n                symbolTable,\n                runProgram,\n                level - 1\n            );\n            return com(\n                Program.fromList([\n                    Program.fromBytes(consAtom),\n                    Program.fromText(op),\n                    Program.fromList([\n                        Program.fromBytes(consAtom),\n                        expression,\n                        quoteAsProgram(Program.nil),\n                    ]),\n                ])\n            );\n        }\n    }\n    const first = com(\n        Program.fromList([Program.fromText('qq'), program.first])\n    );\n    const rest = com(Program.fromList([Program.fromText('qq'), program.rest]));\n    return Program.fromList([Program.fromBytes(consAtom), first, rest]);\n}\n\nexport function compileMacros(\n    _args: Program,\n    macroLookup: Program,\n    _symbolTable: Program,\n    _runProgram: Eval\n): Program {\n    return quoteAsProgram(macroLookup);\n}\n\nexport function compileSymbols(\n    _args: Program,\n    _macroLookup: Program,\n    symbolTable: Program,\n    _runProgram: Eval\n): Program {\n    return quoteAsProgram(symbolTable);\n}\n\nexport const compileBindings = {\n    qq: compileQq,\n    macros: compileMacros,\n    symbols: compileSymbols,\n    lambda: compileMod,\n    mod: compileMod,\n};\n\nexport function lowerQuote(\n    program: Program,\n    _macroLookup?: Program,\n    _symbolTable?: Program,\n    _runProgram?: Eval\n): Program {\n    if (program.isAtom) {\n        return program;\n    } else if (program.first.isAtom && program.first.toText() === 'quote') {\n        if (!program.rest.rest.isNull)\n            throw new Error(\n                `Compilation error while compiling ${program}. Quote takes exactly one argument${program.positionSuffix}.`\n            );\n        return quoteAsProgram(lowerQuote(program.rest.first));\n    } else\n        return Program.cons(\n            lowerQuote(program.first),\n            lowerQuote(program.rest)\n        );\n}\n\nexport function doComProgram(\n    program: Program,\n    macroLookup: Program,\n    symbolTable: Program,\n    runProgram: Eval\n): Program {\n    program = lowerQuote(program, macroLookup, symbolTable, runProgram);\n    if (!program.isCons) {\n        const atom = program.toText();\n        if (atom === '@') {\n            return Program.fromBytes(NodePath.top.asPath());\n        }\n        for (const pair of symbolTable.toList()) {\n            const symbol = pair.first;\n            const value = pair.rest.first;\n            if (symbol.isAtom && symbol.toText() === atom) {\n                return value;\n            }\n        }\n        return quoteAsProgram(program);\n    }\n    const operator = program.first;\n    if (operator.isCons) {\n        const inner = evalAsProgram(\n            Program.fromList([\n                Program.fromText('com'),\n                quoteAsProgram(operator),\n                quoteAsProgram(macroLookup),\n                quoteAsProgram(symbolTable),\n            ]),\n            Program.fromBytes(NodePath.top.asPath())\n        );\n        return Program.fromList([inner]);\n    }\n    const atom = operator.toText();\n    for (const macroPair of macroLookup.toList()) {\n        if (macroPair.first.isAtom && macroPair.first.toText() === atom) {\n            const macroCode = macroPair.rest.first;\n            const postProgram = brunAsProgram(macroCode, program.rest);\n            const result = evalAsProgram(\n                Program.fromList([\n                    Program.fromText('com'),\n                    postProgram,\n                    quoteAsProgram(macroLookup),\n                    quoteAsProgram(symbolTable),\n                ]),\n                Program.fromBytes(NodePath.top.asPath())\n            );\n            return result;\n        }\n    }\n    if (atom in compileBindings) {\n        const compiler = compileBindings[atom as keyof typeof compileBindings];\n        const postProgram = compiler(\n            program.rest,\n            macroLookup,\n            symbolTable,\n            runProgram\n        );\n        return evalAsProgram(\n            quoteAsProgram(postProgram),\n            Program.fromBytes(NodePath.top.asPath())\n        );\n    }\n    if (bytesEqual(operator.atom, quoteAtom)) {\n        return program;\n    }\n    const compiledArgs = program.rest\n        .toList()\n        .map((item) =>\n            doComProgram(item, macroLookup, symbolTable, runProgram)\n        );\n    let result = Program.fromList([operator, ...compiledArgs]);\n    if (\n        passThroughOperators.has(toHex(new TextEncoder().encode(atom))) ||\n        atom.startsWith('_')\n    ) {\n        return result;\n    }\n    for (const item of symbolTable.toList()) {\n        const [symbol, value] = item.toList();\n        if (!symbol.isAtom) continue;\n        const symbolText = symbol.toText();\n        if (symbolText === '*') {\n            return result;\n        } else if (symbolText === atom) {\n            const newArgs = evalAsProgram(\n                Program.fromList([\n                    Program.fromText('opt'),\n                    Program.fromList([\n                        Program.fromText('com'),\n                        quoteAsProgram(\n                            Program.fromList([\n                                Program.fromText('list'),\n                                ...program.rest.toList(),\n                            ])\n                        ),\n                        quoteAsProgram(macroLookup),\n                        quoteAsProgram(symbolTable),\n                    ]),\n                ]),\n                Program.fromBytes(NodePath.top.asPath())\n            );\n            return Program.fromList([\n                Program.fromBytes(applyAtom),\n                value,\n                Program.fromList([\n                    Program.fromBytes(consAtom),\n                    Program.fromBytes(NodePath.left.asPath()),\n                    newArgs,\n                ]),\n            ]);\n        }\n    }\n    throw new Error(\n        `Can't compile unknown operator ${program}${program.positionSuffix}.`\n    );\n}\n\nexport function makeDoCom(runProgram: Eval): Operator {\n    return (sexp: Program): ProgramOutput => {\n        const prog = sexp.first;\n        let symbolTable = Program.nil;\n        let macroLookup: Program;\n        if (!sexp.rest.isNull) {\n            macroLookup = sexp.rest.first;\n            if (!sexp.rest.rest.isNull) symbolTable = sexp.rest.rest.first;\n        } else {\n            macroLookup = defaultMacroLookup(runProgram);\n        }\n        return {\n            value: doComProgram(prog, macroLookup, symbolTable, runProgram),\n            cost: 1n,\n        };\n    };\n}\n","import { encodeBigInt } from 'chia-bls';\nimport { keywords } from './keywords';\n\nexport const quoteAtom = encodeBigInt(keywords['q']);\nexport const applyAtom = encodeBigInt(keywords['a']);\nexport const firstAtom = encodeBigInt(keywords['f']);\nexport const restAtom = encodeBigInt(keywords['r']);\nexport const consAtom = encodeBigInt(keywords['c']);\nexport const raiseAtom = encodeBigInt(keywords['x']);\n","export class BetterSet<T> extends Set<T> {\n    public isSuperset(set: Set<T>): boolean {\n        for (const item of set) if (!this.has(item)) return false;\n        return true;\n    }\n\n    public isSubset(set: Set<T>): boolean {\n        for (const item of this) if (!set.has(item)) return false;\n        return true;\n    }\n\n    public isSupersetProper(set: Set<T>): boolean {\n        return this.isSuperset(set) && !this.isSubset(set);\n    }\n\n    public isSubsetProper(set: Set<T>): boolean {\n        return this.isSubset(set) && !this.isSuperset(set);\n    }\n\n    public equals(set: Set<T>): boolean {\n        return this.isSubset(set) && this.isSuperset(set);\n    }\n\n    public union(set: Set<T>): BetterSet<T> {\n        const union = new BetterSet(this);\n        for (const item of set) union.add(item);\n        return union;\n    }\n\n    public intersection(set: Set<T>): BetterSet<T> {\n        const intersection = new BetterSet<T>();\n        for (const item of set) if (this.has(item)) intersection.add(item);\n        return intersection;\n    }\n\n    public symmetricDifference(set: Set<T>): BetterSet<T> {\n        const difference = new BetterSet<T>(this);\n        for (const item of set)\n            if (difference.has(item)) difference.delete(item);\n            else difference.add(item);\n        return difference;\n    }\n\n    public difference(set: Set<T>): BetterSet<T> {\n        const difference = new BetterSet<T>(this);\n        for (const item of set) difference.delete(item);\n        return difference;\n    }\n\n    public update(set: Set<T>): this {\n        for (const item of set) this.add(item);\n        return this;\n    }\n\n    public differenceUpdate(set: Set<T>): this {\n        for (const item of set) this.delete(item);\n        return this;\n    }\n\n    public symmetricDifferenceUpdate(set: Set<T>): this {\n        for (const item of set)\n            if (this.has(item)) this.delete(item);\n            else this.add(item);\n        return this;\n    }\n\n    public intersectionUpdate(set: Set<T>): this {\n        for (const item of this) if (!set.has(item)) this.delete(item);\n        return this;\n    }\n\n    public sort(sorter?: (a: T, b: T) => number): BetterSet<T> {\n        return new BetterSet([...this].sort(sorter));\n    }\n\n    public map<U>(\n        mapper: (value: T, index: number, array: BetterSet<T>) => U\n    ): BetterSet<U> {\n        const result = new BetterSet<U>();\n        let index = 0;\n        for (const item of this) result.add(mapper(item, index++, this));\n        return result;\n    }\n\n    public filter(\n        predicate: (value: T, index: number, array: BetterSet<T>) => unknown\n    ): BetterSet<T> {\n        const result = new BetterSet<T>();\n        let index = 0;\n        for (const item of this)\n            if (predicate(item, index++, this)) result.add(item);\n        return result;\n    }\n}\n","import { bigIntBitLength, bigIntToBytes, bytesToBigInt } from 'chia-bls';\n\nexport function composePaths(left: bigint, right: bigint): bigint {\n    let mask = 1n;\n    let tempPath = left;\n    while (tempPath > 1n) {\n        right <<= 1n;\n        mask <<= 1n;\n        tempPath >>= 1n;\n    }\n    mask -= 1n;\n    return right | (left & mask);\n}\n\nexport class NodePath {\n    public static top: NodePath = new NodePath();\n    public static left: NodePath = NodePath.top.first();\n    public static right: NodePath = NodePath.top.rest();\n\n    private index: bigint;\n\n    constructor(index: bigint = 1n) {\n        if (index < 0n) {\n            const byteCount = (bigIntBitLength(index) + 7) >> 3;\n            const blob = bigIntToBytes(index, byteCount, 'big', true);\n            index = bytesToBigInt(Uint8Array.from([0, ...blob]), 'big', false);\n        }\n        this.index = index;\n    }\n\n    public asPath(): Uint8Array {\n        const byteCount = (bigIntBitLength(this.index) + 7) >> 3;\n        return bigIntToBytes(this.index, byteCount, 'big');\n    }\n\n    public add(other: NodePath): NodePath {\n        return new NodePath(composePaths(this.index, other.index));\n    }\n\n    public first(): NodePath {\n        return new NodePath(this.index * 2n);\n    }\n\n    public rest(): NodePath {\n        return new NodePath(this.index * 2n + 1n);\n    }\n\n    public toString(): string {\n        return `NodePath: ${this.index}`;\n    }\n}\n","import { keywords } from '../constants/keywords';\nimport { NodePath } from '../types/NodePath';\nimport { Program, ProgramOutput } from '../types/Program';\n\nexport type Eval = (program: Program, args: Program) => ProgramOutput;\nexport type Group = Record<string, Program>;\n\nexport function quoteAsProgram(program: Program): Program {\n    return Program.cons(Program.fromBigInt(keywords['q']), program);\n}\n\nexport function evalAsProgram(program: Program, args: Program): Program {\n    return Program.fromList([Program.fromBigInt(keywords['a']), program, args]);\n}\n\nexport function runAsProgram(program: Program, macroLookup: Program): Program {\n    return evalAsProgram(\n        Program.fromList([\n            Program.fromText('com'),\n            program,\n            quoteAsProgram(macroLookup),\n        ]),\n        Program.fromBytes(NodePath.top.asPath())\n    );\n}\n\nexport function brunAsProgram(program: Program, args: Program): Program {\n    return evalAsProgram(quoteAsProgram(program), quoteAsProgram(args));\n}\n","import { Program } from '../index';\nimport { Eval } from './helpers';\n\nconst defaultMacroSources = [\n    `\n    ; we have to compile this externally, since it uses itself\n    ;(defmacro defmacro (name params body)\n    ;    (qq (list (unquote name) (mod (unquote params) (unquote body))))\n    ;)\n    (q . (\"defmacro\"\n       (c (q . \"list\")\n          (c (f 1)\n             (c (c (q . \"mod\")\n                   (c (f (r 1))\n                      (c (f (r (r 1)))\n                         (q . ()))))\n                (q . ()))))))\n    `,\n    `\n    ;(defmacro list ARGS\n    ;    ((c (mod args\n    ;        (defun compile-list\n    ;               (args)\n    ;               (if args\n    ;                   (qq (c (unquote (f args))\n    ;                         (unquote (compile-list (r args)))))\n    ;                   ()))\n    ;            (compile-list args)\n    ;        )\n    ;        ARGS\n    ;    ))\n    ;)\n    (q \"list\"\n        (a (q #a (q #a 2 (c 2 (c 3 (q))))\n                 (c (q #a (i 5\n                             (q #c (q . 4)\n                                   (c 9 (c (a 2 (c 2 (c 13 (q))))\n                                           (q)))\n                             )\n                             (q 1))\n                           1)\n                    1))\n            1))\n    `,\n    `(defmacro function (BODY)\n        (qq (opt (com (q . (unquote BODY))\n                 (qq (unquote (macros)))\n                 (qq (unquote (symbols)))))))`,\n    `(defmacro if (A B C)\n        (qq (a\n            (i (unquote A)\n               (function (unquote B))\n               (function (unquote C)))\n            @)))`,\n    `(defmacro / (A B) (qq (f (divmod (unquote A) (unquote B)))))`,\n];\n\nlet defaultMacroLookupProgram: Program | undefined;\n\nfunction buildDefaultMacroLookup(evalAsProgram: Eval): Program {\n    const run = Program.fromSource('(a (com 2 3) 1)');\n    for (const macroSource of defaultMacroSources) {\n        const macroProgram = Program.fromSource(macroSource);\n        const env = Program.cons(macroProgram, defaultMacroLookupProgram!);\n        const newMacro = evalAsProgram(run, env).value;\n        defaultMacroLookupProgram = Program.cons(\n            newMacro,\n            defaultMacroLookupProgram!\n        );\n    }\n    return defaultMacroLookupProgram!;\n}\n\nexport function defaultMacroLookup(evalAsProgram: Eval): Program {\n    if (!defaultMacroLookupProgram || defaultMacroLookupProgram.isNull) {\n        defaultMacroLookupProgram = Program.fromList([]);\n        buildDefaultMacroLookup(evalAsProgram);\n    }\n    return defaultMacroLookupProgram;\n}\n","import { consAtom } from '../constants/atoms';\nimport { Program } from '../index';\nimport { BetterSet } from '../types/BetterSet';\nimport { NodePath } from '../types/NodePath';\nimport { compareStrings } from './compare';\nimport { Eval, evalAsProgram, Group, quoteAsProgram } from './helpers';\nimport { optimizeProgram } from './optimize';\n\nconst mainName = '';\n\nexport function buildTree(items: Program[]): Program {\n    if (items.length === 0) return Program.nil;\n    else if (items.length === 1) return items[0];\n    const halfSize = items.length >> 1;\n    return Program.cons(\n        buildTree(items.slice(0, halfSize)),\n        buildTree(items.slice(halfSize))\n    );\n}\n\nexport function buildTreeProgram(items: Program[]): Program {\n    if (items.length === 0)\n        return Program.fromList([quoteAsProgram(Program.nil)]);\n    else if (items.length === 1) return items[0];\n    const halfSize = items.length >> 1;\n    return Program.fromList([\n        Program.fromBytes(consAtom),\n        buildTreeProgram(items.slice(0, halfSize)),\n        buildTreeProgram(items.slice(halfSize)),\n    ]);\n}\n\nexport function flatten(program: Program): string[] {\n    if (program.isCons)\n        return [...flatten(program.first), ...flatten(program.rest)];\n    else return [program.toText()];\n}\n\nexport function buildUsedConstantNames(\n    functions: Group,\n    constants: Group,\n    macros: Program[]\n): BetterSet<string> {\n    const macrosAsDict: Group = {};\n    for (const item of macros) macrosAsDict[item.rest.first.toText()] = item;\n    const possibleSymbols = new BetterSet(Object.keys(functions));\n    possibleSymbols.update(new BetterSet(Object.keys(constants)));\n    let newNames = new BetterSet([mainName]);\n    const usedNames = new BetterSet(newNames);\n    while (newNames.size) {\n        const priorNewNames = new BetterSet(newNames);\n        newNames = new BetterSet<string>();\n        for (const item of priorNewNames) {\n            for (const group of [functions, macrosAsDict]) {\n                if (item in group)\n                    newNames.update(new BetterSet(flatten(group[item])));\n            }\n        }\n        newNames.differenceUpdate(usedNames);\n        usedNames.update(newNames);\n    }\n    usedNames.intersectionUpdate(possibleSymbols);\n    usedNames.delete(mainName);\n    return usedNames.sort((a, b) => compareStrings(a, b));\n}\n\nexport function parseInclude(\n    name: Program,\n    namespace: BetterSet<string>,\n    functions: Group,\n    constants: Group,\n    macros: Program[],\n    runProgram: Eval\n): void {\n    const program = Program.fromSource('(_read (_full_path_for_name 1))');\n    const output = runProgram(program, name).value;\n    for (const item of output.toList())\n        parseModProgram(\n            item,\n            namespace,\n            functions,\n            constants,\n            macros,\n            runProgram\n        );\n}\n\nexport function unquoteArgs(program: Program, args: string[]): Program {\n    if (program.isCons) {\n        return Program.cons(\n            unquoteArgs(program.first, args),\n            unquoteArgs(program.rest, args)\n        );\n    } else if (args.includes(program.toText())) {\n        return Program.fromList([Program.fromText('unquote'), program]);\n    }\n    return program;\n}\n\nexport function defunInlineToMacro(program: Program): Program {\n    const second = program.rest;\n    const third = second.rest;\n    const items = [Program.fromText('defmacro'), second.first, third.first];\n    const code = third.rest.first;\n    const args = flatten(third.first).filter((item) => item.length);\n    const unquotedCode = unquoteArgs(code, args);\n    items.push(Program.fromList([Program.fromText('qq'), unquotedCode]));\n    return Program.fromList(items);\n}\n\nexport function parseModProgram(\n    declarationProgram: Program,\n    namespace: BetterSet<string>,\n    functions: Group,\n    constants: Group,\n    macros: Program[],\n    runProgram: Eval\n): void {\n    const op = declarationProgram.first.toText();\n    const nameProgram = declarationProgram.rest.first;\n    if (op === 'include') {\n        parseInclude(\n            nameProgram,\n            namespace,\n            functions,\n            constants,\n            macros,\n            runProgram\n        );\n        return;\n    }\n    const name = nameProgram.toText();\n    if (namespace.has(name)) {\n        throw new Error(`Symbol ${JSON.stringify(name)} redefined.`);\n    }\n    namespace.add(name);\n    if (op === 'defmacro') {\n        macros.push(declarationProgram);\n    } else if (op === 'defun') {\n        functions[name] = declarationProgram.rest.rest;\n    } else if (op === 'defun-inline') {\n        macros.push(defunInlineToMacro(declarationProgram));\n    } else if (op === 'defconstant') {\n        constants[name] = quoteAsProgram(declarationProgram.rest.rest.first);\n    } else {\n        throw new Error(\n            `Expected \"defun\", \"defun-inline\", \"defmacro\", or \"defconstant\", but got ${JSON.stringify(\n                op\n            )}.`\n        );\n    }\n}\n\nexport function compileModStage1(\n    args: Program,\n    runProgram: Eval\n): [functions: Group, constants: Group, macros: Program[]] {\n    const functions: Group = {};\n    const constants: Group = {};\n    const macros: Array<Program> = [];\n    const mainLocalArguments = args.first;\n    const namespace = new BetterSet<string>();\n    while (true) {\n        args = args.rest;\n        if (args.rest.isNull) break;\n        parseModProgram(\n            args.first,\n            namespace,\n            functions,\n            constants,\n            macros,\n            runProgram\n        );\n    }\n    const uncompiledMain = args.first;\n    functions[mainName] = Program.fromList([\n        mainLocalArguments,\n        uncompiledMain,\n    ]);\n    return [functions, constants, macros];\n}\n\nexport function symbolTableForTree(tree: Program, rootNode: NodePath): Program {\n    if (tree.isNull) return Program.nil;\n    else if (!tree.isCons)\n        return Program.fromList([\n            Program.fromList([tree, Program.fromBytes(rootNode.asPath())]),\n        ]);\n    const left = symbolTableForTree(tree.first, rootNode.add(NodePath.left));\n    const right = symbolTableForTree(tree.rest, rootNode.add(NodePath.right));\n    return Program.fromList([...left.toList(), ...right.toList()]);\n}\n\nexport function buildMacroLookupProgram(\n    macroLookup: Program,\n    macros: Program[],\n    runProgram: Eval\n): Program {\n    let macroLookupProgram = quoteAsProgram(macroLookup);\n    for (const macro of macros) {\n        macroLookupProgram = evalAsProgram(\n            Program.fromList([\n                Program.fromText('opt'),\n                Program.fromList([\n                    Program.fromText('com'),\n                    quoteAsProgram(\n                        Program.fromList([\n                            Program.fromBytes(consAtom),\n                            macro,\n                            macroLookupProgram,\n                        ])\n                    ),\n                    macroLookupProgram,\n                ]),\n            ]),\n            Program.fromBytes(NodePath.top.asPath())\n        );\n        macroLookupProgram = optimizeProgram(macroLookupProgram, runProgram);\n    }\n    return macroLookupProgram;\n}\n\nexport function compileFunctions(\n    functions: Group,\n    macroLookupProgram: Program,\n    constantSymbolTable: Program,\n    argsRootNode: NodePath\n): Group {\n    const compiledFunctions: Group = {};\n    for (const [name, lambdaExpression] of Object.entries(functions)) {\n        const localSymbolTable = symbolTableForTree(\n            lambdaExpression.first,\n            argsRootNode\n        );\n        const allSymbols = Program.fromList([\n            ...localSymbolTable.toList(),\n            ...constantSymbolTable.toList(),\n        ]);\n        compiledFunctions[name] = Program.fromList([\n            Program.fromText('opt'),\n            Program.fromList([\n                Program.fromText('com'),\n                quoteAsProgram(lambdaExpression.rest.first),\n                macroLookupProgram,\n                quoteAsProgram(allSymbols),\n            ]),\n        ]);\n    }\n    return compiledFunctions;\n}\n\nexport function compileMod(\n    args: Program,\n    macroLookup: Program,\n    _symbolTable: Program,\n    runProgram: Eval\n): Program {\n    const [functions, constants, macros] = compileModStage1(args, runProgram);\n    const macroLookupProgram = buildMacroLookupProgram(\n        macroLookup,\n        macros,\n        runProgram\n    );\n    const allConstantNames = buildUsedConstantNames(\n        functions,\n        constants,\n        macros\n    );\n    const hasConstantTree = allConstantNames.size > 0;\n    const constantTree = buildTree([\n        ...allConstantNames.map((item) => Program.fromText(item)),\n    ]);\n    const constantRootNode = NodePath.left;\n    const argsRootNode = hasConstantTree ? NodePath.right : NodePath.top;\n    const constantSymbolTable = symbolTableForTree(\n        constantTree,\n        constantRootNode\n    );\n    const compiledFunctions = compileFunctions(\n        functions,\n        macroLookupProgram,\n        constantSymbolTable,\n        argsRootNode\n    );\n    const mainPathSource = compiledFunctions[mainName].toString();\n    let argTreeSource: string;\n    if (hasConstantTree) {\n        const allConstantsLookup: Group = {};\n        for (const [key, value] of Object.entries(compiledFunctions))\n            if (allConstantNames.has(key)) allConstantsLookup[key] = value;\n        Object.assign(allConstantsLookup, constants);\n        const allConstantsList = [...allConstantNames].map(\n            (item) => allConstantsLookup[item]\n        );\n        const allConstantsTreeProgram = buildTreeProgram(allConstantsList);\n        const allConstantsTreeSource = allConstantsTreeProgram.toString();\n        argTreeSource = `(c ${allConstantsTreeSource} 1)`;\n    } else {\n        argTreeSource = '1';\n    }\n    return Program.fromSource(\n        `(opt (q . (a ${mainPathSource} ${argTreeSource})))`\n    );\n}\n","export function compareStrings(a: string, b: string): number {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import { bytesEqual } from 'chia-bls';\nimport { quoteAtom, raiseAtom } from '../constants/atoms';\nimport { keywords } from '../constants/keywords';\nimport { NodePath } from '../types/NodePath';\nimport { Program } from '../types/Program';\nimport { Eval, quoteAsProgram } from './helpers';\nimport { match } from './match';\nimport { Operator } from './operators';\n\nexport function seemsConstant(program: Program): boolean {\n    if (!program.isCons) return program.isNull;\n    const operator = program.first;\n    if (!operator.isCons) {\n        const value = operator.atom;\n        if (bytesEqual(value, quoteAtom)) return true;\n        else if (bytesEqual(value, raiseAtom)) return false;\n    } else if (!seemsConstant(operator)) return false;\n    return program.rest.toList().every((item) => seemsConstant(item));\n}\n\nexport function constantOptimizer(\n    program: Program,\n    evalAsProgram: Eval\n): Program {\n    if (seemsConstant(program) && !program.isNull) {\n        const newProgram = evalAsProgram(program, Program.nil).value;\n        program = quoteAsProgram(newProgram);\n    }\n    return program;\n}\n\nexport function isArgsCall(program: Program): boolean {\n    return program.isAtom && program.toBigInt() === 1n;\n}\n\nexport function consQuoteApplyOptimizer(\n    program: Program,\n    _evalAsProgram: Eval\n): Program {\n    const matched = match(\n        Program.fromSource('(a (q . (: . sexp)) (: . args))'),\n        program\n    );\n    if (matched && isArgsCall(matched['args'])) {\n        return matched['sexp'];\n    }\n    return program;\n}\n\nexport function consFirst(args: Program): Program {\n    const matched = match(\n        Program.fromSource('(c (: . first) (: . rest))'),\n        args\n    );\n    if (matched) {\n        return matched['first'];\n    }\n    return Program.fromList([Program.fromBigInt(keywords['f']), args]);\n}\n\nexport function consRest(args: Program): Program {\n    const matched = match(\n        Program.fromSource('(c (: . first) (: . rest))'),\n        args\n    );\n    if (matched) {\n        return matched['rest'];\n    }\n    return Program.fromList([Program.fromBigInt(keywords['r']), args]);\n}\n\nexport function pathFromArgs(program: Program, args: Program): Program {\n    const value = program.toBigInt();\n    if (value <= 1n) {\n        return args;\n    }\n    program = Program.fromBigInt(value >> 1n);\n    if (value & 1n) {\n        return pathFromArgs(program, consRest(args));\n    }\n    return pathFromArgs(program, consFirst(args));\n}\n\nexport function subArgs(program: Program, args: Program): Program {\n    if (!program.isCons) {\n        return pathFromArgs(program, args);\n    }\n    let first = program.first;\n    if (first.isCons) first = subArgs(first, args);\n    else if (bytesEqual(first.atom, quoteAtom)) {\n        return program;\n    }\n    return Program.fromList([\n        first,\n        ...program.rest.toList().map((item) => subArgs(item, args)),\n    ]);\n}\n\nexport function varChangeOptimizerConsEval(\n    program: Program,\n    evalAsProgram: Eval\n): Program {\n    const matched = match(\n        Program.fromSource('(a (q . (: . sexp)) (: . args))'),\n        program\n    );\n    if (!matched) {\n        return program;\n    }\n    const originalArgs = matched['args'];\n    const originalCall = matched['sexp'];\n    const newEvalProgramArgs = subArgs(originalCall, originalArgs);\n    if (seemsConstant(newEvalProgramArgs)) {\n        return optimizeProgram(newEvalProgramArgs, evalAsProgram);\n    }\n    const newOperands = newEvalProgramArgs.toList();\n    const optOperands = newOperands.map((item) =>\n        optimizeProgram(item, evalAsProgram)\n    );\n    const nonConstantCount = optOperands.filter(\n        (item) =>\n            item.isCons &&\n            (item.first.isCons || !bytesEqual(item.first.atom, quoteAtom))\n    ).length;\n    if (nonConstantCount < 1) {\n        return Program.fromList(optOperands);\n    }\n    return program;\n}\n\nexport function childrenOptimizer(\n    program: Program,\n    evalAsProgram: Eval\n): Program {\n    if (!program.isCons) {\n        return program;\n    }\n    const operator = program.first;\n    if (operator.isAtom && bytesEqual(operator.atom, quoteAtom)) {\n        return program;\n    }\n    return Program.fromList(\n        program.toList().map((item) => optimizeProgram(item, evalAsProgram))\n    );\n}\n\nexport function consOptimizer(program: Program, _evalAsProgram: Eval): Program {\n    let matched = match(\n        Program.fromSource('(f (c (: . first) (: . rest)))'),\n        program\n    );\n    if (matched) {\n        return matched['first'];\n    }\n    matched = match(\n        Program.fromSource('(r (c (: . first) (: . rest)))'),\n        program\n    );\n    if (matched) {\n        return matched['rest'];\n    }\n    return program;\n}\n\nexport function pathOptimizer(program: Program, _evalAsProgram: Eval): Program {\n    let matched = match(Program.fromSource('(f ($ . atom))'), program);\n    if (matched && !matched['atom'].isNull) {\n        const node = new NodePath(matched['atom'].toBigInt()).add(\n            NodePath.left\n        );\n        return Program.fromBytes(node.asPath());\n    }\n    matched = match(Program.fromSource('(r ($ . atom))'), program);\n    if (matched && !matched['atom'].isNull) {\n        const node = new NodePath(matched['atom'].toBigInt()).add(\n            NodePath.right\n        );\n        return Program.fromBytes(node.asPath());\n    }\n    return program;\n}\n\nexport function quoteNullOptimizer(\n    program: Program,\n    _evalAsProgram: Eval\n): Program {\n    const matched = match(Program.fromSource('(q . 0)'), program);\n    if (matched) {\n        return Program.nil;\n    }\n    return program;\n}\n\nexport function applyNullOptimizer(\n    program: Program,\n    _evalAsProgram: Eval\n): Program {\n    const matched = match(Program.fromSource('(a 0 . (: . rest))'), program);\n    if (matched) {\n        return Program.nil;\n    }\n    return program;\n}\n\nexport function optimizeProgram(\n    program: Program,\n    evalAsProgram: Eval\n): Program {\n    if (program.isAtom) {\n        return program;\n    }\n    const optimizers = [\n        consOptimizer,\n        constantOptimizer,\n        consQuoteApplyOptimizer,\n        varChangeOptimizerConsEval,\n        childrenOptimizer,\n        pathOptimizer,\n        quoteNullOptimizer,\n        applyNullOptimizer,\n    ];\n    while (program.isCons) {\n        const startProgram = program;\n        for (const optimizer of optimizers) {\n            program = optimizer(program, evalAsProgram);\n            if (!startProgram.equals(program)) break;\n        }\n        if (startProgram.equals(program)) {\n            return program;\n        }\n    }\n    return program;\n}\n\nexport function makeDoOpt(runProgram: Eval): Operator {\n    return (args) => {\n        return {\n            value: optimizeProgram(args.first, runProgram),\n            cost: 1n,\n        };\n    };\n}\n","import { bytesEqual } from 'chia-bls';\nimport { Program } from '../index';\nimport { Group } from './helpers';\n\nconst atomMatch = new TextEncoder().encode('$');\nconst sexpMatch = new TextEncoder().encode(':');\n\nexport function unifyBindings(\n    bindings: Group,\n    key: string,\n    valueProgram: Program\n): Group | null {\n    if (key in bindings) {\n        if (!bindings[key].equals(valueProgram)) return null;\n        return bindings;\n    }\n    return { ...bindings, [key]: valueProgram };\n}\n\nexport function match(\n    pattern: Program,\n    sexp: Program,\n    knownBindings: Group = {}\n): Group | null {\n    if (!pattern.isCons) {\n        if (sexp.isCons) return null;\n        return bytesEqual(pattern.atom, sexp.atom) ? knownBindings : null;\n    }\n    const left = pattern.first;\n    const right = pattern.rest;\n    if (left.isAtom && bytesEqual(left.atom, atomMatch)) {\n        if (sexp.isCons) return null;\n        if (right.isAtom && bytesEqual(right.atom, atomMatch)) {\n            if (bytesEqual(sexp.atom, atomMatch)) return {};\n            return null;\n        }\n        return unifyBindings(knownBindings, right.toText(), sexp);\n    }\n    if (left.isAtom && bytesEqual(left.atom, sexpMatch)) {\n        if (right.isAtom && bytesEqual(right.atom, sexpMatch)) {\n            if (bytesEqual(sexp.atom, sexpMatch)) return {};\n            return null;\n        }\n        return unifyBindings(knownBindings, right.toText(), sexp);\n    }\n    if (!sexp.isCons) return null;\n    const newBindings = match(left, sexp.first, knownBindings);\n    if (!newBindings) return newBindings;\n    return match(right, sexp.rest, newBindings);\n}\n","import { bytesEqual } from 'chia-bls';\nimport { applyAtom, quoteAtom } from '../constants/atoms';\nimport { costs } from '../constants/costs';\nimport { Instruction, Program } from '../types/Program';\nimport { traversePath } from './environment';\nimport { runOperator } from './operators';\n\nexport const instructions = {\n    swap: ((_instructionStack, stack, _options) => {\n        const second = stack.pop()!;\n        const first = stack.pop()!;\n        stack.push(second, first);\n        return 0n;\n    }) as Instruction,\n    cons: ((_instructionStack, stack, _options) => {\n        const first = stack.pop()!;\n        const second = stack.pop()!;\n        stack.push(Program.cons(first, second));\n        return 0n;\n    }) as Instruction,\n    eval: ((instructionStack, stack, _options) => {\n        const pair = stack.pop()!;\n        const program = pair.first;\n        const args = pair.rest;\n        if (program.isAtom) {\n            const output = traversePath(program, args);\n            stack.push(output.value);\n            return output.cost;\n        }\n        const op = program.first;\n        if (op.isCons) {\n            const [newOperator, mustBeNil] = op.cons;\n            if (newOperator.isCons || !mustBeNil.isNull)\n                throw new Error(\n                    `Operators that are lists must contain a single atom${op.positionSuffix}.`\n                );\n            const newOperandList = program.rest;\n            stack.push(newOperator, newOperandList);\n            instructionStack.push(instructions.apply);\n            return costs.apply;\n        }\n        let operandList = program.rest;\n        if (bytesEqual(op.atom, quoteAtom)) {\n            stack.push(operandList);\n            return costs.quote;\n        }\n        instructionStack.push(instructions.apply);\n        stack.push(op);\n        while (!operandList.isNull) {\n            stack.push(Program.cons(operandList.first, args));\n            instructionStack.push(\n                instructions.cons,\n                instructions.eval,\n                instructions.swap\n            );\n            operandList = operandList.rest;\n        }\n        stack.push(Program.nil);\n        return 1n;\n    }) as Instruction,\n    apply: ((instructionStack, stack, options) => {\n        const operandList = stack.pop()!;\n        const op = stack.pop()!;\n        if (op.isCons)\n            throw new Error(`An internal error occurred${op.positionSuffix}.`);\n        if (bytesEqual(op.atom, applyAtom)) {\n            const args = operandList.toList();\n            if (args.length !== 2)\n                throw new Error(\n                    `Expected 2 arguments in \"a\" operator${operandList.positionSuffix}.`\n                );\n            stack.push(Program.cons(args[0], args[1]));\n            instructionStack.push(instructions.eval);\n            return costs.apply;\n        }\n        const output = runOperator(op, operandList, options);\n        stack.push(output.value);\n        return output.cost;\n    }) as Instruction,\n};\n","export const costs = {\n    if: 33n,\n    cons: 50n,\n    first: 30n,\n    rest: 30n,\n    listp: 19n,\n    mallocPerByte: 10n,\n    arithBase: 99n,\n    arithPerByte: 3n,\n    arithPerArg: 320n,\n    logBase: 100n,\n    logPerByte: 3n,\n    logPerArg: 264n,\n    grsBase: 117n,\n    grsPerByte: 1n,\n    eqBase: 117n,\n    eqPerByte: 1n,\n    grBase: 498n,\n    grPerByte: 2n,\n    divmodBase: 1116n,\n    divmodPerByte: 6n,\n    divBase: 988n,\n    divPerByte: 4n,\n    sha256Base: 87n,\n    sha256PerByte: 2n,\n    sha256PerArg: 134n,\n    pointAddBase: 101094n,\n    pointAddPerArg: 1343980n,\n    pubkeyBase: 1325730n,\n    pubkeyPerByte: 38n,\n    mulBase: 92n,\n    mulPerOp: 885n,\n    mulLinearPerByte: 6n,\n    mulSquarePerByteDivider: 128n,\n    strlenBase: 173n,\n    strlenPerByte: 1n,\n    pathLookupBase: 40n,\n    pathLookupPerLeg: 4n,\n    pathLookupPerZeroByte: 4n,\n    concatBase: 142n,\n    concatPerByte: 3n,\n    concatPerArg: 135n,\n    boolBase: 200n,\n    boolPerArg: 300n,\n    ashiftBase: 596n,\n    ashiftPerByte: 3n,\n    lshiftBase: 277n,\n    lshiftPerByte: 3n,\n    lognotBase: 331n,\n    lognotPerByte: 3n,\n    apply: 90n,\n    quote: 20n,\n};\n","import { costs } from '../constants/costs';\nimport { Program, ProgramOutput } from '../types/Program';\n\nexport function msbMask(byte: number): number {\n    byte |= byte >> 1;\n    byte |= byte >> 2;\n    byte |= byte >> 4;\n    return (byte + 1) >> 1;\n}\n\nexport function traversePath(\n    value: Program,\n    environment: Program\n): ProgramOutput {\n    let cost = costs.pathLookupBase + costs.pathLookupPerLeg;\n    if (value.isNull) return { value: Program.nil, cost };\n    let endByteCursor = 0;\n    const atom = value.atom;\n    while (endByteCursor < atom.length && atom[endByteCursor] === 0)\n        endByteCursor++;\n    cost += BigInt(endByteCursor) * costs.pathLookupPerZeroByte;\n    if (endByteCursor === atom.length) return { value: Program.nil, cost };\n    const endBitMask = msbMask(atom[endByteCursor]);\n    let byteCursor = atom.length - 1;\n    let bitMask = 0x01;\n    while (byteCursor > endByteCursor || bitMask < endBitMask) {\n        if (environment.isAtom)\n            throw new Error(\n                `Cannot traverse into ${environment}${environment.positionSuffix}.`\n            );\n        if ((atom[byteCursor] & bitMask) !== 0) environment = environment.rest;\n        else environment = environment.first;\n        cost += costs.pathLookupPerLeg;\n        bitMask <<= 1;\n        if (bitMask === 0x100) {\n            byteCursor--;\n            bitMask = 0x01;\n        }\n    }\n    return { value: environment, cost };\n}\n","import {\n    bigIntToBytes,\n    bytesEqual,\n    bytesToBigInt,\n    bytesToInt,\n    defaultEc,\n    hash256,\n    JacobianPoint,\n    mod,\n    PrivateKey,\n} from 'chia-bls';\nimport { costs } from '../constants/costs';\nimport { keywords } from '../constants/keywords';\nimport { Program, ProgramOutput, RunOptions } from '../types/Program';\n\nexport type Operator = (args: Program) => ProgramOutput;\n\nexport interface Operators {\n    operators: Record<string, Operator>;\n    unknown: (operator: Program, args: Program) => ProgramOutput;\n    quote: string;\n    apply: string;\n}\n\nexport const operators = {\n    i: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'i', 3);\n        return { value: list[0].isNull ? list[2] : list[1], cost: costs.if };\n    }) as Operator,\n    c: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'c', 2);\n        return { value: Program.cons(list[0], list[1]), cost: costs.cons };\n    }) as Operator,\n    f: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'f', 1, 'cons');\n        return { value: list[0].first, cost: costs.first };\n    }) as Operator,\n    r: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'r', 1, 'cons');\n        return { value: list[0].rest, cost: costs.rest };\n    }) as Operator,\n    l: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'l', 1);\n        return { value: Program.fromBool(list[0].isCons), cost: costs.listp };\n    }) as Operator,\n    x: ((args: Program): ProgramOutput => {\n        throw new Error(`The error ${args} was raised${args.positionSuffix}.`);\n    }) as Operator,\n    '=': ((args: Program): ProgramOutput => {\n        const list = toList(args, '=', 2, 'atom');\n        return {\n            value: Program.fromBool(bytesEqual(list[0].atom, list[1].atom)),\n            cost:\n                costs.eqBase +\n                (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) *\n                    costs.eqPerByte,\n        };\n    }) as Operator,\n    sha256: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'sha256', undefined, 'atom');\n        let cost = costs.sha256Base;\n        let argLength = 0;\n        const bytes: Array<number> = [];\n        for (const item of list) {\n            for (const byte of item.atom) bytes.push(byte);\n            argLength += item.atom.length;\n            cost += costs.sha256PerArg;\n        }\n        cost += BigInt(argLength) * costs.sha256PerByte;\n        return mallocCost({\n            value: Program.fromBytes(hash256(Uint8Array.from(bytes))),\n            cost,\n        });\n    }) as Operator,\n    '+': ((args: Program): ProgramOutput => {\n        const list = toList(args, '+', undefined, 'atom');\n        let total = 0n;\n        let cost = costs.arithBase;\n        let argSize = 0;\n        for (const item of list) {\n            total += item.toBigInt();\n            argSize += item.atom.length;\n            cost += costs.arithPerArg;\n        }\n        cost += BigInt(argSize) * costs.arithPerByte;\n        return mallocCost({ value: Program.fromBigInt(total), cost });\n    }) as Operator,\n    '-': ((args: Program): ProgramOutput => {\n        let cost = costs.arithBase;\n        if (args.isNull) return { value: Program.nil, cost: cost };\n        const list = toList(args, '-', undefined, 'atom');\n        let total = 0n;\n        let sign = 1n;\n        let argSize = 0;\n        for (const item of list) {\n            total += sign * item.toBigInt();\n            sign = -1n;\n            argSize += item.atom.length;\n            cost += costs.arithPerArg;\n        }\n        cost += BigInt(argSize) * costs.arithPerByte;\n        return mallocCost({ value: Program.fromBigInt(total), cost });\n    }) as Operator,\n    '*': ((args: Program): ProgramOutput => {\n        const list = toList(args, '*', undefined, 'atom');\n        let cost = costs.mulBase;\n        if (!list.length) return mallocCost({ value: Program.true, cost });\n        let value = list[0].toBigInt();\n        let size = list[0].atom.length;\n        for (const item of list.slice(1)) {\n            cost +=\n                costs.mulPerOp +\n                (BigInt(item.atom.length) + BigInt(size)) *\n                    costs.mulLinearPerByte +\n                (BigInt(item.atom.length) * BigInt(size)) /\n                    costs.mulSquarePerByteDivider;\n            value *= item.toBigInt();\n            size = limbsForBigInt(value);\n        }\n        return mallocCost({ value: Program.fromBigInt(value), cost });\n    }) as Operator,\n    divmod: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'divmod', 2, 'atom');\n        let cost = costs.divmodBase;\n        const numerator = list[0].toBigInt();\n        const denominator = list[1].toBigInt();\n        if (denominator === 0n)\n            throw new Error(\n                `Cannot divide by zero in \"divmod\" operator${args.positionSuffix}.`\n            );\n        cost +=\n            (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) *\n            costs.divmodPerByte;\n        let quotientValue = numerator / denominator;\n        const remainderValue = mod(numerator, denominator);\n        if (numerator < 0n !== denominator < 0n && remainderValue !== 0n)\n            quotientValue -= 1n;\n        const quotient = Program.fromBigInt(quotientValue);\n        const remainder = Program.fromBigInt(remainderValue);\n        cost +=\n            (BigInt(quotient.atom.length) + BigInt(remainder.atom.length)) *\n            costs.mallocPerByte;\n        return { value: Program.cons(quotient, remainder), cost };\n    }) as Operator,\n    '/': ((args: Program): ProgramOutput => {\n        const list = toList(args, '/', 2, 'atom');\n        let cost = costs.divBase;\n        const numerator = list[0].toBigInt();\n        const denominator = list[1].toBigInt();\n        if (denominator === 0n)\n            throw new Error(\n                `Cannot divide by zero in \"/\" operator${args.positionSuffix}.`\n            );\n        cost +=\n            (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) *\n            costs.divPerByte;\n        let quotientValue = numerator / denominator;\n        const remainderValue = mod(numerator, denominator);\n        if (numerator < 0n !== denominator < 0n && quotientValue < 0n)\n            quotientValue -= 1n;\n        const quotient = Program.fromBigInt(quotientValue);\n        return mallocCost({ value: quotient, cost });\n    }) as Operator,\n    '>': ((args: Program): ProgramOutput => {\n        const list = toList(args, '>', 2, 'atom');\n        const cost =\n            costs.grBase +\n            (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) *\n                costs.grPerByte;\n        return {\n            value: Program.fromBool(list[0].toBigInt() > list[1].toBigInt()),\n            cost,\n        };\n    }) as Operator,\n    '>s': ((args: Program): ProgramOutput => {\n        const list = toList(args, '>s', 2, 'atom');\n        const cost =\n            costs.grsBase +\n            (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) *\n                costs.grsPerByte;\n        return {\n            value: Program.fromBool(\n                list[0].toHex().localeCompare(list[1].toHex()) === 1\n            ),\n            cost,\n        };\n    }) as Operator,\n    pubkey_for_exp: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'pubkey_for_exp', 1, 'atom');\n        const value = mod(list[0].toBigInt(), defaultEc.n);\n        const exponent = PrivateKey.fromBytes(bigIntToBytes(value, 32, 'big'));\n        const cost =\n            costs.pubkeyBase +\n            BigInt(list[0].atom.length) * costs.pubkeyPerByte;\n        return mallocCost({\n            value: Program.fromBytes(exponent.getG1().toBytes()),\n            cost,\n        });\n    }) as Operator,\n    point_add: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'point_add', undefined, 'atom');\n        let cost = costs.pointAddBase;\n        let point = JacobianPoint.infinityG1();\n        for (const item of list) {\n            point = point.add(JacobianPoint.fromBytes(item.atom, false));\n            cost += costs.pointAddPerArg;\n        }\n        return mallocCost({ value: Program.fromBytes(point.toBytes()), cost });\n    }) as Operator,\n    strlen: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'strlen', 1, 'atom');\n        const size = list[0].atom.length;\n        const cost = costs.strlenBase + BigInt(size) * costs.strlenPerByte;\n        return mallocCost({ value: Program.fromInt(size), cost });\n    }) as Operator,\n    substr: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'substr', [2, 3], 'atom');\n        const value = list[0].atom;\n        if (\n            list[1].atom.length > 4 ||\n            (list.length === 3 && list[2].atom.length > 4)\n        )\n            throw new Error(\n                `Expected 4 byte indices in \"substr\" operator${args.positionSuffix}.`\n            );\n        const from = list[1].toInt();\n        const to = list.length === 3 ? list[2].toInt() : value.length;\n        if (to > value.length || to < from || to < 0 || from < 0)\n            throw new Error(\n                `Invalid indices in \"substr\" operator${args.positionSuffix}.`\n            );\n        return { value: Program.fromBytes(value.slice(from, to)), cost: 1n };\n    }) as Operator,\n    concat: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'concat', undefined, 'atom');\n        let cost = costs.concatBase;\n        const bytes: Array<number> = [];\n        for (const item of list) {\n            for (const byte of item.atom) bytes.push(byte);\n            cost += costs.concatPerArg;\n        }\n        cost += BigInt(bytes.length) * costs.concatPerByte;\n        return mallocCost({\n            value: Program.fromBytes(Uint8Array.from(bytes)),\n            cost,\n        });\n    }) as Operator,\n    ash: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'ash', 2, 'atom');\n        if (list[1].atom.length > 4)\n            throw new Error(\n                `Shift must be 32 bits in \"ash\" operator${args.positionSuffix}.`\n            );\n        const shift = list[1].toBigInt();\n        if ((shift < 0n ? -shift : shift) > 65535n)\n            throw new Error(\n                `Shift too large in \"ash\" operator${args.positionSuffix}.`\n            );\n        let value = list[0].toBigInt();\n        if (shift >= 0) value <<= shift;\n        else value >>= -shift;\n        const cost =\n            costs.ashiftBase +\n            (BigInt(list[0].atom.length) + BigInt(limbsForBigInt(value))) *\n                costs.ashiftPerByte;\n        return mallocCost({ value: Program.fromBigInt(value), cost });\n    }) as Operator,\n    lsh: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'lsh', 2, 'atom');\n        if (list[1].atom.length > 4)\n            throw new Error(\n                `Shift must be 32 bits in \"lsh\" operator${args.positionSuffix}.`\n            );\n        const shift = list[1].toBigInt();\n        if ((shift < 0n ? -shift : shift) > 65535n)\n            throw new Error(\n                `Shift too large in \"lsh\" operator${args.positionSuffix}.`\n            );\n        let value = bytesToBigInt(list[0].atom, 'big', false);\n        if (value < 0n) value = -value;\n        if (shift >= 0) value <<= shift;\n        else value >>= -shift;\n        const cost =\n            costs.lshiftBase +\n            (BigInt(list[0].atom.length) + BigInt(limbsForBigInt(value))) *\n                costs.lshiftPerByte;\n        return mallocCost({ value: Program.fromBigInt(value), cost });\n    }) as Operator,\n    logand: ((args: Program): ProgramOutput =>\n        binopReduction('logand', -1n, args, (a, b) => a & b)) as Operator,\n    logior: ((args: Program): ProgramOutput =>\n        binopReduction('logior', 0n, args, (a, b) => a | b)) as Operator,\n    logxor: ((args: Program): ProgramOutput =>\n        binopReduction('logxor', 0n, args, (a, b) => a ^ b)) as Operator,\n    lognot: ((args: Program): ProgramOutput => {\n        const items = toList(args, 'lognot', 1, 'atom');\n        const cost =\n            costs.lognotBase +\n            BigInt(items[0].atom.length) * costs.lognotPerByte;\n        return mallocCost({\n            value: Program.fromBigInt(~items[0].toBigInt()),\n            cost,\n        });\n    }) as Operator,\n    not: ((args: Program): ProgramOutput => {\n        const items = toList(args, 'not', 1);\n        const cost = costs.boolBase;\n        return { value: Program.fromBool(items[0].isNull), cost: cost };\n    }) as Operator,\n    any: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'any');\n        const cost = costs.boolBase + BigInt(list.length) * costs.boolPerArg;\n        let result = false;\n        for (const item of list) {\n            if (!item.isNull) {\n                result = true;\n                break;\n            }\n        }\n        return { value: Program.fromBool(result), cost: cost };\n    }) as Operator,\n    all: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'all');\n        const cost = costs.boolBase + BigInt(list.length) * costs.boolPerArg;\n        let result = true;\n        for (const item of list) {\n            if (item.isNull) {\n                result = false;\n                break;\n            }\n        }\n        return { value: Program.fromBool(result), cost: cost };\n    }) as Operator,\n    softfork: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'softfork', [1, Infinity]);\n        if (!list[0].isAtom)\n            throw new Error(\n                `Expected atom argument in \"softfork\" operator at ${list[0].positionSuffix}.`\n            );\n        const cost = list[0].toBigInt();\n        if (cost < 1n)\n            throw new Error(\n                `Cost must be greater than zero in \"softfork\" operator${args.positionSuffix}.`\n            );\n        return { value: Program.false, cost: cost };\n    }) as Operator,\n};\n\nexport const defaultOperators = {\n    operators,\n    unknown: defaultUnknownOperator,\n    quote: 'q',\n    apply: 'a',\n};\n\nexport function makeDefaultOperators() {\n    return {\n        ...defaultOperators,\n        operators: { ...defaultOperators.operators },\n    };\n}\n\nexport function toList(\n    program: Program,\n    name: string,\n    length?: [number, number] | number,\n    type?: 'atom' | 'cons'\n): Program[] {\n    const list = program.toList();\n    if (typeof length === 'number' && list.length !== length)\n        throw new Error(\n            `Expected ${length} arguments in ${JSON.stringify(name)} operator${\n                program.positionSuffix\n            }.`\n        );\n    else if (\n        Array.isArray(length) &&\n        (list.length < length[0] || list.length > length[1])\n    )\n        throw new Error(\n            `Expected ${\n                length[1] === Infinity\n                    ? `at least ${length[0]}`\n                    : `between ${length[0]} and ${length[1]}`\n            } arguments in ${JSON.stringify(name)} operator${\n                program.positionSuffix\n            }.`\n        );\n    if (type !== undefined)\n        list.forEach((item) => {\n            if (\n                (type === 'atom' && !item.isAtom) ||\n                (type === 'cons' && !item.isCons)\n            )\n                throw new Error(\n                    `Expected ${type} argument in ${JSON.stringify(\n                        name\n                    )} operator${item.positionSuffix}.`\n                );\n        });\n    return list;\n}\n\nexport function limbsForBigInt(value: bigint): number {\n    let length =\n        value === 0n ? 0 : (value < 0n ? -value : value).toString(2).length;\n    if (value < 0n) length++;\n    return (length + 7) >> 3;\n}\n\nexport function mallocCost(output: ProgramOutput): ProgramOutput {\n    return {\n        value: output.value,\n        cost:\n            output.cost +\n            BigInt(output.value.atom.length) * costs.mallocPerByte,\n    };\n}\n\nexport function binopReduction(\n    opName: string,\n    initialValue: bigint,\n    args: Program,\n    opFunction: (a: bigint, b: bigint) => bigint\n): ProgramOutput {\n    let total = initialValue;\n    let argSize = 0;\n    let cost = costs.logBase;\n    for (const item of args.toList().map((item) => {\n        if (!item.isAtom)\n            throw new Error(\n                `Expected atom argument in ${JSON.stringify(opName)} operator${\n                    item.positionSuffix\n                }.`\n            );\n        return item;\n    })) {\n        total = opFunction(total, item.toBigInt());\n        argSize += item.atom.length;\n        cost += costs.logPerArg;\n    }\n    cost += BigInt(argSize) * costs.logPerByte;\n    return mallocCost({ value: Program.fromBigInt(total), cost });\n}\n\nexport function defaultUnknownOperator(\n    op: Program,\n    args: Program\n): ProgramOutput {\n    if (\n        !op.atom.length ||\n        bytesEqual(op.atom.slice(0, 2), Uint8Array.from([0xff, 0xff]))\n    )\n        throw new Error(`Reserved operator${op.positionSuffix}.`);\n    if (op.atom.length > 5)\n        throw new Error(`Invalid operator${op.positionSuffix}.`);\n    const costFunction = (op.atom[op.atom.length - 1] & 0xc0) >> 6;\n    const costMultiplier =\n        bytesToInt(op.atom.slice(0, op.atom.length - 1), 'big') + 1;\n    let cost: bigint;\n    if (costFunction === 0) cost = 1n;\n    else if (costFunction === 1) {\n        cost = costs.arithBase;\n        let argSize = 0;\n        for (const item of args.toList()) {\n            if (!item.isAtom)\n                throw new Error(\n                    `Expected atom argument${item.positionSuffix}.`\n                );\n            argSize += item.atom.length;\n            cost += costs.arithPerArg;\n        }\n        cost += BigInt(argSize) * costs.arithPerByte;\n    } else if (costFunction === 2) {\n        cost = costs.mulBase;\n        const argList = args.toList();\n        if (argList.length) {\n            const first = argList[0];\n            if (!first.isAtom)\n                throw new Error(\n                    `Expected atom argument${first.positionSuffix}.`\n                );\n            let current = first.atom.length;\n            for (const item of argList.slice(1)) {\n                if (!item.isAtom)\n                    throw new Error(\n                        `Expected atom argument${item.positionSuffix}.`\n                    );\n                cost +=\n                    costs.mulPerOp +\n                    (BigInt(item.atom.length) + BigInt(current)) *\n                        costs.mulLinearPerByte +\n                    (BigInt(item.atom.length) * BigInt(current)) /\n                        costs.mulSquarePerByteDivider;\n                current += item.atom.length;\n            }\n        }\n    } else if (costFunction === 3) {\n        cost = costs.concatBase;\n        let length = 0;\n        for (const item of args.toList()) {\n            if (!item.isAtom)\n                throw new Error(\n                    `Expected atom argument${item.positionSuffix}.`\n                );\n            cost += costs.concatPerArg;\n            length += item.atom.length;\n        }\n        cost += BigInt(length) * costs.concatPerByte;\n    } else throw new Error(`Unknown cost function${op.positionSuffix}.`);\n    cost *= BigInt(costMultiplier);\n    if (cost >= 2n ** 32n)\n        throw new Error(`Invalid operator${op.positionSuffix}.`);\n    return { value: Program.nil, cost: cost };\n}\n\nexport function runOperator(\n    op: Program,\n    args: Program,\n    options: RunOptions\n): ProgramOutput {\n    const symbol = op.toBigInt();\n    const keyword =\n        Object.entries(keywords).find((entry) => entry[1] === symbol)?.[0] ??\n        op.toText();\n    if (keyword in options.operators.operators) {\n        const result = options.operators.operators[keyword](args);\n        return result;\n    } else return options.operators.unknown(op, args);\n}\n","import { decodeInt } from 'chia-bls';\nimport { ParserError } from '../types/ParserError';\nimport { Program } from '../types/Program';\n\nexport function deserialize(program: number[]): Program {\n    const sizeBytes: Array<number> = [];\n    if (program[0] <= 0x7f)\n        return Program.fromBytes(Uint8Array.from([program[0]]));\n    else if (program[0] <= 0xbf) sizeBytes.push(program[0] & 0x3f);\n    else if (program[0] <= 0xdf) {\n        sizeBytes.push(program[0] & 0x1f);\n        program.shift();\n        if (!program.length)\n            throw new ParserError('Expected next byte in source.');\n        sizeBytes.push(program[0]);\n    } else if (program[0] <= 0xef) {\n        sizeBytes.push(program[0] & 0x0f);\n        for (let i = 0; i < 2; i++) {\n            program.shift();\n            if (!program.length)\n                throw new ParserError('Expected next byte in source.');\n            sizeBytes.push(program[0]);\n        }\n    } else if (program[0] <= 0xf7) {\n        sizeBytes.push(program[0] & 0x07);\n        for (let i = 0; i < 3; i++) {\n            program.shift();\n            if (!program.length)\n                throw new ParserError('Expected next byte in source.');\n            sizeBytes.push(program[0]);\n        }\n    } else if (program[0] <= 0xfb) {\n        sizeBytes.push(program[0] & 0x03);\n        for (let i = 0; i < 4; i++) {\n            program.shift();\n            if (!program.length)\n                throw new ParserError('Expected next byte in source.');\n            sizeBytes.push(program[0]);\n        }\n    } else if (program[0] === 0xff) {\n        program.shift();\n        if (!program.length)\n            throw new ParserError('Expected next byte in source.');\n        const first = deserialize(program);\n        program.shift();\n        if (!program.length)\n            throw new ParserError('Expected next byte in source.');\n        const rest = deserialize(program);\n        return Program.cons(first, rest);\n    } else throw new ParserError('Invalid encoding.');\n    const size = decodeInt(Uint8Array.from(sizeBytes));\n    let bytes: Array<number> = [];\n    for (let i = 0; i < size; i++) {\n        program.shift();\n        if (!program.length) {\n            throw new ParserError('Expected next byte in atom.');\n        }\n        bytes.push(program[0]);\n    }\n    return Program.fromBytes(Uint8Array.from(bytes));\n}\n","import { keywords } from '../constants/keywords';\nimport { ParserError } from '../types/ParserError';\nimport { Position } from '../types/Position';\nimport { Program } from '../types/Program';\nimport { Token } from '../types/Token';\n\nexport function next(tokens: Token[]): Token | undefined {\n    tokens.shift();\n    return tokens[0];\n}\n\nexport function expect(source: string, tokens: Token[]): void {\n    const token = tokens[0];\n    if (!next(tokens))\n        throw new ParserError(\n            `Unexpected end of source at ${new Position(source, token.index)}.`\n        );\n}\n\nexport function isSpace(char: string): boolean {\n    return /^[\\u0020\\u202F\\u205F\\u2028\\u2029\\u3000\\u0085\\u1680\\u00A0\\u2000-\\u200A\\u0009-\\u000D\\u001C-\\u001F]$/.test(\n        char\n    );\n}\n\nexport function consumeWhitespace(text: string, index: number): number {\n    while (true) {\n        while (index < text.length && isSpace(text[index])) index++;\n        if (index >= text.length || text[index] !== ';') break;\n        while (index < text.length && !'\\n\\r'.includes(text[index])) index++;\n    }\n    return index;\n}\n\nexport function consumeUntilWhitespace(text: string, index: number): Token {\n    const start = index;\n    while (index < text.length && !isSpace(text[index]) && text[index] !== ')')\n        index++;\n    return { text: text.slice(start, index), index };\n}\n\nexport function tokenizeCons(source: string, tokens: Token[]): Program {\n    let token = tokens[0];\n    if (token.text === ')')\n        return Program.fromBytes(Uint8Array.from([])).at(\n            new Position(source, token.index)\n        );\n    const consStart = token.index;\n    const first = tokenizeExpr(source, tokens);\n    expect(source, tokens);\n    token = tokens[0];\n    let rest: Program;\n    if (token.text === '.') {\n        const dotStart = token.index;\n        expect(source, tokens);\n        token = tokens[0];\n        rest = tokenizeExpr(source, tokens);\n        expect(source, tokens);\n        token = tokens[0];\n        if (token.text !== ')')\n            throw new ParserError(\n                `Illegal dot expression at ${new Position(source, dotStart)}.`\n            );\n    } else rest = tokenizeCons(source, tokens);\n    return Program.cons(first, rest).at(new Position(source, consStart));\n}\n\nexport function tokenizeInt(source: string, token: Token): Program | null {\n    return /^[+\\-]?[0-9]+(?:_[0-9]+)*$/.test(token.text)\n        ? Program.fromBigInt(BigInt(token.text.replaceAll('_', ''))).at(\n              new Position(source, token.index)\n          )\n        : null;\n}\n\nexport function tokenizeHex(source: string, token: Token): Program | null {\n    if (\n        token.text.length >= 2 &&\n        token.text.slice(0, 2).toLowerCase() === '0x'\n    ) {\n        let hex = token.text.slice(2);\n        if (hex.length % 2 === 1) hex = `0${hex}`;\n        try {\n            return Program.fromHex(hex).at(new Position(source, token.index));\n        } catch (e) {\n            throw new ParserError(\n                `Invalid hex ${JSON.stringify(token.text)} at ${new Position(\n                    source,\n                    token.index\n                )}.`\n            );\n        }\n    } else return null;\n}\n\nexport function tokenizeQuotes(source: string, token: Token): Program | null {\n    if (token.text.length < 2) return null;\n    const quote = token.text[0];\n    if (!'\"\\''.includes(quote)) return null;\n    if (token.text[token.text.length - 1] !== quote)\n        throw new ParserError(\n            `Unterminated string ${JSON.stringify(\n                token.text\n            )} at ${new Position(source, token.index)}.`\n        );\n    return Program.fromText(token.text.slice(1, token.text.length - 1)).at(\n        new Position(source, token.index)\n    );\n}\n\nexport function tokenizeSymbol(source: string, token: Token): Program | null {\n    let text = token.text;\n    if (text.startsWith('#')) text = text.slice(1);\n    const keyword: bigint | undefined = keywords[text as keyof typeof keywords];\n    return (\n        keyword === undefined\n            ? Program.fromText(text)\n            : Program.fromBigInt(keyword)\n    ).at(new Position(source, token.index));\n}\n\nexport function tokenizeExpr(source: string, tokens: Token[]): Program {\n    const token = tokens[0];\n    if (token.text === '(') {\n        expect(source, tokens);\n        return tokenizeCons(source, tokens);\n    }\n    const result =\n        tokenizeInt(source, token) ??\n        tokenizeHex(source, token) ??\n        tokenizeQuotes(source, token) ??\n        tokenizeSymbol(source, token);\n    if (!result)\n        throw new ParserError(\n            `Invalid expression ${JSON.stringify(token.text)} at ${new Position(\n                source,\n                token.index\n            )}.`\n        );\n    return result;\n}\n\nexport function* tokenStream(source: string): IterableIterator<Token> {\n    let index = 0;\n    while (index < source.length) {\n        index = consumeWhitespace(source, index);\n        if (index >= source.length) break;\n        const char = source[index];\n        if ('(.)'.includes(char)) {\n            yield { text: char, index };\n            index++;\n            continue;\n        }\n        if ('\"\\''.includes(char)) {\n            const start = index;\n            const quote = source[index];\n            index++;\n            while (index < source.length && source[index] !== quote) index++;\n            if (index < source.length) {\n                yield { text: source.slice(start, index + 1), index: start };\n                index++;\n                continue;\n            } else\n                throw new ParserError(\n                    `Unterminated string at ${new Position(source, index)}.`\n                );\n        }\n        const token = consumeUntilWhitespace(source, index);\n        yield { text: token.text, index };\n        index = token.index;\n    }\n}\n","export class Position {\n    public line: number;\n    public column: number;\n\n    constructor(source: string, index: number) {\n        source = source.replaceAll('\\r\\n', '\\n');\n        let line = 1;\n        let column = 1;\n        for (let i = 0; i < index; i++) {\n            if (source[i] === '\\n') {\n                line++;\n                column = 1;\n            } else {\n                column++;\n            }\n        }\n        this.line = line;\n        this.column = column;\n    }\n\n    public toString(): string {\n        return `${this.line}:${this.column}`;\n    }\n}\n"],"names":[],"version":3,"file":"index.js.map","sourceRoot":"../../"}