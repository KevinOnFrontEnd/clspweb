export type AnyField = Field<AnyField>;
export abstract class Field<T extends Field<T>> {
    abstract Q: bigint;
    abstract extension: number;
    abstract zero(Q: bigint): this;
    abstract one(Q: bigint): this;
    abstract fromBytes(Q: bigint, bytes: Uint8Array): this;
    abstract fromHex(Q: bigint, hex: string): this;
    abstract fromFq(Q: bigint, fq: Fq): this;
    abstract clone(): this;
    abstract toBytes(): Uint8Array;
    abstract toBool(): boolean;
    abstract toHex(): string;
    abstract toString(): string;
    abstract negate(): this;
    abstract inverse(): this;
    abstract qiPower(i: number): this;
    abstract pow(exponent: bigint): this;
    abstract addTo(value: AnyField | bigint): this;
    abstract multiplyWith(value: AnyField | bigint): this;
    abstract add(value: AnyField | bigint): AnyField;
    abstract subtract(value: AnyField | bigint): AnyField;
    abstract multiply(value: AnyField | bigint): AnyField;
    abstract divide(value: AnyField | bigint): AnyField;
    abstract equalTo(value: AnyField | bigint): boolean;
    abstract equals(value: AnyField | bigint): boolean;
    abstract lt(value: this): boolean;
    abstract gt(value: this): boolean;
    abstract lteq(value: this): boolean;
    abstract gteq(value: this): boolean;
}
export abstract class FieldExt<T extends Field<T>> extends Field<FieldExt<T>> {
    Q: bigint;
    abstract root: T;
    elements: T[];
    basefield: T;
    constructor(Q: bigint, elements: T[]);
    abstract construct(Q: bigint, elements: T[]): this;
    constructWithRoot(Q: bigint, elements: T[]): this;
    withRoot(root: T): this;
    fromBytes(Q: bigint, bytes: Uint8Array): this;
    fromHex(Q: bigint, hex: string): this;
    fromFq(Q: bigint, fq: Fq): this;
    zero(Q: bigint): this;
    one(Q: bigint): this;
    clone(): this;
    toBytes(): Uint8Array;
    toBool(): boolean;
    toHex(): string;
    toString(): string;
    negate(): this;
    qiPower(i: number): this;
    pow(exponent: bigint): this;
    addTo(value: AnyField | bigint): this;
    multiplyWith(value: AnyField | bigint): this;
    subtract(value: AnyField | bigint): FieldExt<AnyField>;
    divide(value: AnyField | bigint): FieldExt<AnyField>;
    equalTo(value: AnyField | bigint): boolean;
    lt(value: this): boolean;
    gt(value: this): boolean;
    lteq(value: this): boolean;
    gteq(value: this): boolean;
    add(value: AnyField | bigint): FieldExt<AnyField>;
    multiply(value: AnyField | bigint): FieldExt<AnyField>;
    equals(value: AnyField | bigint): boolean;
}
export class Fq extends Field<Fq> {
    Q: bigint;
    static nil: Fq;
    extension: number;
    value: bigint;
    constructor(Q: bigint, value: bigint);
    fromBytes(Q: bigint, bytes: Uint8Array): this;
    fromHex(Q: bigint, hex: string): this;
    fromFq(_Q: bigint, fq: this): this;
    zero(Q: bigint): this;
    one(Q: bigint): this;
    clone(): this;
    toBytes(): Uint8Array;
    toBool(): boolean;
    toHex(): string;
    toString(): string;
    negate(): this;
    inverse(): this;
    qiPower(_i: number): this;
    pow(exponent: bigint): this;
    addTo(value: AnyField | bigint): this;
    multiplyWith(value: AnyField | bigint): this;
    subtract(value: AnyField | bigint): this;
    divide(value: AnyField | bigint): this;
    equalTo(value: AnyField | bigint): boolean;
    lt(value: Fq): boolean;
    gt(value: Fq): boolean;
    lteq(value: Fq): boolean;
    gteq(value: Fq): boolean;
    modSqrt(): Fq;
    add(value: AnyField | bigint): AnyField;
    multiply(value: AnyField | bigint): AnyField;
    equals(value: AnyField | bigint): boolean;
}
export class Fq2 extends FieldExt<Fq> {
    static nil: Fq2;
    extension: number;
    root: Fq;
    constructor(Q: bigint, x: Fq, y: Fq);
    construct(Q: bigint, elements: Fq[]): this;
    inverse(): this;
    mulByNonResidue(): this;
    modSqrt(): this;
}
export class Fq6 extends FieldExt<Fq2> {
    static nil: Fq6;
    extension: number;
    root: Fq2;
    constructor(Q: bigint, x: Fq2, y: Fq2, z: Fq2);
    construct(Q: bigint, elements: Fq2[]): this;
    inverse(): this;
    mulByNonResidue(): this;
}
export class Fq12 extends FieldExt<Fq6> {
    static nil: Fq12;
    extension: number;
    root: Fq6;
    constructor(Q: bigint, x: Fq6, y: Fq6);
    construct(Q: bigint, elements: Fq6[]): this;
    inverse(): this;
}
export const x = -15132376222941642752n;
export const q = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787n;
export const a: Fq;
export const b: Fq;
export const aTwist: Fq2;
export const bTwist: Fq2;
export const gx: Fq;
export const gy: Fq;
export const g2x: Fq2;
export const g2y: Fq2;
export const n = 52435875175126190479447740508185965837690552500527637822603658699938581184513n;
export const h = 76329603384216526031706109802092473003n;
export const hEff = 209869847837335686905080341498658477663839067235703451875306851526599783796572738804459333109033834234622528588876978987822447936461846631641690358257586228683615991308971558879306463436166481n;
export const k = 12n;
export const sqrtN3 = 1586958781458431025242759403266842894121773480562120986020912974854563298150952611241517463240701n;
export const sqrtN3m1o2 = 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n;
export const defaultEc: EC;
export const defaultEcTwist: EC;
export const frobCoeffs: Record<`${number},${number},${number}`, AnyField>;
export function getFrobCoeff(extension: number, i: number, index: number): AnyField | undefined;
export const sha256: HashInfo;
export const sha512: HashInfo;
export const xnum: Fq2[];
export const xden: Fq2[];
export const ynum: Fq2[];
export const yden: Fq2[];
export const xi_2: Fq2;
export const Ell2p_a: Fq2;
export const Ell2p_b: Fq2;
export const ev1 = 1015919005498129635886032702454337503112659152043614931979881174103627376789972962005013361970813319613593700736144n;
export const ev2 = 1244231661155348484223428017511856347821538750986231559855759541903146219579071812422210818684355842447591283616181n;
export const ev3 = 1646015993121829755895883253076789309308090876275172350194834453434199515639474951814226234213676147507404483718679n;
export const ev4 = 1637752706019426886789797193293828301565549384974986623510918743054325021588194075665960171838131772227885159387073n;
export const etas: Fq2[];
export const rv1 = 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n;
export const rootsOfUnity: Fq2[];
export const basicSchemeDst: Uint8Array;
export const augSchemeDst: Uint8Array;
export const popSchemeDst: Uint8Array;
export const popSchemePopDst: Uint8Array;
export class AffinePoint {
    x: Fq | Fq2;
    y: Fq | Fq2;
    isInfinity: boolean;
    ec: EC;
    constructor(x: Fq | Fq2, y: Fq | Fq2, isInfinity: boolean, ec?: EC);
    isOnCurve(): boolean;
    toJacobian(): JacobianPoint;
    twist(): AffinePoint;
    untwist(): AffinePoint;
    double(): AffinePoint;
    add(value: AffinePoint): AffinePoint;
    subtract(value: AffinePoint): AffinePoint;
    multiply(value: Fq | bigint): AffinePoint;
    negate(): AffinePoint;
    equals(value: AffinePoint): boolean;
    clone(): AffinePoint;
    toString(): string;
}
export interface EC {
    q: bigint;
    a: AnyField;
    b: AnyField;
    gx: Fq;
    gy: Fq;
    g2x: Fq2;
    g2y: Fq2;
    n: bigint;
    h: bigint;
    x: bigint;
    k: bigint;
    sqrtN3: bigint;
    sqrtN3m1o2: bigint;
}
export class JacobianPoint {
    x: Fq | Fq2;
    y: Fq | Fq2;
    z: Fq | Fq2;
    isInfinity: boolean;
    ec: EC;
    static fromBytes(bytes: Uint8Array, isExtension: boolean, ec?: EC): JacobianPoint;
    static fromHex(hex: string, isExtension: boolean, ec?: EC): JacobianPoint;
    static generateG1(): JacobianPoint;
    static generateG2(): JacobianPoint;
    static infinityG1(isExtension?: boolean): JacobianPoint;
    static infinityG2(isExtension?: boolean): JacobianPoint;
    static fromBytesG1(bytes: Uint8Array, isExtension?: boolean): JacobianPoint;
    static fromBytesG2(bytes: Uint8Array, isExtension?: boolean): JacobianPoint;
    static fromHexG1(hex: string, isExtension?: boolean): JacobianPoint;
    static fromHexG2(hex: string, isExtension?: boolean): JacobianPoint;
    constructor(x: Fq | Fq2, y: Fq | Fq2, z: Fq | Fq2, isInfinity: boolean, ec?: EC);
    isOnCurve(): boolean;
    isValid(): boolean;
    getFingerprint(): number;
    toAffine(): AffinePoint;
    toBytes(): Uint8Array;
    toHex(): string;
    toString(): string;
    double(): JacobianPoint;
    negate(): JacobianPoint;
    add(value: JacobianPoint): JacobianPoint;
    multiply(value: Fq | bigint): JacobianPoint;
    equals(value: JacobianPoint): boolean;
    clone(): JacobianPoint;
}
export class OperatorError extends Error {
    constructor(message: string);
}
export class AssertionError extends Error {
    constructor(message: string);
}
export function assert(test: boolean, message?: string): void;
export interface HashInfo {
    convert: (bytes: Uint8Array) => Uint8Array;
    byteSize: number;
    blockSize: number;
}
export class PrivateKey {
    value: bigint;
    static size: number;
    static fromBytes(bytes: Uint8Array): PrivateKey;
    static fromHex(hex: string): PrivateKey;
    static fromSeed(seed: Uint8Array): PrivateKey;
    static fromBigInt(value: bigint): PrivateKey;
    static aggregate(privateKeys: PrivateKey[]): PrivateKey;
    constructor(value: bigint);
    getG1(): JacobianPoint;
    toBytes(): Uint8Array;
    toHex(): string;
    toString(): string;
    equals(value: PrivateKey): boolean;
}
export class AugSchemeMPL {
    static keyGen(seed: Uint8Array): PrivateKey;
    static sign(privateKey: PrivateKey, message: Uint8Array): JacobianPoint;
    static sign_prepend(privateKey: PrivateKey, message: Uint8Array, prependPublicKey: JacobianPoint): JacobianPoint;
    static verify(publicKey: JacobianPoint, message: Uint8Array, signature: JacobianPoint): boolean;
    static aggregate(signatures: JacobianPoint[]): JacobianPoint;
    static aggregateVerify(publicKeys: JacobianPoint[], messages: Uint8Array[], signature: JacobianPoint): boolean;
    static deriveChildSk(privateKey: PrivateKey, index: number): PrivateKey;
    static deriveChildSkUnhardened(privateKey: PrivateKey, index: number): PrivateKey;
    static deriveChildPkUnhardened(publicKey: JacobianPoint, index: number): JacobianPoint;
}
export class BasicSchemeMPL {
    static keyGen(seed: Uint8Array): PrivateKey;
    static sign(privateKey: PrivateKey, message: Uint8Array): JacobianPoint;
    static verify(publicKey: JacobianPoint, message: Uint8Array, signature: JacobianPoint): boolean;
    static aggregate(signatures: JacobianPoint[]): JacobianPoint;
    static aggregateVerify(publicKeys: JacobianPoint[], messages: Uint8Array[], signature: JacobianPoint): boolean;
    static deriveChildSk(privateKey: PrivateKey, index: number): PrivateKey;
    static deriveChildSkUnhardened(privateKey: PrivateKey, index: number): PrivateKey;
    static deriveChildPkUnhardened(publicKey: JacobianPoint, index: number): JacobianPoint;
}
export class PopSchemeMPL {
    static keyGen(seed: Uint8Array): PrivateKey;
    static sign(privateKey: PrivateKey, message: Uint8Array): JacobianPoint;
    static verify(publicKey: JacobianPoint, message: Uint8Array, signature: JacobianPoint): boolean;
    static aggregate(signatures: JacobianPoint[]): JacobianPoint;
    static aggregateVerify(publicKeys: JacobianPoint[], messages: Uint8Array[], signature: JacobianPoint): boolean;
    static popProve(privateKey: PrivateKey): JacobianPoint;
    static popVerify(publicKey: JacobianPoint, proof: JacobianPoint): boolean;
    static fastAggregateVerify(publicKeys: JacobianPoint[], message: Uint8Array, signature: JacobianPoint): boolean;
    static deriveChildSk(privateKey: PrivateKey, index: number): PrivateKey;
    static deriveChildSkUnhardened(privateKey: PrivateKey, index: number): PrivateKey;
    static deriveChildPkUnhardened(publicKey: JacobianPoint, index: number): JacobianPoint;
}
export type Endian = 'little' | 'big';
export function flip(binary: string): string;
export function intBitLength(value: number): number;
export function bigIntBitLength(value: bigint): number;
export function bigIntToBits(i: bigint): number[];
export function intToBits(i: number): number[];
export function intToBytes(value: number, size: number, endian: Endian, signed?: boolean): Uint8Array;
export function bytesToInt(bytes: Uint8Array, endian: Endian, signed?: boolean): number;
export function encodeInt(value: number): Uint8Array;
export function decodeInt(bytes: Uint8Array): number;
export function bigIntToBytes(value: bigint, size: number, endian: Endian, signed?: boolean): Uint8Array;
export function bytesToBigInt(bytes: Uint8Array, endian: Endian, signed?: boolean): bigint;
export function encodeBigInt(value: bigint): Uint8Array;
export function decodeBigInt(bytes: Uint8Array): bigint;
export function concatBytes(...lists: Uint8Array[]): Uint8Array;
export function bytesEqual(a: Uint8Array, b: Uint8Array): boolean;
export function toHex(bytes: Uint8Array): string;
export function fromHex(hex: string): Uint8Array;
export function yForX(x: Fq | Fq2, ec?: EC): Fq | Fq2;
export function scalarMultJacobian(value: Fq | bigint, point: JacobianPoint, ec?: EC): JacobianPoint;
export function evalIso(P: JacobianPoint, mapCoeffs: Fq2[][], ec: EC): JacobianPoint;
export function signFq(element: Fq, ec?: EC): boolean;
export function signFq2(element: Fq2, ec?: EC): boolean;
export function I2OSP(value: bigint, length: number): Uint8Array;
export function OS2IP(octets: Uint8Array): bigint;
export function bytesXor(a: Uint8Array, b: Uint8Array): Uint8Array;
export function expandMessageXmd(message: Uint8Array, dst: Uint8Array, length: number, hash: HashInfo): Uint8Array;
export function expandMessageXof(message: Uint8Array, dst: Uint8Array, length: number, hash: HashInfo): Uint8Array;
export function hashToField(message: Uint8Array, count: number, dst: Uint8Array, modulus: bigint, degree: number, byteLength: number, expand: (message: Uint8Array, dst: Uint8Array, length: number, hash: HashInfo) => Uint8Array, hash: HashInfo): bigint[][];
export function Hp(message: Uint8Array, count: number, dst: Uint8Array): bigint[][];
export function Hp2(message: Uint8Array, count: number, dst: Uint8Array): bigint[][];
export function keyGen(seed: Uint8Array): PrivateKey;
export function ikmToLamportSk(ikm: Uint8Array, salt: Uint8Array): Uint8Array;
export function parentSkToLamportPk(parentSk: PrivateKey, index: number): Uint8Array;
export function deriveChildSk(parentSk: PrivateKey, index: number): PrivateKey;
export function deriveChildSkUnhardened(parentSk: PrivateKey, index: number): PrivateKey;
export function deriveChildG1Unhardened(parentPk: JacobianPoint, index: number): JacobianPoint;
export function deriveChildG2Unhardened(parentPk: JacobianPoint, index: number): JacobianPoint;
export const blockSize = 32;
export function extract(salt: Uint8Array, ikm: Uint8Array): Uint8Array;
export function expand(length: number, prk: Uint8Array, info: Uint8Array): Uint8Array;
export function extractExpand(length: number, key: Uint8Array, salt: Uint8Array, info: Uint8Array): Uint8Array;
export const hmacBlockSize = 64;
export function hash256(message: Uint8Array): Uint8Array;
export function hash512(message: Uint8Array): Uint8Array;
export function hmac256(message: Uint8Array, k: Uint8Array): Uint8Array;
export function modPow(base: bigint, exponent: bigint, modulo: bigint): bigint;
export function mod(value: bigint, modulus: bigint): bigint;
export function modNumber(value: number, modulus: number): number;
export function sgn0(x: Fq2): bigint;
export function osswu2Help(t: Fq2): JacobianPoint;
export function iso3(P: JacobianPoint): JacobianPoint;
export function optSwu2Map(t: Fq2, t2?: Fq2): JacobianPoint;
export function g2Map(alpha: Uint8Array, dst: Uint8Array): JacobianPoint;
export function doubleLineEval(R: AffinePoint, P: AffinePoint, ec?: EC): Fq | Fq2;
export function addLineEval(R: AffinePoint, Q: AffinePoint, P: AffinePoint): Fq | Fq2;
export function millerLoop(T: bigint, P: AffinePoint, Q: AffinePoint, ec?: EC): Fq12;
export function finalExponentiation(element: Fq12, ec?: EC): Fq12;
export function atePairing(P: JacobianPoint, Q: JacobianPoint, ec?: EC): Fq12;
export function atePairingMulti(Ps: JacobianPoint[], Qs: JacobianPoint[], ec?: EC): Fq12;
export function coreSignMpl(sk: PrivateKey, message: Uint8Array, dst: Uint8Array): JacobianPoint;
export function coreVerifyMpl(pk: JacobianPoint, message: Uint8Array, signature: JacobianPoint, dst: Uint8Array): boolean;
export function coreAggregateMpl(signatures: JacobianPoint[]): JacobianPoint;
export function coreAggregateVerify(pks: JacobianPoint[], ms: Uint8Array[], signature: JacobianPoint, dst: Uint8Array): boolean;

//# sourceMappingURL=index.d.ts.map
