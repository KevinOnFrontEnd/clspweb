{"ast":null,"code":"var $fpZC2$chiabls = require(\"chia-bls\");\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function (key) {\n    if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) {\n      return;\n    }\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      }\n    });\n  });\n  return dest;\n}\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"Program\", () => $9636c8954d640602$export$b6c59b989905b650);\nvar $a550084cece3e4e0$exports = {};\n$parcel$export($a550084cece3e4e0$exports, \"ParserError\", () => $a550084cece3e4e0$export$d125cf0331bff9a9);\nclass $a550084cece3e4e0$export$d125cf0331bff9a9 extends Error {\n  constructor(message) {\n    super(message);\n    Object.setPrototypeOf(this, $a550084cece3e4e0$export$d125cf0331bff9a9.prototype);\n  }\n}\nconst $94ca46fd7d128ba2$export$eebaaf2b24d91f63 = {\n  q: 0x01n,\n  a: 0x02n,\n  i: 0x03n,\n  c: 0x04n,\n  f: 0x05n,\n  r: 0x06n,\n  l: 0x07n,\n  x: 0x08n,\n  \"=\": 0x09n,\n  \">s\": 0x0an,\n  sha256: 0x0bn,\n  substr: 0x0cn,\n  strlen: 0x0dn,\n  concat: 0x0en,\n  \"+\": 0x10n,\n  \"-\": 0x11n,\n  \"*\": 0x12n,\n  \"/\": 0x13n,\n  divmod: 0x14n,\n  \">\": 0x15n,\n  ash: 0x16n,\n  lsh: 0x17n,\n  logand: 0x18n,\n  logior: 0x19n,\n  logxor: 0x1an,\n  lognot: 0x1bn,\n  point_add: 0x1dn,\n  pubkey_for_exp: 0x1en,\n  not: 0x20n,\n  any: 0x21n,\n  all: 0x22n,\n  \".\": 0x23n,\n  softfork: 0x24n\n};\nconst $1382d0708deed0de$export$b81a09a7187d4786 = `0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+,-./:;<=>?@[\\]^_\\`{|}~ \t\n\n\u000b\f`;\nconst $69b3f00f8a7733d7$export$2ede34752a982e57 = (0, $fpZC2$chiabls.encodeBigInt)((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[\"q\"]);\nconst $69b3f00f8a7733d7$export$688e2fe60354a4fd = (0, $fpZC2$chiabls.encodeBigInt)((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[\"a\"]);\nconst $69b3f00f8a7733d7$export$15235ce324d8441e = (0, $fpZC2$chiabls.encodeBigInt)((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[\"f\"]);\nconst $69b3f00f8a7733d7$export$11418da7d6f16373 = (0, $fpZC2$chiabls.encodeBigInt)((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[\"r\"]);\nconst $69b3f00f8a7733d7$export$2542912e97e68f4e = (0, $fpZC2$chiabls.encodeBigInt)((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[\"c\"]);\nconst $69b3f00f8a7733d7$export$9d2b043fe7614ba5 = (0, $fpZC2$chiabls.encodeBigInt)((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[\"x\"]);\nclass $17c1ef024405b6ea$export$a4dd1bf5a8aa5573 extends Set {\n  isSuperset(set) {\n    for (const item of set) if (!this.has(item)) return false;\n    return true;\n  }\n  isSubset(set) {\n    for (const item of this) if (!set.has(item)) return false;\n    return true;\n  }\n  isSupersetProper(set) {\n    return this.isSuperset(set) && !this.isSubset(set);\n  }\n  isSubsetProper(set) {\n    return this.isSubset(set) && !this.isSuperset(set);\n  }\n  equals(set) {\n    return this.isSubset(set) && this.isSuperset(set);\n  }\n  union(set) {\n    const union = new $17c1ef024405b6ea$export$a4dd1bf5a8aa5573(this);\n    for (const item of set) union.add(item);\n    return union;\n  }\n  intersection(set) {\n    const intersection = new $17c1ef024405b6ea$export$a4dd1bf5a8aa5573();\n    for (const item of set) if (this.has(item)) intersection.add(item);\n    return intersection;\n  }\n  symmetricDifference(set) {\n    const difference = new $17c1ef024405b6ea$export$a4dd1bf5a8aa5573(this);\n    for (const item of set) if (difference.has(item)) difference.delete(item);else difference.add(item);\n    return difference;\n  }\n  difference(set) {\n    const difference = new $17c1ef024405b6ea$export$a4dd1bf5a8aa5573(this);\n    for (const item of set) difference.delete(item);\n    return difference;\n  }\n  update(set) {\n    for (const item of set) this.add(item);\n    return this;\n  }\n  differenceUpdate(set) {\n    for (const item of set) this.delete(item);\n    return this;\n  }\n  symmetricDifferenceUpdate(set) {\n    for (const item of set) if (this.has(item)) this.delete(item);else this.add(item);\n    return this;\n  }\n  intersectionUpdate(set) {\n    for (const item of this) if (!set.has(item)) this.delete(item);\n    return this;\n  }\n  sort(sorter) {\n    return new $17c1ef024405b6ea$export$a4dd1bf5a8aa5573([...this].sort(sorter));\n  }\n  map(mapper) {\n    const result = new $17c1ef024405b6ea$export$a4dd1bf5a8aa5573();\n    let index = 0;\n    for (const item of this) result.add(mapper(item, index++, this));\n    return result;\n  }\n  filter(predicate) {\n    const result = new $17c1ef024405b6ea$export$a4dd1bf5a8aa5573();\n    let index = 0;\n    for (const item of this) if (predicate(item, index++, this)) result.add(item);\n    return result;\n  }\n}\nfunction $3f2125465f2f6884$export$7ac16079f594c861(left, right) {\n  let mask = 1n;\n  let tempPath = left;\n  while (tempPath > 1n) {\n    right <<= 1n;\n    mask <<= 1n;\n    tempPath >>= 1n;\n  }\n  mask -= 1n;\n  return right | left & mask;\n}\nclass $3f2125465f2f6884$export$119c224dc5fdfaa6 {\n  static top = new $3f2125465f2f6884$export$119c224dc5fdfaa6();\n  static left = $3f2125465f2f6884$export$119c224dc5fdfaa6.top.first();\n  static right = $3f2125465f2f6884$export$119c224dc5fdfaa6.top.rest();\n  index;\n  constructor(index = 1n) {\n    if (index < 0n) {\n      const byteCount = (0, $fpZC2$chiabls.bigIntBitLength)(index) + 7 >> 3;\n      const blob = (0, $fpZC2$chiabls.bigIntToBytes)(index, byteCount, \"big\", true);\n      index = (0, $fpZC2$chiabls.bytesToBigInt)(Uint8Array.from([0, ...blob]), \"big\", false);\n    }\n    this.index = index;\n  }\n  asPath() {\n    const byteCount = (0, $fpZC2$chiabls.bigIntBitLength)(this.index) + 7 >> 3;\n    return (0, $fpZC2$chiabls.bigIntToBytes)(this.index, byteCount, \"big\");\n  }\n  add(other) {\n    return new $3f2125465f2f6884$export$119c224dc5fdfaa6($3f2125465f2f6884$export$7ac16079f594c861(this.index, other.index));\n  }\n  first() {\n    return new $3f2125465f2f6884$export$119c224dc5fdfaa6(this.index * 2n);\n  }\n  rest() {\n    return new $3f2125465f2f6884$export$119c224dc5fdfaa6(this.index * 2n + 1n);\n  }\n  toString() {\n    return `NodePath: ${this.index}`;\n  }\n}\nfunction $ec4be0719743fcdf$export$15d71aa2e69a0c29(program) {\n  return (0, $9636c8954d640602$export$b6c59b989905b650).cons((0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[\"q\"]), program);\n}\nfunction $ec4be0719743fcdf$export$57e68749c88bb462(program, args) {\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[\"a\"]), program, args]);\n}\nfunction $ec4be0719743fcdf$export$408b9eea5dcb5044(program, macroLookup) {\n  return $ec4be0719743fcdf$export$57e68749c88bb462((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"com\"), program, $ec4be0719743fcdf$export$15d71aa2e69a0c29(macroLookup)]), (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).top.asPath()));\n}\nfunction $ec4be0719743fcdf$export$9692bc1ad98955fc(program, args) {\n  return $ec4be0719743fcdf$export$57e68749c88bb462($ec4be0719743fcdf$export$15d71aa2e69a0c29(program), $ec4be0719743fcdf$export$15d71aa2e69a0c29(args));\n}\nconst $c1f25f83b21fbca5$var$defaultMacroSources = [`\n    ; we have to compile this externally, since it uses itself\n    ;(defmacro defmacro (name params body)\n    ;    (qq (list (unquote name) (mod (unquote params) (unquote body))))\n    ;)\n    (q . (\"defmacro\"\n       (c (q . \"list\")\n          (c (f 1)\n             (c (c (q . \"mod\")\n                   (c (f (r 1))\n                      (c (f (r (r 1)))\n                         (q . ()))))\n                (q . ()))))))\n    `, `\n    ;(defmacro list ARGS\n    ;    ((c (mod args\n    ;        (defun compile-list\n    ;               (args)\n    ;               (if args\n    ;                   (qq (c (unquote (f args))\n    ;                         (unquote (compile-list (r args)))))\n    ;                   ()))\n    ;            (compile-list args)\n    ;        )\n    ;        ARGS\n    ;    ))\n    ;)\n    (q \"list\"\n        (a (q #a (q #a 2 (c 2 (c 3 (q))))\n                 (c (q #a (i 5\n                             (q #c (q . 4)\n                                   (c 9 (c (a 2 (c 2 (c 13 (q))))\n                                           (q)))\n                             )\n                             (q 1))\n                           1)\n                    1))\n            1))\n    `, `(defmacro function (BODY)\n        (qq (opt (com (q . (unquote BODY))\n                 (qq (unquote (macros)))\n                 (qq (unquote (symbols)))))))`, `(defmacro if (A B C)\n        (qq (a\n            (i (unquote A)\n               (function (unquote B))\n               (function (unquote C)))\n            @)))`, `(defmacro / (A B) (qq (f (divmod (unquote A) (unquote B)))))`];\nlet $c1f25f83b21fbca5$var$defaultMacroLookupProgram;\nfunction $c1f25f83b21fbca5$var$buildDefaultMacroLookup(evalAsProgram) {\n  const run = (0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(a (com 2 3) 1)\");\n  for (const macroSource of $c1f25f83b21fbca5$var$defaultMacroSources) {\n    const macroProgram = (0, $9636c8954d640602$export$b6c59b989905b650).fromSource(macroSource);\n    const env = (0, $9636c8954d640602$export$b6c59b989905b650).cons(macroProgram, $c1f25f83b21fbca5$var$defaultMacroLookupProgram);\n    const newMacro = evalAsProgram(run, env).value;\n    $c1f25f83b21fbca5$var$defaultMacroLookupProgram = (0, $9636c8954d640602$export$b6c59b989905b650).cons(newMacro, $c1f25f83b21fbca5$var$defaultMacroLookupProgram);\n  }\n  return $c1f25f83b21fbca5$var$defaultMacroLookupProgram;\n}\nfunction $c1f25f83b21fbca5$export$35ac38cd538ce3a4(evalAsProgram) {\n  if (!$c1f25f83b21fbca5$var$defaultMacroLookupProgram || $c1f25f83b21fbca5$var$defaultMacroLookupProgram.isNull) {\n    $c1f25f83b21fbca5$var$defaultMacroLookupProgram = (0, $9636c8954d640602$export$b6c59b989905b650).fromList([]);\n    $c1f25f83b21fbca5$var$buildDefaultMacroLookup(evalAsProgram);\n  }\n  return $c1f25f83b21fbca5$var$defaultMacroLookupProgram;\n}\nfunction $b8dc7cb54aa9eaa3$export$633da1651c3bd3f9(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\nconst $b28f999d37dccebe$var$atomMatch = new TextEncoder().encode(\"$\");\nconst $b28f999d37dccebe$var$sexpMatch = new TextEncoder().encode(\":\");\nfunction $b28f999d37dccebe$export$c85aa06d1e6a7731(bindings, key, valueProgram) {\n  if (key in bindings) {\n    if (!bindings[key].equals(valueProgram)) return null;\n    return bindings;\n  }\n  return {\n    ...bindings,\n    [key]: valueProgram\n  };\n}\nfunction $b28f999d37dccebe$export$4659b591c19bdf3d(pattern, sexp, knownBindings = {}) {\n  if (!pattern.isCons) {\n    if (sexp.isCons) return null;\n    return (0, $fpZC2$chiabls.bytesEqual)(pattern.atom, sexp.atom) ? knownBindings : null;\n  }\n  const left = pattern.first;\n  const right = pattern.rest;\n  if (left.isAtom && (0, $fpZC2$chiabls.bytesEqual)(left.atom, $b28f999d37dccebe$var$atomMatch)) {\n    if (sexp.isCons) return null;\n    if (right.isAtom && (0, $fpZC2$chiabls.bytesEqual)(right.atom, $b28f999d37dccebe$var$atomMatch)) {\n      if ((0, $fpZC2$chiabls.bytesEqual)(sexp.atom, $b28f999d37dccebe$var$atomMatch)) return {};\n      return null;\n    }\n    return $b28f999d37dccebe$export$c85aa06d1e6a7731(knownBindings, right.toText(), sexp);\n  }\n  if (left.isAtom && (0, $fpZC2$chiabls.bytesEqual)(left.atom, $b28f999d37dccebe$var$sexpMatch)) {\n    if (right.isAtom && (0, $fpZC2$chiabls.bytesEqual)(right.atom, $b28f999d37dccebe$var$sexpMatch)) {\n      if ((0, $fpZC2$chiabls.bytesEqual)(sexp.atom, $b28f999d37dccebe$var$sexpMatch)) return {};\n      return null;\n    }\n    return $b28f999d37dccebe$export$c85aa06d1e6a7731(knownBindings, right.toText(), sexp);\n  }\n  if (!sexp.isCons) return null;\n  const newBindings = $b28f999d37dccebe$export$4659b591c19bdf3d(left, sexp.first, knownBindings);\n  if (!newBindings) return newBindings;\n  return $b28f999d37dccebe$export$4659b591c19bdf3d(right, sexp.rest, newBindings);\n}\nfunction $a985f73a592474fb$export$6eee28b7ff726723(program) {\n  if (!program.isCons) return program.isNull;\n  const operator = program.first;\n  if (!operator.isCons) {\n    const value = operator.atom;\n    if ((0, $fpZC2$chiabls.bytesEqual)(value, (0, $69b3f00f8a7733d7$export$2ede34752a982e57))) return true;else if ((0, $fpZC2$chiabls.bytesEqual)(value, (0, $69b3f00f8a7733d7$export$9d2b043fe7614ba5))) return false;\n  } else if (!$a985f73a592474fb$export$6eee28b7ff726723(operator)) return false;\n  return program.rest.toList().every(item => $a985f73a592474fb$export$6eee28b7ff726723(item));\n}\nfunction $a985f73a592474fb$export$4b7046275197ae1c(program, evalAsProgram) {\n  if ($a985f73a592474fb$export$6eee28b7ff726723(program) && !program.isNull) {\n    const newProgram = evalAsProgram(program, (0, $9636c8954d640602$export$b6c59b989905b650).nil).value;\n    program = (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(newProgram);\n  }\n  return program;\n}\nfunction $a985f73a592474fb$export$3ee5814c52647d49(program) {\n  return program.isAtom && program.toBigInt() === 1n;\n}\nfunction $a985f73a592474fb$export$6e8a6ed2471a063e(program, _evalAsProgram) {\n  const matched = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)((0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(a (q . (: . sexp)) (: . args))\"), program);\n  if (matched && $a985f73a592474fb$export$3ee5814c52647d49(matched[\"args\"])) return matched[\"sexp\"];\n  return program;\n}\nfunction $a985f73a592474fb$export$840131dd5ee64358(args) {\n  const matched = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)((0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(c (: . first) (: . rest))\"), args);\n  if (matched) return matched[\"first\"];\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[\"f\"]), args]);\n}\nfunction $a985f73a592474fb$export$a540b74c4a2a7577(args) {\n  const matched = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)((0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(c (: . first) (: . rest))\"), args);\n  if (matched) return matched[\"rest\"];\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[\"r\"]), args]);\n}\nfunction $a985f73a592474fb$export$c5d611a83338c57a(program, args) {\n  const value = program.toBigInt();\n  if (value <= 1n) return args;\n  program = (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(value >> 1n);\n  if (value & 1n) return $a985f73a592474fb$export$c5d611a83338c57a(program, $a985f73a592474fb$export$a540b74c4a2a7577(args));\n  return $a985f73a592474fb$export$c5d611a83338c57a(program, $a985f73a592474fb$export$840131dd5ee64358(args));\n}\nfunction $a985f73a592474fb$export$f44402eed32c89db(program, args) {\n  if (!program.isCons) return $a985f73a592474fb$export$c5d611a83338c57a(program, args);\n  let first = program.first;\n  if (first.isCons) first = $a985f73a592474fb$export$f44402eed32c89db(first, args);else if ((0, $fpZC2$chiabls.bytesEqual)(first.atom, (0, $69b3f00f8a7733d7$export$2ede34752a982e57))) return program;\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([first, ...program.rest.toList().map(item => $a985f73a592474fb$export$f44402eed32c89db(item, args))]);\n}\nfunction $a985f73a592474fb$export$47ba71260b7e33dc(program, evalAsProgram) {\n  const matched = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)((0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(a (q . (: . sexp)) (: . args))\"), program);\n  if (!matched) return program;\n  const originalArgs = matched[\"args\"];\n  const originalCall = matched[\"sexp\"];\n  const newEvalProgramArgs = $a985f73a592474fb$export$f44402eed32c89db(originalCall, originalArgs);\n  if ($a985f73a592474fb$export$6eee28b7ff726723(newEvalProgramArgs)) return $a985f73a592474fb$export$767e25f35e0954(newEvalProgramArgs, evalAsProgram);\n  const newOperands = newEvalProgramArgs.toList();\n  const optOperands = newOperands.map(item => $a985f73a592474fb$export$767e25f35e0954(item, evalAsProgram));\n  const nonConstantCount = optOperands.filter(item => item.isCons && (item.first.isCons || !(0, $fpZC2$chiabls.bytesEqual)(item.first.atom, (0, $69b3f00f8a7733d7$export$2ede34752a982e57)))).length;\n  if (nonConstantCount < 1) return (0, $9636c8954d640602$export$b6c59b989905b650).fromList(optOperands);\n  return program;\n}\nfunction $a985f73a592474fb$export$2da8b1cb5a5c1650(program, evalAsProgram) {\n  if (!program.isCons) return program;\n  const operator = program.first;\n  if (operator.isAtom && (0, $fpZC2$chiabls.bytesEqual)(operator.atom, (0, $69b3f00f8a7733d7$export$2ede34752a982e57))) return program;\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromList(program.toList().map(item => $a985f73a592474fb$export$767e25f35e0954(item, evalAsProgram)));\n}\nfunction $a985f73a592474fb$export$6f76a56e2909b861(program, _evalAsProgram) {\n  let matched = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)((0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(f (c (: . first) (: . rest)))\"), program);\n  if (matched) return matched[\"first\"];\n  matched = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)((0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(r (c (: . first) (: . rest)))\"), program);\n  if (matched) return matched[\"rest\"];\n  return program;\n}\nfunction $a985f73a592474fb$export$ea1c1c64007bc24b(program, _evalAsProgram) {\n  let matched = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)((0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(f ($ . atom))\"), program);\n  if (matched && !matched[\"atom\"].isNull) {\n    const node = new (0, $3f2125465f2f6884$export$119c224dc5fdfaa6)(matched[\"atom\"].toBigInt()).add((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).left);\n    return (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes(node.asPath());\n  }\n  matched = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)((0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(r ($ . atom))\"), program);\n  if (matched && !matched[\"atom\"].isNull) {\n    const node = new (0, $3f2125465f2f6884$export$119c224dc5fdfaa6)(matched[\"atom\"].toBigInt()).add((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).right);\n    return (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes(node.asPath());\n  }\n  return program;\n}\nfunction $a985f73a592474fb$export$32ec3f290cb70d5a(program, _evalAsProgram) {\n  const matched = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)((0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(q . 0)\"), program);\n  if (matched) return (0, $9636c8954d640602$export$b6c59b989905b650).nil;\n  return program;\n}\nfunction $a985f73a592474fb$export$b4f30947615ab0c1(program, _evalAsProgram) {\n  const matched = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)((0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(a 0 . (: . rest))\"), program);\n  if (matched) return (0, $9636c8954d640602$export$b6c59b989905b650).nil;\n  return program;\n}\nfunction $a985f73a592474fb$export$767e25f35e0954(program, evalAsProgram) {\n  if (program.isAtom) return program;\n  const optimizers = [$a985f73a592474fb$export$6f76a56e2909b861, $a985f73a592474fb$export$4b7046275197ae1c, $a985f73a592474fb$export$6e8a6ed2471a063e, $a985f73a592474fb$export$47ba71260b7e33dc, $a985f73a592474fb$export$2da8b1cb5a5c1650, $a985f73a592474fb$export$ea1c1c64007bc24b, $a985f73a592474fb$export$32ec3f290cb70d5a, $a985f73a592474fb$export$b4f30947615ab0c1];\n  while (program.isCons) {\n    const startProgram = program;\n    for (const optimizer of optimizers) {\n      program = optimizer(program, evalAsProgram);\n      if (!startProgram.equals(program)) break;\n    }\n    if (startProgram.equals(program)) return program;\n  }\n  return program;\n}\nfunction $a985f73a592474fb$export$f47d6a487cee0a73(runProgram) {\n  return args => {\n    return {\n      value: $a985f73a592474fb$export$767e25f35e0954(args.first, runProgram),\n      cost: 1n\n    };\n  };\n}\nconst $d81bf0ff4dbe2d6e$var$mainName = \"\";\nfunction $d81bf0ff4dbe2d6e$export$9896244d8c99a4d0(items) {\n  if (items.length === 0) return (0, $9636c8954d640602$export$b6c59b989905b650).nil;else if (items.length === 1) return items[0];\n  const halfSize = items.length >> 1;\n  return (0, $9636c8954d640602$export$b6c59b989905b650).cons($d81bf0ff4dbe2d6e$export$9896244d8c99a4d0(items.slice(0, halfSize)), $d81bf0ff4dbe2d6e$export$9896244d8c99a4d0(items.slice(halfSize)));\n}\nfunction $d81bf0ff4dbe2d6e$export$50a2a08029067c58(items) {\n  if (items.length === 0) return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)((0, $9636c8954d640602$export$b6c59b989905b650).nil)]);else if (items.length === 1) return items[0];\n  const halfSize = items.length >> 1;\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $69b3f00f8a7733d7$export$2542912e97e68f4e)), $d81bf0ff4dbe2d6e$export$50a2a08029067c58(items.slice(0, halfSize)), $d81bf0ff4dbe2d6e$export$50a2a08029067c58(items.slice(halfSize))]);\n}\nfunction $d81bf0ff4dbe2d6e$export$bffa455ba8c619a6(program) {\n  if (program.isCons) return [...$d81bf0ff4dbe2d6e$export$bffa455ba8c619a6(program.first), ...$d81bf0ff4dbe2d6e$export$bffa455ba8c619a6(program.rest)];else return [program.toText()];\n}\nfunction $d81bf0ff4dbe2d6e$export$fddefddb691e6258(functions, constants, macros) {\n  const macrosAsDict = {};\n  for (const item of macros) macrosAsDict[item.rest.first.toText()] = item;\n  const possibleSymbols = new (0, $17c1ef024405b6ea$export$a4dd1bf5a8aa5573)(Object.keys(functions));\n  possibleSymbols.update(new (0, $17c1ef024405b6ea$export$a4dd1bf5a8aa5573)(Object.keys(constants)));\n  let newNames = new (0, $17c1ef024405b6ea$export$a4dd1bf5a8aa5573)([$d81bf0ff4dbe2d6e$var$mainName]);\n  const usedNames = new (0, $17c1ef024405b6ea$export$a4dd1bf5a8aa5573)(newNames);\n  while (newNames.size) {\n    const priorNewNames = new (0, $17c1ef024405b6ea$export$a4dd1bf5a8aa5573)(newNames);\n    newNames = new (0, $17c1ef024405b6ea$export$a4dd1bf5a8aa5573)();\n    for (const item of priorNewNames) {\n      for (const group of [functions, macrosAsDict]) if (item in group) newNames.update(new (0, $17c1ef024405b6ea$export$a4dd1bf5a8aa5573)($d81bf0ff4dbe2d6e$export$bffa455ba8c619a6(group[item])));\n    }\n    newNames.differenceUpdate(usedNames);\n    usedNames.update(newNames);\n  }\n  usedNames.intersectionUpdate(possibleSymbols);\n  usedNames.delete($d81bf0ff4dbe2d6e$var$mainName);\n  return usedNames.sort((a, b) => (0, $b8dc7cb54aa9eaa3$export$633da1651c3bd3f9)(a, b));\n}\nfunction $d81bf0ff4dbe2d6e$export$8bf632d40c0a848b(name, namespace, functions, constants, macros, runProgram) {\n  const program = (0, $9636c8954d640602$export$b6c59b989905b650).fromSource(\"(_read (_full_path_for_name 1))\");\n  const output = runProgram(program, name).value;\n  for (const item of output.toList()) $d81bf0ff4dbe2d6e$export$7d6a67d8e26b1886(item, namespace, functions, constants, macros, runProgram);\n}\nfunction $d81bf0ff4dbe2d6e$export$66c2bd7a184bdde8(program, args) {\n  if (program.isCons) return (0, $9636c8954d640602$export$b6c59b989905b650).cons($d81bf0ff4dbe2d6e$export$66c2bd7a184bdde8(program.first, args), $d81bf0ff4dbe2d6e$export$66c2bd7a184bdde8(program.rest, args));else if (args.includes(program.toText())) return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"unquote\"), program]);\n  return program;\n}\nfunction $d81bf0ff4dbe2d6e$export$3d84838a88a77879(program) {\n  const second = program.rest;\n  const third = second.rest;\n  const items = [(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"defmacro\"), second.first, third.first];\n  const code = third.rest.first;\n  const args = $d81bf0ff4dbe2d6e$export$bffa455ba8c619a6(third.first).filter(item => item.length);\n  const unquotedCode = $d81bf0ff4dbe2d6e$export$66c2bd7a184bdde8(code, args);\n  items.push((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"qq\"), unquotedCode]));\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromList(items);\n}\nfunction $d81bf0ff4dbe2d6e$export$7d6a67d8e26b1886(declarationProgram, namespace, functions, constants, macros, runProgram) {\n  const op = declarationProgram.first.toText();\n  const nameProgram = declarationProgram.rest.first;\n  if (op === \"include\") {\n    $d81bf0ff4dbe2d6e$export$8bf632d40c0a848b(nameProgram, namespace, functions, constants, macros, runProgram);\n    return;\n  }\n  const name = nameProgram.toText();\n  if (namespace.has(name)) throw new Error(`Symbol ${JSON.stringify(name)} redefined.`);\n  namespace.add(name);\n  if (op === \"defmacro\") macros.push(declarationProgram);else if (op === \"defun\") functions[name] = declarationProgram.rest.rest;else if (op === \"defun-inline\") macros.push($d81bf0ff4dbe2d6e$export$3d84838a88a77879(declarationProgram));else if (op === \"defconstant\") constants[name] = (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(declarationProgram.rest.rest.first);else throw new Error(`Expected \"defun\", \"defun-inline\", \"defmacro\", or \"defconstant\", but got ${JSON.stringify(op)}.`);\n}\nfunction $d81bf0ff4dbe2d6e$export$9665f6d487c71a5a(args, runProgram) {\n  const functions = {};\n  const constants = {};\n  const macros = [];\n  const mainLocalArguments = args.first;\n  const namespace = new (0, $17c1ef024405b6ea$export$a4dd1bf5a8aa5573)();\n  while (true) {\n    args = args.rest;\n    if (args.rest.isNull) break;\n    $d81bf0ff4dbe2d6e$export$7d6a67d8e26b1886(args.first, namespace, functions, constants, macros, runProgram);\n  }\n  const uncompiledMain = args.first;\n  functions[$d81bf0ff4dbe2d6e$var$mainName] = (0, $9636c8954d640602$export$b6c59b989905b650).fromList([mainLocalArguments, uncompiledMain]);\n  return [functions, constants, macros];\n}\nfunction $d81bf0ff4dbe2d6e$export$bb136ef67aed6c8c(tree, rootNode) {\n  if (tree.isNull) return (0, $9636c8954d640602$export$b6c59b989905b650).nil;else if (!tree.isCons) return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromList([tree, (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes(rootNode.asPath())])]);\n  const left = $d81bf0ff4dbe2d6e$export$bb136ef67aed6c8c(tree.first, rootNode.add((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).left));\n  const right = $d81bf0ff4dbe2d6e$export$bb136ef67aed6c8c(tree.rest, rootNode.add((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).right));\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([...left.toList(), ...right.toList()]);\n}\nfunction $d81bf0ff4dbe2d6e$export$3b9592ef1cecfca1(macroLookup, macros, runProgram) {\n  let macroLookupProgram = (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(macroLookup);\n  for (const macro of macros) {\n    macroLookupProgram = (0, $ec4be0719743fcdf$export$57e68749c88bb462)((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"opt\"), (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"com\"), (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $69b3f00f8a7733d7$export$2542912e97e68f4e)), macro, macroLookupProgram])), macroLookupProgram])]), (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).top.asPath()));\n    macroLookupProgram = (0, $a985f73a592474fb$export$767e25f35e0954)(macroLookupProgram, runProgram);\n  }\n  return macroLookupProgram;\n}\nfunction $d81bf0ff4dbe2d6e$export$7eeeed3abcd324fe(functions, macroLookupProgram, constantSymbolTable, argsRootNode) {\n  const compiledFunctions = {};\n  for (const [name, lambdaExpression] of Object.entries(functions)) {\n    const localSymbolTable = $d81bf0ff4dbe2d6e$export$bb136ef67aed6c8c(lambdaExpression.first, argsRootNode);\n    const allSymbols = (0, $9636c8954d640602$export$b6c59b989905b650).fromList([...localSymbolTable.toList(), ...constantSymbolTable.toList()]);\n    compiledFunctions[name] = (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"opt\"), (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"com\"), (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(lambdaExpression.rest.first), macroLookupProgram, (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(allSymbols)])]);\n  }\n  return compiledFunctions;\n}\nfunction $d81bf0ff4dbe2d6e$export$19b97198b397b1c4(args, macroLookup, _symbolTable, runProgram) {\n  const [functions, constants, macros] = $d81bf0ff4dbe2d6e$export$9665f6d487c71a5a(args, runProgram);\n  const macroLookupProgram = $d81bf0ff4dbe2d6e$export$3b9592ef1cecfca1(macroLookup, macros, runProgram);\n  const allConstantNames = $d81bf0ff4dbe2d6e$export$fddefddb691e6258(functions, constants, macros);\n  const hasConstantTree = allConstantNames.size > 0;\n  const constantTree = $d81bf0ff4dbe2d6e$export$9896244d8c99a4d0([...allConstantNames.map(item => (0, $9636c8954d640602$export$b6c59b989905b650).fromText(item))]);\n  const constantRootNode = (0, $3f2125465f2f6884$export$119c224dc5fdfaa6).left;\n  const argsRootNode = hasConstantTree ? (0, $3f2125465f2f6884$export$119c224dc5fdfaa6).right : (0, $3f2125465f2f6884$export$119c224dc5fdfaa6).top;\n  const constantSymbolTable = $d81bf0ff4dbe2d6e$export$bb136ef67aed6c8c(constantTree, constantRootNode);\n  const compiledFunctions = $d81bf0ff4dbe2d6e$export$7eeeed3abcd324fe(functions, macroLookupProgram, constantSymbolTable, argsRootNode);\n  const mainPathSource = compiledFunctions[$d81bf0ff4dbe2d6e$var$mainName].toString();\n  let argTreeSource;\n  if (hasConstantTree) {\n    const allConstantsLookup = {};\n    for (const [key, value] of Object.entries(compiledFunctions)) if (allConstantNames.has(key)) allConstantsLookup[key] = value;\n    Object.assign(allConstantsLookup, constants);\n    const allConstantsList = [...allConstantNames].map(item => allConstantsLookup[item]);\n    const allConstantsTreeProgram = $d81bf0ff4dbe2d6e$export$50a2a08029067c58(allConstantsList);\n    const allConstantsTreeSource = allConstantsTreeProgram.toString();\n    argTreeSource = `(c ${allConstantsTreeSource} 1)`;\n  } else argTreeSource = \"1\";\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromSource(`(opt (q . (a ${mainPathSource} ${argTreeSource})))`);\n}\nconst $6edfc72fb8768007$var$passThroughOperators = new (0, $17c1ef024405b6ea$export$a4dd1bf5a8aa5573)([...Object.values((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)).map(value => (0, $fpZC2$chiabls.toHex)((0, $fpZC2$chiabls.encodeBigInt)(value))), (0, $fpZC2$chiabls.toHex)(new TextEncoder().encode(\"com\")), (0, $fpZC2$chiabls.toHex)(new TextEncoder().encode(\"opt\"))]);\nfunction $6edfc72fb8768007$export$4f014e0e2f9a3439(args, macroLookup, symbolTable, runProgram, level = 1) {\n  function com(program) {\n    return $6edfc72fb8768007$export$6469419774d99a46(program, macroLookup, symbolTable, runProgram);\n  }\n  const program = args.first;\n  if (!program.isCons) return (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(program);\n  if (!program.first.isCons) {\n    const op = program.first.toText();\n    if (op === \"qq\") {\n      const expression = $6edfc72fb8768007$export$4f014e0e2f9a3439(program.rest, macroLookup, symbolTable, runProgram, level + 1);\n      return com((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $69b3f00f8a7733d7$export$2542912e97e68f4e)), (0, $9636c8954d640602$export$b6c59b989905b650).fromText(op), (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $69b3f00f8a7733d7$export$2542912e97e68f4e)), expression, (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)((0, $9636c8954d640602$export$b6c59b989905b650).nil)])]));\n    } else if (op === \"unquote\") {\n      if (level === 1) return com(program.rest.first);\n      const expression = $6edfc72fb8768007$export$4f014e0e2f9a3439(program.rest, macroLookup, symbolTable, runProgram, level - 1);\n      return com((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $69b3f00f8a7733d7$export$2542912e97e68f4e)), (0, $9636c8954d640602$export$b6c59b989905b650).fromText(op), (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $69b3f00f8a7733d7$export$2542912e97e68f4e)), expression, (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)((0, $9636c8954d640602$export$b6c59b989905b650).nil)])]));\n    }\n  }\n  const first = com((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"qq\"), program.first]));\n  const rest = com((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"qq\"), program.rest]));\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $69b3f00f8a7733d7$export$2542912e97e68f4e)), first, rest]);\n}\nfunction $6edfc72fb8768007$export$10e4a0f3245dd758(_args, macroLookup, _symbolTable, _runProgram) {\n  return (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(macroLookup);\n}\nfunction $6edfc72fb8768007$export$11b536640056999f(_args, _macroLookup, symbolTable, _runProgram) {\n  return (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(symbolTable);\n}\nconst $6edfc72fb8768007$export$77f1bb37b4f1d5ec = {\n  qq: $6edfc72fb8768007$export$4f014e0e2f9a3439,\n  macros: $6edfc72fb8768007$export$10e4a0f3245dd758,\n  symbols: $6edfc72fb8768007$export$11b536640056999f,\n  lambda: (0, $d81bf0ff4dbe2d6e$export$19b97198b397b1c4),\n  mod: (0, $d81bf0ff4dbe2d6e$export$19b97198b397b1c4)\n};\nfunction $6edfc72fb8768007$export$1e276181c3bc016e(program, _macroLookup, _symbolTable, _runProgram) {\n  if (program.isAtom) return program;else if (program.first.isAtom && program.first.toText() === \"quote\") {\n    if (!program.rest.rest.isNull) throw new Error(`Compilation error while compiling ${program}. Quote takes exactly one argument${program.positionSuffix}.`);\n    return (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)($6edfc72fb8768007$export$1e276181c3bc016e(program.rest.first));\n  } else return (0, $9636c8954d640602$export$b6c59b989905b650).cons($6edfc72fb8768007$export$1e276181c3bc016e(program.first), $6edfc72fb8768007$export$1e276181c3bc016e(program.rest));\n}\nfunction $6edfc72fb8768007$export$6469419774d99a46(program, macroLookup, symbolTable, runProgram) {\n  program = $6edfc72fb8768007$export$1e276181c3bc016e(program, macroLookup, symbolTable, runProgram);\n  if (!program.isCons) {\n    const atom = program.toText();\n    if (atom === \"@\") return (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).top.asPath());\n    for (const pair of symbolTable.toList()) {\n      const symbol = pair.first;\n      const value = pair.rest.first;\n      if (symbol.isAtom && symbol.toText() === atom) return value;\n    }\n    return (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(program);\n  }\n  const operator = program.first;\n  if (operator.isCons) {\n    const inner = (0, $ec4be0719743fcdf$export$57e68749c88bb462)((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"com\"), (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(operator), (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(macroLookup), (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(symbolTable)]), (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).top.asPath()));\n    return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([inner]);\n  }\n  const atom = operator.toText();\n  for (const macroPair of macroLookup.toList()) if (macroPair.first.isAtom && macroPair.first.toText() === atom) {\n    const macroCode = macroPair.rest.first;\n    const postProgram = (0, $ec4be0719743fcdf$export$9692bc1ad98955fc)(macroCode, program.rest);\n    const result = (0, $ec4be0719743fcdf$export$57e68749c88bb462)((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"com\"), postProgram, (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(macroLookup), (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(symbolTable)]), (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).top.asPath()));\n    return result;\n  }\n  if (atom in $6edfc72fb8768007$export$77f1bb37b4f1d5ec) {\n    const compiler = $6edfc72fb8768007$export$77f1bb37b4f1d5ec[atom];\n    const postProgram = compiler(program.rest, macroLookup, symbolTable, runProgram);\n    return (0, $ec4be0719743fcdf$export$57e68749c88bb462)((0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(postProgram), (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).top.asPath()));\n  }\n  if ((0, $fpZC2$chiabls.bytesEqual)(operator.atom, (0, $69b3f00f8a7733d7$export$2ede34752a982e57))) return program;\n  const compiledArgs = program.rest.toList().map(item => $6edfc72fb8768007$export$6469419774d99a46(item, macroLookup, symbolTable, runProgram));\n  let result = (0, $9636c8954d640602$export$b6c59b989905b650).fromList([operator, ...compiledArgs]);\n  if ($6edfc72fb8768007$var$passThroughOperators.has((0, $fpZC2$chiabls.toHex)(new TextEncoder().encode(atom))) || atom.startsWith(\"_\")) return result;\n  for (const item of symbolTable.toList()) {\n    const [symbol, value] = item.toList();\n    if (!symbol.isAtom) continue;\n    const symbolText = symbol.toText();\n    if (symbolText === \"*\") return result;else if (symbolText === atom) {\n      const newArgs = (0, $ec4be0719743fcdf$export$57e68749c88bb462)((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"opt\"), (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"com\"), (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)((0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromText(\"list\"), ...program.rest.toList()])), (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(macroLookup), (0, $ec4be0719743fcdf$export$15d71aa2e69a0c29)(symbolTable)])]), (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).top.asPath()));\n      return (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $69b3f00f8a7733d7$export$688e2fe60354a4fd)), value, (0, $9636c8954d640602$export$b6c59b989905b650).fromList([(0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $69b3f00f8a7733d7$export$2542912e97e68f4e)), (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $3f2125465f2f6884$export$119c224dc5fdfaa6).left.asPath()), newArgs])]);\n    }\n  }\n  throw new Error(`Can't compile unknown operator ${program}${program.positionSuffix}.`);\n}\nfunction $6edfc72fb8768007$export$5af009c3dc40b1bc(runProgram) {\n  return sexp => {\n    const prog = sexp.first;\n    let symbolTable = (0, $9636c8954d640602$export$b6c59b989905b650).nil;\n    let macroLookup;\n    if (!sexp.rest.isNull) {\n      macroLookup = sexp.rest.first;\n      if (!sexp.rest.rest.isNull) symbolTable = sexp.rest.rest.first;\n    } else macroLookup = (0, $c1f25f83b21fbca5$export$35ac38cd538ce3a4)(runProgram);\n    return {\n      value: $6edfc72fb8768007$export$6469419774d99a46(prog, macroLookup, symbolTable, runProgram),\n      cost: 1n\n    };\n  };\n}\nconst $50d1f9204136c73a$export$5fe13095c61781e4 = {\n  if: 33n,\n  cons: 50n,\n  first: 30n,\n  rest: 30n,\n  listp: 19n,\n  mallocPerByte: 10n,\n  arithBase: 99n,\n  arithPerByte: 3n,\n  arithPerArg: 320n,\n  logBase: 100n,\n  logPerByte: 3n,\n  logPerArg: 264n,\n  grsBase: 117n,\n  grsPerByte: 1n,\n  eqBase: 117n,\n  eqPerByte: 1n,\n  grBase: 498n,\n  grPerByte: 2n,\n  divmodBase: 1116n,\n  divmodPerByte: 6n,\n  divBase: 988n,\n  divPerByte: 4n,\n  sha256Base: 87n,\n  sha256PerByte: 2n,\n  sha256PerArg: 134n,\n  pointAddBase: 101094n,\n  pointAddPerArg: 1343980n,\n  pubkeyBase: 1325730n,\n  pubkeyPerByte: 38n,\n  mulBase: 92n,\n  mulPerOp: 885n,\n  mulLinearPerByte: 6n,\n  mulSquarePerByteDivider: 128n,\n  strlenBase: 173n,\n  strlenPerByte: 1n,\n  pathLookupBase: 40n,\n  pathLookupPerLeg: 4n,\n  pathLookupPerZeroByte: 4n,\n  concatBase: 142n,\n  concatPerByte: 3n,\n  concatPerArg: 135n,\n  boolBase: 200n,\n  boolPerArg: 300n,\n  ashiftBase: 596n,\n  ashiftPerByte: 3n,\n  lshiftBase: 277n,\n  lshiftPerByte: 3n,\n  lognotBase: 331n,\n  lognotPerByte: 3n,\n  apply: 90n,\n  quote: 20n\n};\nfunction $b45cfe84191f72e9$export$2370125adba2cb1e(byte) {\n  byte |= byte >> 1;\n  byte |= byte >> 2;\n  byte |= byte >> 4;\n  return byte + 1 >> 1;\n}\nfunction $b45cfe84191f72e9$export$520469ab96a2a022(value, environment) {\n  let cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).pathLookupBase + (0, $50d1f9204136c73a$export$5fe13095c61781e4).pathLookupPerLeg;\n  if (value.isNull) return {\n    value: (0, $9636c8954d640602$export$b6c59b989905b650).nil,\n    cost: cost\n  };\n  let endByteCursor = 0;\n  const atom = value.atom;\n  while (endByteCursor < atom.length && atom[endByteCursor] === 0) endByteCursor++;\n  cost += BigInt(endByteCursor) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).pathLookupPerZeroByte;\n  if (endByteCursor === atom.length) return {\n    value: (0, $9636c8954d640602$export$b6c59b989905b650).nil,\n    cost: cost\n  };\n  const endBitMask = $b45cfe84191f72e9$export$2370125adba2cb1e(atom[endByteCursor]);\n  let byteCursor = atom.length - 1;\n  let bitMask = 0x01;\n  while (byteCursor > endByteCursor || bitMask < endBitMask) {\n    if (environment.isAtom) throw new Error(`Cannot traverse into ${environment}${environment.positionSuffix}.`);\n    if ((atom[byteCursor] & bitMask) !== 0) environment = environment.rest;else environment = environment.first;\n    cost += (0, $50d1f9204136c73a$export$5fe13095c61781e4).pathLookupPerLeg;\n    bitMask <<= 1;\n    if (bitMask === 0x100) {\n      byteCursor--;\n      bitMask = 0x01;\n    }\n  }\n  return {\n    value: environment,\n    cost: cost\n  };\n}\nconst $ee0ce775d2fb3caf$export$ccbce4efa7f8029b = {\n  i: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"i\", 3);\n    return {\n      value: list[0].isNull ? list[2] : list[1],\n      cost: (0, $50d1f9204136c73a$export$5fe13095c61781e4).if\n    };\n  },\n  c: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"c\", 2);\n    return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).cons(list[0], list[1]),\n      cost: (0, $50d1f9204136c73a$export$5fe13095c61781e4).cons\n    };\n  },\n  f: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"f\", 1, \"cons\");\n    return {\n      value: list[0].first,\n      cost: (0, $50d1f9204136c73a$export$5fe13095c61781e4).first\n    };\n  },\n  r: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"r\", 1, \"cons\");\n    return {\n      value: list[0].rest,\n      cost: (0, $50d1f9204136c73a$export$5fe13095c61781e4).rest\n    };\n  },\n  l: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"l\", 1);\n    return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBool(list[0].isCons),\n      cost: (0, $50d1f9204136c73a$export$5fe13095c61781e4).listp\n    };\n  },\n  x: args => {\n    throw new Error(`The error ${args} was raised${args.positionSuffix}.`);\n  },\n  \"=\": args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"=\", 2, \"atom\");\n    return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBool((0, $fpZC2$chiabls.bytesEqual)(list[0].atom, list[1].atom)),\n      cost: (0, $50d1f9204136c73a$export$5fe13095c61781e4).eqBase + (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).eqPerByte\n    };\n  },\n  sha256: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"sha256\", undefined, \"atom\");\n    let cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).sha256Base;\n    let argLength = 0;\n    const bytes = [];\n    for (const item of list) {\n      for (const byte of item.atom) bytes.push(byte);\n      argLength += item.atom.length;\n      cost += (0, $50d1f9204136c73a$export$5fe13095c61781e4).sha256PerArg;\n    }\n    cost += BigInt(argLength) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).sha256PerByte;\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes((0, $fpZC2$chiabls.hash256)(Uint8Array.from(bytes))),\n      cost: cost\n    });\n  },\n  \"+\": args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"+\", undefined, \"atom\");\n    let total = 0n;\n    let cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).arithBase;\n    let argSize = 0;\n    for (const item of list) {\n      total += item.toBigInt();\n      argSize += item.atom.length;\n      cost += (0, $50d1f9204136c73a$export$5fe13095c61781e4).arithPerArg;\n    }\n    cost += BigInt(argSize) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).arithPerByte;\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(total),\n      cost: cost\n    });\n  },\n  \"-\": args => {\n    let cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).arithBase;\n    if (args.isNull) return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).nil,\n      cost: cost\n    };\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"-\", undefined, \"atom\");\n    let total = 0n;\n    let sign = 1n;\n    let argSize = 0;\n    for (const item of list) {\n      total += sign * item.toBigInt();\n      sign = -1n;\n      argSize += item.atom.length;\n      cost += (0, $50d1f9204136c73a$export$5fe13095c61781e4).arithPerArg;\n    }\n    cost += BigInt(argSize) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).arithPerByte;\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(total),\n      cost: cost\n    });\n  },\n  \"*\": args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"*\", undefined, \"atom\");\n    let cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).mulBase;\n    if (!list.length) return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).true,\n      cost: cost\n    });\n    let value = list[0].toBigInt();\n    let size = list[0].atom.length;\n    for (const item of list.slice(1)) {\n      cost += (0, $50d1f9204136c73a$export$5fe13095c61781e4).mulPerOp + (BigInt(item.atom.length) + BigInt(size)) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).mulLinearPerByte + BigInt(item.atom.length) * BigInt(size) / (0, $50d1f9204136c73a$export$5fe13095c61781e4).mulSquarePerByteDivider;\n      value *= item.toBigInt();\n      size = $ee0ce775d2fb3caf$export$2f0301b329918c24(value);\n    }\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(value),\n      cost: cost\n    });\n  },\n  divmod: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"divmod\", 2, \"atom\");\n    let cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).divmodBase;\n    const numerator = list[0].toBigInt();\n    const denominator = list[1].toBigInt();\n    if (denominator === 0n) throw new Error(`Cannot divide by zero in \"divmod\" operator${args.positionSuffix}.`);\n    cost += (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).divmodPerByte;\n    let quotientValue = numerator / denominator;\n    const remainderValue = (0, $fpZC2$chiabls.mod)(numerator, denominator);\n    if (numerator < 0n !== denominator < 0n && remainderValue !== 0n) quotientValue -= 1n;\n    const quotient = (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(quotientValue);\n    const remainder = (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(remainderValue);\n    cost += (BigInt(quotient.atom.length) + BigInt(remainder.atom.length)) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).mallocPerByte;\n    return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).cons(quotient, remainder),\n      cost: cost\n    };\n  },\n  \"/\": args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"/\", 2, \"atom\");\n    let cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).divBase;\n    const numerator = list[0].toBigInt();\n    const denominator = list[1].toBigInt();\n    if (denominator === 0n) throw new Error(`Cannot divide by zero in \"/\" operator${args.positionSuffix}.`);\n    cost += (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).divPerByte;\n    let quotientValue = numerator / denominator;\n    const remainderValue = (0, $fpZC2$chiabls.mod)(numerator, denominator);\n    if (numerator < 0n !== denominator < 0n && quotientValue < 0n) quotientValue -= 1n;\n    const quotient = (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(quotientValue);\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: quotient,\n      cost: cost\n    });\n  },\n  \">\": args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \">\", 2, \"atom\");\n    const cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).grBase + (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).grPerByte;\n    return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBool(list[0].toBigInt() > list[1].toBigInt()),\n      cost: cost\n    };\n  },\n  \">s\": args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \">s\", 2, \"atom\");\n    const cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).grsBase + (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).grsPerByte;\n    return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBool(list[0].toHex().localeCompare(list[1].toHex()) === 1),\n      cost: cost\n    };\n  },\n  pubkey_for_exp: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"pubkey_for_exp\", 1, \"atom\");\n    const value = (0, $fpZC2$chiabls.mod)(list[0].toBigInt(), (0, $fpZC2$chiabls.defaultEc).n);\n    const exponent = (0, $fpZC2$chiabls.PrivateKey).fromBytes((0, $fpZC2$chiabls.bigIntToBytes)(value, 32, \"big\"));\n    const cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).pubkeyBase + BigInt(list[0].atom.length) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).pubkeyPerByte;\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes(exponent.getG1().toBytes()),\n      cost: cost\n    });\n  },\n  point_add: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"point_add\", undefined, \"atom\");\n    let cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).pointAddBase;\n    let point = (0, $fpZC2$chiabls.JacobianPoint).infinityG1();\n    for (const item of list) {\n      point = point.add((0, $fpZC2$chiabls.JacobianPoint).fromBytes(item.atom, false));\n      cost += (0, $50d1f9204136c73a$export$5fe13095c61781e4).pointAddPerArg;\n    }\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes(point.toBytes()),\n      cost: cost\n    });\n  },\n  strlen: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"strlen\", 1, \"atom\");\n    const size = list[0].atom.length;\n    const cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).strlenBase + BigInt(size) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).strlenPerByte;\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromInt(size),\n      cost: cost\n    });\n  },\n  substr: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"substr\", [2, 3], \"atom\");\n    const value = list[0].atom;\n    if (list[1].atom.length > 4 || list.length === 3 && list[2].atom.length > 4) throw new Error(`Expected 4 byte indices in \"substr\" operator${args.positionSuffix}.`);\n    const from = list[1].toInt();\n    const to = list.length === 3 ? list[2].toInt() : value.length;\n    if (to > value.length || to < from || to < 0 || from < 0) throw new Error(`Invalid indices in \"substr\" operator${args.positionSuffix}.`);\n    return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes(value.slice(from, to)),\n      cost: 1n\n    };\n  },\n  concat: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"concat\", undefined, \"atom\");\n    let cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).concatBase;\n    const bytes = [];\n    for (const item of list) {\n      for (const byte of item.atom) bytes.push(byte);\n      cost += (0, $50d1f9204136c73a$export$5fe13095c61781e4).concatPerArg;\n    }\n    cost += BigInt(bytes.length) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).concatPerByte;\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes(Uint8Array.from(bytes)),\n      cost: cost\n    });\n  },\n  ash: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"ash\", 2, \"atom\");\n    if (list[1].atom.length > 4) throw new Error(`Shift must be 32 bits in \"ash\" operator${args.positionSuffix}.`);\n    const shift = list[1].toBigInt();\n    if ((shift < 0n ? -shift : shift) > 65535n) throw new Error(`Shift too large in \"ash\" operator${args.positionSuffix}.`);\n    let value = list[0].toBigInt();\n    if (shift >= 0) value <<= shift;else value >>= -shift;\n    const cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).ashiftBase + (BigInt(list[0].atom.length) + BigInt($ee0ce775d2fb3caf$export$2f0301b329918c24(value))) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).ashiftPerByte;\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(value),\n      cost: cost\n    });\n  },\n  lsh: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"lsh\", 2, \"atom\");\n    if (list[1].atom.length > 4) throw new Error(`Shift must be 32 bits in \"lsh\" operator${args.positionSuffix}.`);\n    const shift = list[1].toBigInt();\n    if ((shift < 0n ? -shift : shift) > 65535n) throw new Error(`Shift too large in \"lsh\" operator${args.positionSuffix}.`);\n    let value = (0, $fpZC2$chiabls.bytesToBigInt)(list[0].atom, \"big\", false);\n    if (value < 0n) value = -value;\n    if (shift >= 0) value <<= shift;else value >>= -shift;\n    const cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).lshiftBase + (BigInt(list[0].atom.length) + BigInt($ee0ce775d2fb3caf$export$2f0301b329918c24(value))) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).lshiftPerByte;\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(value),\n      cost: cost\n    });\n  },\n  logand: args => $ee0ce775d2fb3caf$export$a0a039066bddd5e0(\"logand\", -1n, args, (a, b) => a & b),\n  logior: args => $ee0ce775d2fb3caf$export$a0a039066bddd5e0(\"logior\", 0n, args, (a, b) => a | b),\n  logxor: args => $ee0ce775d2fb3caf$export$a0a039066bddd5e0(\"logxor\", 0n, args, (a, b) => a ^ b),\n  lognot: args => {\n    const items = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"lognot\", 1, \"atom\");\n    const cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).lognotBase + BigInt(items[0].atom.length) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).lognotPerByte;\n    return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(~items[0].toBigInt()),\n      cost: cost\n    });\n  },\n  not: args => {\n    const items = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"not\", 1);\n    const cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).boolBase;\n    return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBool(items[0].isNull),\n      cost: cost\n    };\n  },\n  any: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"any\");\n    const cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).boolBase + BigInt(list.length) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).boolPerArg;\n    let result = false;\n    for (const item of list) if (!item.isNull) {\n      result = true;\n      break;\n    }\n    return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBool(result),\n      cost: cost\n    };\n  },\n  all: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"all\");\n    const cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).boolBase + BigInt(list.length) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).boolPerArg;\n    let result = true;\n    for (const item of list) if (item.isNull) {\n      result = false;\n      break;\n    }\n    return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBool(result),\n      cost: cost\n    };\n  },\n  softfork: args => {\n    const list = $ee0ce775d2fb3caf$export$effcdbd76139450(args, \"softfork\", [1, Infinity]);\n    if (!list[0].isAtom) throw new Error(`Expected atom argument in \"softfork\" operator at ${list[0].positionSuffix}.`);\n    const cost = list[0].toBigInt();\n    if (cost < 1n) throw new Error(`Cost must be greater than zero in \"softfork\" operator${args.positionSuffix}.`);\n    return {\n      value: (0, $9636c8954d640602$export$b6c59b989905b650).false,\n      cost: cost\n    };\n  }\n};\nconst $ee0ce775d2fb3caf$export$391b7405552d5e99 = {\n  operators: $ee0ce775d2fb3caf$export$ccbce4efa7f8029b,\n  unknown: $ee0ce775d2fb3caf$export$2d0c81c03591c44,\n  quote: \"q\",\n  apply: \"a\"\n};\nfunction $ee0ce775d2fb3caf$export$46a92a3441911620() {\n  return {\n    ...$ee0ce775d2fb3caf$export$391b7405552d5e99,\n    operators: {\n      ...$ee0ce775d2fb3caf$export$391b7405552d5e99.operators\n    }\n  };\n}\nfunction $ee0ce775d2fb3caf$export$effcdbd76139450(program, name, length, type) {\n  const list = program.toList();\n  if (typeof length === \"number\" && list.length !== length) throw new Error(`Expected ${length} arguments in ${JSON.stringify(name)} operator${program.positionSuffix}.`);else if (Array.isArray(length) && (list.length < length[0] || list.length > length[1])) throw new Error(`Expected ${length[1] === Infinity ? `at least ${length[0]}` : `between ${length[0]} and ${length[1]}`} arguments in ${JSON.stringify(name)} operator${program.positionSuffix}.`);\n  if (type !== undefined) list.forEach(item => {\n    if (type === \"atom\" && !item.isAtom || type === \"cons\" && !item.isCons) throw new Error(`Expected ${type} argument in ${JSON.stringify(name)} operator${item.positionSuffix}.`);\n  });\n  return list;\n}\nfunction $ee0ce775d2fb3caf$export$2f0301b329918c24(value) {\n  let length = value === 0n ? 0 : (value < 0n ? -value : value).toString(2).length;\n  if (value < 0n) length++;\n  return length + 7 >> 3;\n}\nfunction $ee0ce775d2fb3caf$export$c85cac6a8d81208f(output) {\n  return {\n    value: output.value,\n    cost: output.cost + BigInt(output.value.atom.length) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).mallocPerByte\n  };\n}\nfunction $ee0ce775d2fb3caf$export$a0a039066bddd5e0(opName, initialValue, args, opFunction) {\n  let total = initialValue;\n  let argSize = 0;\n  let cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).logBase;\n  for (const item of args.toList().map(item => {\n    if (!item.isAtom) throw new Error(`Expected atom argument in ${JSON.stringify(opName)} operator${item.positionSuffix}.`);\n    return item;\n  })) {\n    total = opFunction(total, item.toBigInt());\n    argSize += item.atom.length;\n    cost += (0, $50d1f9204136c73a$export$5fe13095c61781e4).logPerArg;\n  }\n  cost += BigInt(argSize) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).logPerByte;\n  return $ee0ce775d2fb3caf$export$c85cac6a8d81208f({\n    value: (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(total),\n    cost: cost\n  });\n}\nfunction $ee0ce775d2fb3caf$export$2d0c81c03591c44(op, args) {\n  if (!op.atom.length || (0, $fpZC2$chiabls.bytesEqual)(op.atom.slice(0, 2), Uint8Array.from([0xff, 0xff]))) throw new Error(`Reserved operator${op.positionSuffix}.`);\n  if (op.atom.length > 5) throw new Error(`Invalid operator${op.positionSuffix}.`);\n  const costFunction = (op.atom[op.atom.length - 1] & 0xc0) >> 6;\n  const costMultiplier = (0, $fpZC2$chiabls.bytesToInt)(op.atom.slice(0, op.atom.length - 1), \"big\") + 1;\n  let cost;\n  if (costFunction === 0) cost = 1n;else if (costFunction === 1) {\n    cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).arithBase;\n    let argSize = 0;\n    for (const item of args.toList()) {\n      if (!item.isAtom) throw new Error(`Expected atom argument${item.positionSuffix}.`);\n      argSize += item.atom.length;\n      cost += (0, $50d1f9204136c73a$export$5fe13095c61781e4).arithPerArg;\n    }\n    cost += BigInt(argSize) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).arithPerByte;\n  } else if (costFunction === 2) {\n    cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).mulBase;\n    const argList = args.toList();\n    if (argList.length) {\n      const first = argList[0];\n      if (!first.isAtom) throw new Error(`Expected atom argument${first.positionSuffix}.`);\n      let current = first.atom.length;\n      for (const item of argList.slice(1)) {\n        if (!item.isAtom) throw new Error(`Expected atom argument${item.positionSuffix}.`);\n        cost += (0, $50d1f9204136c73a$export$5fe13095c61781e4).mulPerOp + (BigInt(item.atom.length) + BigInt(current)) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).mulLinearPerByte + BigInt(item.atom.length) * BigInt(current) / (0, $50d1f9204136c73a$export$5fe13095c61781e4).mulSquarePerByteDivider;\n        current += item.atom.length;\n      }\n    }\n  } else if (costFunction === 3) {\n    cost = (0, $50d1f9204136c73a$export$5fe13095c61781e4).concatBase;\n    let length = 0;\n    for (const item of args.toList()) {\n      if (!item.isAtom) throw new Error(`Expected atom argument${item.positionSuffix}.`);\n      cost += (0, $50d1f9204136c73a$export$5fe13095c61781e4).concatPerArg;\n      length += item.atom.length;\n    }\n    cost += BigInt(length) * (0, $50d1f9204136c73a$export$5fe13095c61781e4).concatPerByte;\n  } else throw new Error(`Unknown cost function${op.positionSuffix}.`);\n  cost *= BigInt(costMultiplier);\n  if (cost >= 2n ** 32n) throw new Error(`Invalid operator${op.positionSuffix}.`);\n  return {\n    value: (0, $9636c8954d640602$export$b6c59b989905b650).nil,\n    cost: cost\n  };\n}\nfunction $ee0ce775d2fb3caf$export$664a4a7902029a5b(op, args, options) {\n  const symbol = op.toBigInt();\n  const keyword = Object.entries((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)).find(entry => entry[1] === symbol)?.[0] ?? op.toText();\n  if (keyword in options.operators.operators) {\n    const result = options.operators.operators[keyword](args);\n    return result;\n  } else return options.operators.unknown(op, args);\n}\nconst $bd56f675ad0fd6d4$export$21ba78b50397401d = {\n  swap: (_instructionStack, stack, _options) => {\n    const second = stack.pop();\n    const first = stack.pop();\n    stack.push(second, first);\n    return 0n;\n  },\n  cons: (_instructionStack, stack, _options) => {\n    const first = stack.pop();\n    const second = stack.pop();\n    stack.push((0, $9636c8954d640602$export$b6c59b989905b650).cons(first, second));\n    return 0n;\n  },\n  eval: (instructionStack, stack, _options) => {\n    const pair = stack.pop();\n    const program = pair.first;\n    const args = pair.rest;\n    if (program.isAtom) {\n      const output = (0, $b45cfe84191f72e9$export$520469ab96a2a022)(program, args);\n      stack.push(output.value);\n      return output.cost;\n    }\n    const op = program.first;\n    if (op.isCons) {\n      const [newOperator, mustBeNil] = op.cons;\n      if (newOperator.isCons || !mustBeNil.isNull) throw new Error(`Operators that are lists must contain a single atom${op.positionSuffix}.`);\n      const newOperandList = program.rest;\n      stack.push(newOperator, newOperandList);\n      instructionStack.push($bd56f675ad0fd6d4$export$21ba78b50397401d.apply);\n      return (0, $50d1f9204136c73a$export$5fe13095c61781e4).apply;\n    }\n    let operandList = program.rest;\n    if ((0, $fpZC2$chiabls.bytesEqual)(op.atom, (0, $69b3f00f8a7733d7$export$2ede34752a982e57))) {\n      stack.push(operandList);\n      return (0, $50d1f9204136c73a$export$5fe13095c61781e4).quote;\n    }\n    instructionStack.push($bd56f675ad0fd6d4$export$21ba78b50397401d.apply);\n    stack.push(op);\n    while (!operandList.isNull) {\n      stack.push((0, $9636c8954d640602$export$b6c59b989905b650).cons(operandList.first, args));\n      instructionStack.push($bd56f675ad0fd6d4$export$21ba78b50397401d.cons, $bd56f675ad0fd6d4$export$21ba78b50397401d.eval, $bd56f675ad0fd6d4$export$21ba78b50397401d.swap);\n      operandList = operandList.rest;\n    }\n    stack.push((0, $9636c8954d640602$export$b6c59b989905b650).nil);\n    return 1n;\n  },\n  apply: (instructionStack, stack, options) => {\n    const operandList = stack.pop();\n    const op = stack.pop();\n    if (op.isCons) throw new Error(`An internal error occurred${op.positionSuffix}.`);\n    if ((0, $fpZC2$chiabls.bytesEqual)(op.atom, (0, $69b3f00f8a7733d7$export$688e2fe60354a4fd))) {\n      const args = operandList.toList();\n      if (args.length !== 2) throw new Error(`Expected 2 arguments in \"a\" operator${operandList.positionSuffix}.`);\n      stack.push((0, $9636c8954d640602$export$b6c59b989905b650).cons(args[0], args[1]));\n      instructionStack.push($bd56f675ad0fd6d4$export$21ba78b50397401d.eval);\n      return (0, $50d1f9204136c73a$export$5fe13095c61781e4).apply;\n    }\n    const output = (0, $ee0ce775d2fb3caf$export$664a4a7902029a5b)(op, operandList, options);\n    stack.push(output.value);\n    return output.cost;\n  }\n};\nfunction $ecfc887e9c4d9ec4$export$efcd34ab6248d3cd(program) {\n  const sizeBytes = [];\n  if (program[0] <= 0x7f) return (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes(Uint8Array.from([program[0]]));else if (program[0] <= 0xbf) sizeBytes.push(program[0] & 0x3f);else if (program[0] <= 0xdf) {\n    sizeBytes.push(program[0] & 0x1f);\n    program.shift();\n    if (!program.length) throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(\"Expected next byte in source.\");\n    sizeBytes.push(program[0]);\n  } else if (program[0] <= 0xef) {\n    sizeBytes.push(program[0] & 0x0f);\n    for (let i = 0; i < 2; i++) {\n      program.shift();\n      if (!program.length) throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(\"Expected next byte in source.\");\n      sizeBytes.push(program[0]);\n    }\n  } else if (program[0] <= 0xf7) {\n    sizeBytes.push(program[0] & 0x07);\n    for (let i = 0; i < 3; i++) {\n      program.shift();\n      if (!program.length) throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(\"Expected next byte in source.\");\n      sizeBytes.push(program[0]);\n    }\n  } else if (program[0] <= 0xfb) {\n    sizeBytes.push(program[0] & 0x03);\n    for (let i = 0; i < 4; i++) {\n      program.shift();\n      if (!program.length) throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(\"Expected next byte in source.\");\n      sizeBytes.push(program[0]);\n    }\n  } else if (program[0] === 0xff) {\n    program.shift();\n    if (!program.length) throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(\"Expected next byte in source.\");\n    const first = $ecfc887e9c4d9ec4$export$efcd34ab6248d3cd(program);\n    program.shift();\n    if (!program.length) throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(\"Expected next byte in source.\");\n    const rest = $ecfc887e9c4d9ec4$export$efcd34ab6248d3cd(program);\n    return (0, $9636c8954d640602$export$b6c59b989905b650).cons(first, rest);\n  } else throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(\"Invalid encoding.\");\n  const size = (0, $fpZC2$chiabls.decodeInt)(Uint8Array.from(sizeBytes));\n  let bytes = [];\n  for (let i = 0; i < size; i++) {\n    program.shift();\n    if (!program.length) throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(\"Expected next byte in atom.\");\n    bytes.push(program[0]);\n  }\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes(Uint8Array.from(bytes));\n}\nclass $2795eb571c1ed5e7$export$13807d9ee5a34a42 {\n  line;\n  column;\n  constructor(source, index) {\n    source = source.replaceAll(\"\\r\\n\", \"\\n\");\n    let line = 1;\n    let column = 1;\n    for (let i = 0; i < index; i++) if (source[i] === \"\\n\") {\n      line++;\n      column = 1;\n    } else column++;\n    this.line = line;\n    this.column = column;\n  }\n  toString() {\n    return `${this.line}:${this.column}`;\n  }\n}\nfunction $bdb42fba8f5f461a$export$48cfd1e771a65c4f(tokens) {\n  tokens.shift();\n  return tokens[0];\n}\nfunction $bdb42fba8f5f461a$export$3570f33b1a1f3329(source, tokens) {\n  const token = tokens[0];\n  if (!$bdb42fba8f5f461a$export$48cfd1e771a65c4f(tokens)) throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(`Unexpected end of source at ${new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, token.index)}.`);\n}\nfunction $bdb42fba8f5f461a$export$1d5ccafae59b4926(char) {\n  return /^[\\u0020\\u202F\\u205F\\u2028\\u2029\\u3000\\u0085\\u1680\\u00A0\\u2000-\\u200A\\u0009-\\u000D\\u001C-\\u001F]$/.test(char);\n}\nfunction $bdb42fba8f5f461a$export$ab7f5d67832a6850(text, index) {\n  while (true) {\n    while (index < text.length && $bdb42fba8f5f461a$export$1d5ccafae59b4926(text[index])) index++;\n    if (index >= text.length || text[index] !== \";\") break;\n    while (index < text.length && !\"\\n\\r\".includes(text[index])) index++;\n  }\n  return index;\n}\nfunction $bdb42fba8f5f461a$export$92d34793dd37ac50(text, index) {\n  const start = index;\n  while (index < text.length && !$bdb42fba8f5f461a$export$1d5ccafae59b4926(text[index]) && text[index] !== \")\") index++;\n  return {\n    text: text.slice(start, index),\n    index: index\n  };\n}\nfunction $bdb42fba8f5f461a$export$4e9e188b3a3b0cbf(source, tokens) {\n  let token = tokens[0];\n  if (token.text === \")\") return (0, $9636c8954d640602$export$b6c59b989905b650).fromBytes(Uint8Array.from([])).at(new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, token.index));\n  const consStart = token.index;\n  const first = $bdb42fba8f5f461a$export$cd60724007a613c1(source, tokens);\n  $bdb42fba8f5f461a$export$3570f33b1a1f3329(source, tokens);\n  token = tokens[0];\n  let rest;\n  if (token.text === \".\") {\n    const dotStart = token.index;\n    $bdb42fba8f5f461a$export$3570f33b1a1f3329(source, tokens);\n    token = tokens[0];\n    rest = $bdb42fba8f5f461a$export$cd60724007a613c1(source, tokens);\n    $bdb42fba8f5f461a$export$3570f33b1a1f3329(source, tokens);\n    token = tokens[0];\n    if (token.text !== \")\") throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(`Illegal dot expression at ${new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, dotStart)}.`);\n  } else rest = $bdb42fba8f5f461a$export$4e9e188b3a3b0cbf(source, tokens);\n  return (0, $9636c8954d640602$export$b6c59b989905b650).cons(first, rest).at(new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, consStart));\n}\nfunction $bdb42fba8f5f461a$export$cbe5a625b098a663(source, token) {\n  return /^[+\\-]?[0-9]+(?:_[0-9]+)*$/.test(token.text) ? (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(BigInt(token.text.replaceAll(\"_\", \"\"))).at(new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, token.index)) : null;\n}\nfunction $bdb42fba8f5f461a$export$c553c4a3641f57a2(source, token) {\n  if (token.text.length >= 2 && token.text.slice(0, 2).toLowerCase() === \"0x\") {\n    let hex = token.text.slice(2);\n    if (hex.length % 2 === 1) hex = `0${hex}`;\n    try {\n      return (0, $9636c8954d640602$export$b6c59b989905b650).fromHex(hex).at(new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, token.index));\n    } catch (e) {\n      throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(`Invalid hex ${JSON.stringify(token.text)} at ${new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, token.index)}.`);\n    }\n  } else return null;\n}\nfunction $bdb42fba8f5f461a$export$efc939cd3ec83299(source, token) {\n  if (token.text.length < 2) return null;\n  const quote = token.text[0];\n  if (!\"\\\"'\".includes(quote)) return null;\n  if (token.text[token.text.length - 1] !== quote) throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(`Unterminated string ${JSON.stringify(token.text)} at ${new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, token.index)}.`);\n  return (0, $9636c8954d640602$export$b6c59b989905b650).fromText(token.text.slice(1, token.text.length - 1)).at(new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, token.index));\n}\nfunction $bdb42fba8f5f461a$export$52faefa73a5cb81b(source, token) {\n  let text = token.text;\n  if (text.startsWith(\"#\")) text = text.slice(1);\n  const keyword = (0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[text];\n  return (keyword === undefined ? (0, $9636c8954d640602$export$b6c59b989905b650).fromText(text) : (0, $9636c8954d640602$export$b6c59b989905b650).fromBigInt(keyword)).at(new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, token.index));\n}\nfunction $bdb42fba8f5f461a$export$cd60724007a613c1(source, tokens) {\n  const token = tokens[0];\n  if (token.text === \"(\") {\n    $bdb42fba8f5f461a$export$3570f33b1a1f3329(source, tokens);\n    return $bdb42fba8f5f461a$export$4e9e188b3a3b0cbf(source, tokens);\n  }\n  const result = $bdb42fba8f5f461a$export$cbe5a625b098a663(source, token) ?? $bdb42fba8f5f461a$export$c553c4a3641f57a2(source, token) ?? $bdb42fba8f5f461a$export$efc939cd3ec83299(source, token) ?? $bdb42fba8f5f461a$export$52faefa73a5cb81b(source, token);\n  if (!result) throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(`Invalid expression ${JSON.stringify(token.text)} at ${new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, token.index)}.`);\n  return result;\n}\nfunction* $bdb42fba8f5f461a$export$f3f15647e54e234d(source) {\n  let index = 0;\n  while (index < source.length) {\n    index = $bdb42fba8f5f461a$export$ab7f5d67832a6850(source, index);\n    if (index >= source.length) break;\n    const char = source[index];\n    if (\"(.)\".includes(char)) {\n      yield {\n        text: char,\n        index: index\n      };\n      index++;\n      continue;\n    }\n    if (\"\\\"'\".includes(char)) {\n      const start = index;\n      const quote = source[index];\n      index++;\n      while (index < source.length && source[index] !== quote) index++;\n      if (index < source.length) {\n        yield {\n          text: source.slice(start, index + 1),\n          index: start\n        };\n        index++;\n        continue;\n      } else throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(`Unterminated string at ${new (0, $2795eb571c1ed5e7$export$13807d9ee5a34a42)(source, index)}.`);\n    }\n    const token = $bdb42fba8f5f461a$export$92d34793dd37ac50(source, index);\n    yield {\n      text: token.text,\n      index: index\n    };\n    index = token.index;\n  }\n}\nclass $9636c8954d640602$export$b6c59b989905b650 {\n  static cost = 11000000000;\n  static true = $9636c8954d640602$export$b6c59b989905b650.fromBytes(Uint8Array.from([1]));\n  static false = $9636c8954d640602$export$b6c59b989905b650.fromBytes(Uint8Array.from([]));\n  static nil = $9636c8954d640602$export$b6c59b989905b650.false;\n  value;\n  position;\n  get atom() {\n    if (!this.isAtom) throw new Error(`Expected atom${this.positionSuffix}.`);\n    return this.value;\n  }\n  get cons() {\n    if (!this.isCons) throw new Error(`Expected cons${this.positionSuffix}.`);\n    return this.value;\n  }\n  get first() {\n    return this.cons[0];\n  }\n  get rest() {\n    return this.cons[1];\n  }\n  get isAtom() {\n    return this.value instanceof Uint8Array;\n  }\n  get isCons() {\n    return Array.isArray(this.value);\n  }\n  get isNull() {\n    return this.isAtom && this.value.length === 0;\n  }\n  static cons(first, rest) {\n    return new $9636c8954d640602$export$b6c59b989905b650([first, rest]);\n  }\n  static fromBytes(bytes) {\n    return new $9636c8954d640602$export$b6c59b989905b650(bytes);\n  }\n  static fromJacobianPoint(jacobianPoint) {\n    return new $9636c8954d640602$export$b6c59b989905b650(jacobianPoint.toBytes());\n  }\n  static fromPrivateKey(privateKey) {\n    return new $9636c8954d640602$export$b6c59b989905b650(privateKey.toBytes());\n  }\n  static fromHex(hex) {\n    return new $9636c8954d640602$export$b6c59b989905b650((0, $fpZC2$chiabls.fromHex)(hex));\n  }\n  static fromBool(value) {\n    return value ? $9636c8954d640602$export$b6c59b989905b650.true : $9636c8954d640602$export$b6c59b989905b650.false;\n  }\n  static fromInt(value) {\n    return new $9636c8954d640602$export$b6c59b989905b650((0, $fpZC2$chiabls.encodeInt)(value));\n  }\n  static fromBigInt(value) {\n    return new $9636c8954d640602$export$b6c59b989905b650((0, $fpZC2$chiabls.encodeBigInt)(value));\n  }\n  static fromText(text) {\n    return new $9636c8954d640602$export$b6c59b989905b650(new TextEncoder().encode(text));\n  }\n  static fromSource(source) {\n    const stream = (0, $bdb42fba8f5f461a$export$f3f15647e54e234d)(source);\n    const tokens = [...stream];\n    if (tokens.length) return (0, $bdb42fba8f5f461a$export$cd60724007a613c1)(source, tokens);else throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(\"Unexpected end of source.\");\n  }\n  static fromList(programs) {\n    let result = $9636c8954d640602$export$b6c59b989905b650.nil;\n    for (const program of programs.reverse()) result = $9636c8954d640602$export$b6c59b989905b650.cons(program, result);\n    return result;\n  }\n  static deserialize(bytes) {\n    const program = [...bytes];\n    if (!program.length) throw new (0, $a550084cece3e4e0$export$d125cf0331bff9a9)(\"Unexpected end of source.\");\n    return (0, $ecfc887e9c4d9ec4$export$efcd34ab6248d3cd)(program);\n  }\n  static deserializeHex(hex) {\n    return $9636c8954d640602$export$b6c59b989905b650.deserialize((0, $fpZC2$chiabls.fromHex)(hex));\n  }\n  constructor(value) {\n    this.value = value;\n  }\n  get positionSuffix() {\n    return this.position ? ` at ${this.position}` : \"\";\n  }\n  at(position) {\n    this.position = position;\n    return this;\n  }\n  curry(args) {\n    return $9636c8954d640602$export$b6c59b989905b650.fromSource(\"(a (q #a 4 (c 2 (c 5 (c 7 0)))) (c (q (c (q . 2) (c (c (q . 1) 5) (c (a 6 (c 2 (c 11 (q 1)))) 0))) #a (i 5 (q 4 (q . 4) (c (c (q . 1) 9) (c (a 6 (c 2 (c 13 (c 11 0)))) 0))) (q . 11)) 1) 1))\").run($9636c8954d640602$export$b6c59b989905b650.cons(this, $9636c8954d640602$export$b6c59b989905b650.fromList(args))).value;\n  }\n  uncurry() {\n    const uncurryPatternFunction = $9636c8954d640602$export$b6c59b989905b650.fromSource(\"(a (q . (: . function)) (: . core))\");\n    const uncurryPatternCore = $9636c8954d640602$export$b6c59b989905b650.fromSource(\"(c (q . (: . parm)) (: . core))\");\n    let result = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)(uncurryPatternFunction, this);\n    if (!result) return null;\n    const fn = result.function;\n    let core = result.core;\n    const args = [];\n    while (true) {\n      result = (0, $b28f999d37dccebe$export$4659b591c19bdf3d)(uncurryPatternCore, core);\n      if (!result) break;\n      args.push(result.parm);\n      core = result.core;\n    }\n    if (core.isAtom && core.toBigInt() === 1n) return [fn, args];\n    return null;\n  }\n  hash() {\n    return this.isAtom ? (0, $fpZC2$chiabls.hash256)((0, $fpZC2$chiabls.concatBytes)(Uint8Array.from([1]), this.atom)) : (0, $fpZC2$chiabls.hash256)((0, $fpZC2$chiabls.concatBytes)(Uint8Array.from([2]), this.first.hash(), this.rest.hash()));\n  }\n  hashHex() {\n    return (0, $fpZC2$chiabls.toHex)(this.hash());\n  }\n  define(program) {\n    let result = this;\n    if (this.isAtom || this.first.isCons || this.first.toText() !== \"mod\") result = $9636c8954d640602$export$b6c59b989905b650.fromList([$9636c8954d640602$export$b6c59b989905b650.fromText(\"mod\"), $9636c8954d640602$export$b6c59b989905b650.nil, this]);\n    const items = result.toList();\n    items.splice(2, 0, program);\n    return $9636c8954d640602$export$b6c59b989905b650.fromList(items);\n  }\n  defineAll(programs) {\n    let result = this;\n    for (const program of programs.reverse()) result = result.define(program);\n    return result;\n  }\n  compile(options = {}) {\n    const fullOptions = {\n      strict: false,\n      operators: (0, $ee0ce775d2fb3caf$export$46a92a3441911620)(),\n      includeFilePaths: {},\n      ...options\n    };\n    if (fullOptions.strict) fullOptions.operators.unknown = (_operator, args) => {\n      throw new Error(`Unimplemented operator${args.positionSuffix}.`);\n    };\n    function doFullPathForName(args) {\n      const fileName = args.first.toText();\n      for (const [path, files] of Object.entries(fullOptions.includeFilePaths)) {\n        if (fileName in files) return {\n          value: $9636c8954d640602$export$b6c59b989905b650.fromText(`${path}/${fileName}`),\n          cost: 1n\n        };\n      }\n      throw new Error(`Can't open ${fileName}${args.positionSuffix}.`);\n    }\n    function doRead(args) {\n      const fileName = args.first.toText();\n      let source = null;\n      for (const [path, files] of Object.entries(fullOptions.includeFilePaths)) {\n        for (const [file, content] of Object.entries(files)) if (fileName === `${path}/${file}`) source = content;\n      }\n      if (source === null) throw new Error(`Can't open ${fileName}${args.positionSuffix}.`);\n      return {\n        value: $9636c8954d640602$export$b6c59b989905b650.fromSource(source),\n        cost: 1n\n      };\n    }\n    // Not functional, due to browser support. May reimplement later.\n    function doWrite(_args) {\n      return {\n        value: $9636c8954d640602$export$b6c59b989905b650.nil,\n        cost: 1n\n      };\n    }\n    function runProgram(program, args) {\n      return program.run(args, fullOptions);\n    }\n    const bindings = {\n      com: (0, $6edfc72fb8768007$export$5af009c3dc40b1bc)(runProgram),\n      opt: (0, $a985f73a592474fb$export$f47d6a487cee0a73)(runProgram),\n      _full_path_for_name: doFullPathForName,\n      _read: doRead,\n      _write: doWrite\n    };\n    Object.assign(fullOptions.operators.operators, bindings);\n    return runProgram($9636c8954d640602$export$b6c59b989905b650.fromSource(\"(a (opt (com 2)) 3)\"), $9636c8954d640602$export$b6c59b989905b650.fromList([this]));\n  }\n  run(environment, options = {}) {\n    const fullOptions = {\n      strict: false,\n      operators: (0, $ee0ce775d2fb3caf$export$46a92a3441911620)(),\n      ...options\n    };\n    if (fullOptions.strict) fullOptions.operators.unknown = (_operator, args) => {\n      throw new Error(`Unimplemented operator${args.positionSuffix}.`);\n    };\n    const instructionStack = [(0, $bd56f675ad0fd6d4$export$21ba78b50397401d).eval];\n    const stack = [$9636c8954d640602$export$b6c59b989905b650.cons(this, environment)];\n    let cost = 0n;\n    while (instructionStack.length) {\n      const instruction = instructionStack.pop();\n      cost += instruction(instructionStack, stack, fullOptions);\n      if (fullOptions.maxCost !== undefined && cost > fullOptions.maxCost) throw new Error(`Exceeded cost of ${fullOptions.maxCost}${stack[stack.length - 1].positionSuffix}.`);\n    }\n    return {\n      value: stack[stack.length - 1],\n      cost: cost\n    };\n  }\n  toBytes() {\n    if (this.isCons) throw new Error(`Cannot convert ${this.toString()} to hex${this.positionSuffix}.`);\n    return this.atom;\n  }\n  toJacobianPoint() {\n    if (this.isCons || this.atom.length !== 48 && this.atom.length !== 96) throw new Error(`Cannot convert ${this.toString()} to JacobianPoint${this.positionSuffix}.`);\n    return this.atom.length === 48 ? (0, $fpZC2$chiabls.JacobianPoint).fromBytesG1(this.atom) : (0, $fpZC2$chiabls.JacobianPoint).fromBytesG2(this.atom);\n  }\n  toPrivateKey() {\n    if (this.isCons) throw new Error(`Cannot convert ${this.toString()} to private key${this.positionSuffix}.`);\n    return (0, $fpZC2$chiabls.PrivateKey).fromBytes(this.atom);\n  }\n  toHex() {\n    if (this.isCons) throw new Error(`Cannot convert ${this.toString()} to hex${this.positionSuffix}.`);\n    return (0, $fpZC2$chiabls.toHex)(this.atom);\n  }\n  toBool() {\n    if (this.isCons) throw new Error(`Cannot convert ${this.toString()} to bool${this.positionSuffix}.`);\n    return !this.isNull;\n  }\n  toInt() {\n    if (this.isCons) throw new Error(`Cannot convert ${this.toString()} to int${this.positionSuffix}.`);\n    return (0, $fpZC2$chiabls.decodeInt)(this.atom);\n  }\n  toBigInt() {\n    if (this.isCons) throw new Error(`Cannot convert ${this.toString()} to bigint${this.positionSuffix}.`);\n    return (0, $fpZC2$chiabls.decodeBigInt)(this.atom);\n  }\n  toText() {\n    if (this.isCons) throw new Error(`Cannot convert ${this.toString()} to text${this.positionSuffix}.`);\n    return new TextDecoder().decode(this.atom);\n  }\n  toSource(showKeywords = true) {\n    if (this.isAtom) {\n      if (this.isNull) return \"()\";else if (this.value.length > 2) try {\n        const string = this.toText();\n        for (let i = 0; i < string.length; i++) {\n          if (!(0, $1382d0708deed0de$export$b81a09a7187d4786).includes(string[i])) return `0x${this.toHex()}`;\n        }\n        if (string.includes('\"') && string.includes(\"'\")) return `0x${this.toHex()}`;\n        const quote = string.includes('\"') ? \"'\" : '\"';\n        return quote + string + quote;\n      } catch {\n        return `0x${this.toHex()}`;\n      } else if ((0, $fpZC2$chiabls.bytesEqual)((0, $fpZC2$chiabls.encodeInt)((0, $fpZC2$chiabls.decodeInt)(this.atom)), this.atom)) return (0, $fpZC2$chiabls.decodeInt)(this.atom).toString();else return `0x${this.toHex()}`;\n    } else {\n      let result = \"(\";\n      if (showKeywords && this.first.isAtom) {\n        const value = this.first.toBigInt();\n        const keyword = Object.keys((0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)).find(keyword => (0, $94ca46fd7d128ba2$export$eebaaf2b24d91f63)[keyword] === value);\n        result += keyword ? keyword : this.first.toSource(showKeywords);\n      } else result += this.first.toSource(showKeywords);\n      let current = this.cons[1];\n      while (current.isCons) {\n        result += ` ${current.first.toSource(showKeywords)}`;\n        current = current.cons[1];\n      }\n      result += (current.isNull ? \"\" : ` . ${current.toSource(showKeywords)}`) + \")\";\n      return result;\n    }\n  }\n  toList(strict = false) {\n    const result = [];\n    let current = this;\n    while (current.isCons) {\n      const item = current.first;\n      result.push(item);\n      current = current.rest;\n    }\n    if (!current.isNull && strict) throw new Error(`Expected strict list${this.positionSuffix}.`);\n    return result;\n  }\n  serialize() {\n    if (this.isAtom) {\n      if (this.isNull) return Uint8Array.from([0x80]);else if (this.atom.length === 1 && this.atom[0] <= 0x7f) return this.atom;else {\n        const size = this.atom.length;\n        const result = [];\n        if (size < 0x40) result.push(0x80 | size);else if (size < 0x2000) {\n          result.push(0xc0 | size >> 8);\n          result.push(size >> 0 & 0xff);\n        } else if (size < 0x100000) {\n          result.push(0xe0 | size >> 16);\n          result.push(size >> 8 & 0xff);\n          result.push(size >> 0 & 0xff);\n        } else if (size < 0x8000000) {\n          result.push(0xf0 | size >> 24);\n          result.push(size >> 16 & 0xff);\n          result.push(size >> 8 & 0xff);\n          result.push(size >> 0 & 0xff);\n        } else if (size < 0x400000000) {\n          result.push(0xf8 | size >> 32);\n          result.push(size >> 24 & 0xff);\n          result.push(size >> 16 & 0xff);\n          result.push(size >> 8 & 0xff);\n          result.push(size >> 0 & 0xff);\n        } else throw new RangeError(`Cannot serialize ${this.toString()} as it is 17,179,869,184 or more bytes in size${this.positionSuffix}.`);\n        for (const byte of this.atom) result.push(byte);\n        return Uint8Array.from(result);\n      }\n    } else {\n      const result = [0xff];\n      for (const byte of this.first.serialize()) result.push(byte);\n      for (const byte of this.rest.serialize()) result.push(byte);\n      return Uint8Array.from(result);\n    }\n  }\n  serializeHex() {\n    return (0, $fpZC2$chiabls.toHex)(this.serialize());\n  }\n  equals(value) {\n    return this.isAtom === value.isAtom && (this.isAtom ? (0, $fpZC2$chiabls.bytesEqual)(this.atom, value.atom) : this.first.equals(value.first) && this.rest.equals(value.rest));\n  }\n  toString() {\n    return this.toSource();\n  }\n}\n$parcel$exportWildcard(module.exports, $a550084cece3e4e0$exports);","map":{"version":3,"names":["$a550084cece3e4e0$export$d125cf0331bff9a9","Error","constructor","message","Object","setPrototypeOf","prototype","$94ca46fd7d128ba2$export$eebaaf2b24d91f63","q","a","i","c","f","r","l","x","sha256","substr","strlen","concat","divmod","ash","lsh","logand","logior","logxor","lognot","point_add","pubkey_for_exp","not","any","all","softfork","$1382d0708deed0de$export$b81a09a7187d4786","$69b3f00f8a7733d7$export$2ede34752a982e57","$fpZC2$chiabls","encodeBigInt","$69b3f00f8a7733d7$export$688e2fe60354a4fd","$69b3f00f8a7733d7$export$15235ce324d8441e","$69b3f00f8a7733d7$export$11418da7d6f16373","$69b3f00f8a7733d7$export$2542912e97e68f4e","$69b3f00f8a7733d7$export$9d2b043fe7614ba5","$17c1ef024405b6ea$export$a4dd1bf5a8aa5573","Set","isSuperset","set","item","has","isSubset","isSupersetProper","isSubsetProper","equals","union","add","intersection","symmetricDifference","difference","delete","update","differenceUpdate","symmetricDifferenceUpdate","intersectionUpdate","sort","sorter","map","mapper","result","index","filter","predicate","$3f2125465f2f6884$export$7ac16079f594c861","left","right","mask","tempPath","$3f2125465f2f6884$export$119c224dc5fdfaa6","top","first","rest","byteCount","bigIntBitLength","blob","bigIntToBytes","bytesToBigInt","Uint8Array","from","asPath","other","toString","$ec4be0719743fcdf$export$15d71aa2e69a0c29","program","$9636c8954d640602$export$b6c59b989905b650","cons","fromBigInt","$ec4be0719743fcdf$export$57e68749c88bb462","args","fromList","$ec4be0719743fcdf$export$408b9eea5dcb5044","macroLookup","fromText","fromBytes","$ec4be0719743fcdf$export$9692bc1ad98955fc","$c1f25f83b21fbca5$var$defaultMacroSources","$c1f25f83b21fbca5$var$defaultMacroLookupProgram","$c1f25f83b21fbca5$var$buildDefaultMacroLookup","evalAsProgram","run","fromSource","macroSource","macroProgram","env","newMacro","value","$c1f25f83b21fbca5$export$35ac38cd538ce3a4","isNull","$b8dc7cb54aa9eaa3$export$633da1651c3bd3f9","b","$b28f999d37dccebe$var$atomMatch","TextEncoder","encode","$b28f999d37dccebe$var$sexpMatch","$b28f999d37dccebe$export$c85aa06d1e6a7731","bindings","key","valueProgram","$b28f999d37dccebe$export$4659b591c19bdf3d","pattern","sexp","knownBindings","isCons","bytesEqual","atom","isAtom","toText","newBindings","$a985f73a592474fb$export$6eee28b7ff726723","operator","toList","every","$a985f73a592474fb$export$4b7046275197ae1c","newProgram","nil","$a985f73a592474fb$export$3ee5814c52647d49","toBigInt","$a985f73a592474fb$export$6e8a6ed2471a063e","_evalAsProgram","matched","$a985f73a592474fb$export$840131dd5ee64358","$a985f73a592474fb$export$a540b74c4a2a7577","$a985f73a592474fb$export$c5d611a83338c57a","$a985f73a592474fb$export$f44402eed32c89db","$a985f73a592474fb$export$47ba71260b7e33dc","originalArgs","originalCall","newEvalProgramArgs","$a985f73a592474fb$export$767e25f35e0954","newOperands","optOperands","nonConstantCount","length","$a985f73a592474fb$export$2da8b1cb5a5c1650","$a985f73a592474fb$export$6f76a56e2909b861","$a985f73a592474fb$export$ea1c1c64007bc24b","node","$a985f73a592474fb$export$32ec3f290cb70d5a","$a985f73a592474fb$export$b4f30947615ab0c1","optimizers","startProgram","optimizer","$a985f73a592474fb$export$f47d6a487cee0a73","runProgram","cost","$d81bf0ff4dbe2d6e$var$mainName","$d81bf0ff4dbe2d6e$export$9896244d8c99a4d0","items","halfSize","slice","$d81bf0ff4dbe2d6e$export$50a2a08029067c58","$d81bf0ff4dbe2d6e$export$bffa455ba8c619a6","$d81bf0ff4dbe2d6e$export$fddefddb691e6258","functions","constants","macros","macrosAsDict","possibleSymbols","keys","newNames","usedNames","size","priorNewNames","group","$d81bf0ff4dbe2d6e$export$8bf632d40c0a848b","name","namespace","output","$d81bf0ff4dbe2d6e$export$7d6a67d8e26b1886","$d81bf0ff4dbe2d6e$export$66c2bd7a184bdde8","includes","$d81bf0ff4dbe2d6e$export$3d84838a88a77879","second","third","code","unquotedCode","push","declarationProgram","op","nameProgram","JSON","stringify","$d81bf0ff4dbe2d6e$export$9665f6d487c71a5a","mainLocalArguments","uncompiledMain","$d81bf0ff4dbe2d6e$export$bb136ef67aed6c8c","tree","rootNode","$d81bf0ff4dbe2d6e$export$3b9592ef1cecfca1","macroLookupProgram","macro","$d81bf0ff4dbe2d6e$export$7eeeed3abcd324fe","constantSymbolTable","argsRootNode","compiledFunctions","lambdaExpression","entries","localSymbolTable","allSymbols","$d81bf0ff4dbe2d6e$export$19b97198b397b1c4","_symbolTable","allConstantNames","hasConstantTree","constantTree","constantRootNode","mainPathSource","argTreeSource","allConstantsLookup","assign","allConstantsList","allConstantsTreeProgram","allConstantsTreeSource","$6edfc72fb8768007$var$passThroughOperators","values","toHex","$6edfc72fb8768007$export$4f014e0e2f9a3439","symbolTable","level","com","$6edfc72fb8768007$export$6469419774d99a46","expression","$6edfc72fb8768007$export$10e4a0f3245dd758","_args","_runProgram","$6edfc72fb8768007$export$11b536640056999f","_macroLookup","$6edfc72fb8768007$export$77f1bb37b4f1d5ec","qq","symbols","lambda","mod","$6edfc72fb8768007$export$1e276181c3bc016e","positionSuffix","pair","symbol","inner","macroPair","macroCode","postProgram","compiler","compiledArgs","startsWith","symbolText","newArgs","$6edfc72fb8768007$export$5af009c3dc40b1bc","prog","$50d1f9204136c73a$export$5fe13095c61781e4","if","listp","mallocPerByte","arithBase","arithPerByte","arithPerArg","logBase","logPerByte","logPerArg","grsBase","grsPerByte","eqBase","eqPerByte","grBase","grPerByte","divmodBase","divmodPerByte","divBase","divPerByte","sha256Base","sha256PerByte","sha256PerArg","pointAddBase","pointAddPerArg","pubkeyBase","pubkeyPerByte","mulBase","mulPerOp","mulLinearPerByte","mulSquarePerByteDivider","strlenBase","strlenPerByte","pathLookupBase","pathLookupPerLeg","pathLookupPerZeroByte","concatBase","concatPerByte","concatPerArg","boolBase","boolPerArg","ashiftBase","ashiftPerByte","lshiftBase","lshiftPerByte","lognotBase","lognotPerByte","apply","quote","$b45cfe84191f72e9$export$2370125adba2cb1e","byte","$b45cfe84191f72e9$export$520469ab96a2a022","environment","endByteCursor","BigInt","endBitMask","byteCursor","bitMask","$ee0ce775d2fb3caf$export$ccbce4efa7f8029b","list","$ee0ce775d2fb3caf$export$effcdbd76139450","fromBool","undefined","argLength","bytes","$ee0ce775d2fb3caf$export$c85cac6a8d81208f","hash256","total","argSize","sign","true","$ee0ce775d2fb3caf$export$2f0301b329918c24","numerator","denominator","quotientValue","remainderValue","quotient","remainder","localeCompare","defaultEc","n","exponent","PrivateKey","getG1","toBytes","point","JacobianPoint","infinityG1","fromInt","toInt","to","shift","$ee0ce775d2fb3caf$export$a0a039066bddd5e0","Infinity","false","$ee0ce775d2fb3caf$export$391b7405552d5e99","unknown","$ee0ce775d2fb3caf$export$2d0c81c03591c44","$ee0ce775d2fb3caf$export$46a92a3441911620","operators","type","Array","isArray","forEach","opName","initialValue","opFunction","costFunction","costMultiplier","bytesToInt","argList","current","$ee0ce775d2fb3caf$export$664a4a7902029a5b","options","keyword","find","entry","$bd56f675ad0fd6d4$export$21ba78b50397401d","swap","_instructionStack","stack","_options","pop","eval","instructionStack","newOperator","mustBeNil","newOperandList","operandList","$ecfc887e9c4d9ec4$export$efcd34ab6248d3cd","sizeBytes","decodeInt","$2795eb571c1ed5e7$export$13807d9ee5a34a42","line","column","source","replaceAll","$bdb42fba8f5f461a$export$48cfd1e771a65c4f","tokens","$bdb42fba8f5f461a$export$3570f33b1a1f3329","token","$bdb42fba8f5f461a$export$1d5ccafae59b4926","char","test","$bdb42fba8f5f461a$export$ab7f5d67832a6850","text","$bdb42fba8f5f461a$export$92d34793dd37ac50","start","$bdb42fba8f5f461a$export$4e9e188b3a3b0cbf","at","consStart","$bdb42fba8f5f461a$export$cd60724007a613c1","dotStart","$bdb42fba8f5f461a$export$cbe5a625b098a663","$bdb42fba8f5f461a$export$c553c4a3641f57a2","toLowerCase","hex","fromHex","e","$bdb42fba8f5f461a$export$efc939cd3ec83299","$bdb42fba8f5f461a$export$52faefa73a5cb81b","$bdb42fba8f5f461a$export$f3f15647e54e234d","position","fromJacobianPoint","jacobianPoint","fromPrivateKey","privateKey","encodeInt","stream","programs","reverse","deserialize","deserializeHex","curry","uncurry","uncurryPatternFunction","uncurryPatternCore","fn","function","core","parm","hash","concatBytes","hashHex","define","splice","defineAll","compile","fullOptions","strict","includeFilePaths","_operator","doFullPathForName","fileName","path","files","doRead","file","content","doWrite","opt","_full_path_for_name","_read","_write","instruction","maxCost","toJacobianPoint","fromBytesG1","fromBytesG2","toPrivateKey","toBool","decodeBigInt","TextDecoder","decode","toSource","showKeywords","string","serialize","RangeError","serializeHex"],"sources":["/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/index.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/types/ParserError.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/types/Program.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/constants/keywords.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/constants/printable.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/compile.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/constants/atoms.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/types/BetterSet.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/types/NodePath.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/helpers.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/macros.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/mod.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/compare.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/optimize.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/match.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/instructions.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/constants/costs.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/environment.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/operators.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/ir.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/utils/parser.ts","/Users/kev/repos/chialisp-starter-pack/helper/node_modules/clvm-lib/src/types/Position.ts"],"sourcesContent":["export * from './types/ParserError';\nexport {\n    Program,\n    type CompileOptions,\n    type Cons,\n    type ProgramOutput,\n    type RunOptions,\n    type Value,\n} from './types/Program';\n","export class ParserError extends Error {\n    constructor(message: string) {\n        super(message);\n        Object.setPrototypeOf(this, ParserError.prototype);\n    }\n}\n","import {\n    bytesEqual,\n    concatBytes,\n    decodeBigInt,\n    decodeInt,\n    encodeBigInt,\n    encodeInt,\n    fromHex,\n    hash256,\n    JacobianPoint,\n    PrivateKey,\n    toHex,\n} from 'chia-bls';\nimport { keywords } from '../constants/keywords';\nimport { printable } from '../constants/printable';\nimport { makeDoCom } from '../utils/compile';\nimport { instructions } from '../utils/instructions';\nimport { deserialize } from '../utils/ir';\nimport { match } from '../utils/match';\nimport { makeDefaultOperators, Operators } from '../utils/operators';\nimport { makeDoOpt } from '../utils/optimize';\nimport { tokenizeExpr, tokenStream } from '../utils/parser';\nimport { ParserError } from './ParserError';\nimport { Position } from './Position';\n\nexport interface ProgramOutput {\n    value: Program;\n    cost: bigint;\n}\n\nexport interface RunOptions {\n    maxCost?: bigint;\n    operators: Operators;\n    strict: boolean;\n}\n\nexport interface CompileOptions extends RunOptions {\n    includeFilePaths: Record<string, Record<string, string>>;\n}\n\nexport type Cons = [Program, Program];\nexport type Value = Cons | Uint8Array;\n\nexport type Instruction = (\n    instructions: Instruction[],\n    stack: Program[],\n    options: RunOptions\n) => bigint;\n\nexport class Program {\n    public static cost = 11000000000;\n    public static true = Program.fromBytes(Uint8Array.from([1]));\n    public static false = Program.fromBytes(Uint8Array.from([]));\n    public static nil = Program.false;\n\n    public readonly value: Value;\n    public position?: Position;\n\n    public get atom(): Uint8Array {\n        if (!this.isAtom)\n            throw new Error(`Expected atom${this.positionSuffix}.`);\n        return this.value as Uint8Array;\n    }\n\n    public get cons(): Cons {\n        if (!this.isCons)\n            throw new Error(`Expected cons${this.positionSuffix}.`);\n        return this.value as Cons;\n    }\n\n    public get first(): Program {\n        return this.cons[0];\n    }\n\n    public get rest(): Program {\n        return this.cons[1];\n    }\n\n    public get isAtom() {\n        return this.value instanceof Uint8Array;\n    }\n\n    public get isCons() {\n        return Array.isArray(this.value);\n    }\n\n    public get isNull(): boolean {\n        return this.isAtom && this.value.length === 0;\n    }\n\n    public static cons(first: Program, rest: Program): Program {\n        return new Program([first, rest]);\n    }\n\n    public static fromBytes(bytes: Uint8Array): Program {\n        return new Program(bytes);\n    }\n\n    public static fromJacobianPoint(jacobianPoint: JacobianPoint): Program {\n        return new Program(jacobianPoint.toBytes());\n    }\n\n    public static fromPrivateKey(privateKey: PrivateKey): Program {\n        return new Program(privateKey.toBytes());\n    }\n\n    public static fromHex(hex: string): Program {\n        return new Program(fromHex(hex));\n    }\n\n    public static fromBool(value: boolean): Program {\n        return value ? Program.true : Program.false;\n    }\n\n    public static fromInt(value: number): Program {\n        return new Program(encodeInt(value));\n    }\n\n    public static fromBigInt(value: bigint): Program {\n        return new Program(encodeBigInt(value));\n    }\n\n    public static fromText(text: string): Program {\n        return new Program(new TextEncoder().encode(text));\n    }\n\n    public static fromSource(source: string): Program {\n        const stream = tokenStream(source);\n        const tokens = [...stream];\n        if (tokens.length) return tokenizeExpr(source, tokens);\n        else throw new ParserError('Unexpected end of source.');\n    }\n\n    public static fromList(programs: Program[]): Program {\n        let result = Program.nil;\n        for (const program of programs.reverse())\n            result = Program.cons(program, result);\n        return result;\n    }\n\n    public static deserialize(bytes: Uint8Array): Program {\n        const program = [...bytes];\n        if (!program.length) throw new ParserError('Unexpected end of source.');\n        return deserialize(program);\n    }\n\n    public static deserializeHex(hex: string): Program {\n        return Program.deserialize(fromHex(hex));\n    }\n\n    constructor(value: Value) {\n        this.value = value;\n    }\n\n    public get positionSuffix(): string {\n        return this.position ? ` at ${this.position}` : '';\n    }\n\n    public at(position: Position): this {\n        this.position = position;\n        return this;\n    }\n\n    public curry(args: Program[]): Program {\n        return Program.fromSource(\n            '(a (q #a 4 (c 2 (c 5 (c 7 0)))) (c (q (c (q . 2) (c (c (q . 1) 5) (c (a 6 (c 2 (c 11 (q 1)))) 0))) #a (i 5 (q 4 (q . 4) (c (c (q . 1) 9) (c (a 6 (c 2 (c 13 (c 11 0)))) 0))) (q . 11)) 1) 1))'\n        ).run(Program.cons(this, Program.fromList(args))).value;\n    }\n\n    public uncurry(): [Program, Program[]] | null {\n        const uncurryPatternFunction = Program.fromSource(\n            '(a (q . (: . function)) (: . core))'\n        );\n        const uncurryPatternCore = Program.fromSource(\n            '(c (q . (: . parm)) (: . core))'\n        );\n\n        let result = match(uncurryPatternFunction, this);\n        if (!result) return null;\n\n        const fn = result.function;\n        let core = result.core;\n\n        const args: Array<Program> = [];\n\n        while (true) {\n            result = match(uncurryPatternCore, core);\n            if (!result) break;\n\n            args.push(result.parm);\n            core = result.core;\n        }\n\n        if (core.isAtom && core.toBigInt() === 1n) return [fn, args];\n        return null;\n    }\n\n    public hash(): Uint8Array {\n        return this.isAtom\n            ? hash256(concatBytes(Uint8Array.from([1]), this.atom))\n            : hash256(\n                  concatBytes(\n                      Uint8Array.from([2]),\n                      this.first.hash(),\n                      this.rest.hash()\n                  )\n              );\n    }\n\n    public hashHex(): string {\n        return toHex(this.hash());\n    }\n\n    public define(program: Program): Program {\n        let result: Program = this;\n        if (this.isAtom || this.first.isCons || this.first.toText() !== 'mod')\n            result = Program.fromList([\n                Program.fromText('mod'),\n                Program.nil,\n                this,\n            ]);\n        const items = result.toList();\n        items.splice(2, 0, program);\n        return Program.fromList(items);\n    }\n\n    public defineAll(programs: Program[]): Program {\n        let result: Program = this;\n        for (const program of programs.reverse())\n            result = result.define(program);\n        return result;\n    }\n\n    public compile(options: Partial<CompileOptions> = {}): ProgramOutput {\n        const fullOptions: CompileOptions = {\n            strict: false,\n            operators: makeDefaultOperators(),\n            includeFilePaths: {},\n            ...options,\n        };\n        if (fullOptions.strict)\n            fullOptions.operators.unknown = (_operator, args) => {\n                throw new Error(\n                    `Unimplemented operator${args.positionSuffix}.`\n                );\n            };\n        function doFullPathForName(args: Program): ProgramOutput {\n            const fileName = args.first.toText();\n            for (const [path, files] of Object.entries(\n                fullOptions.includeFilePaths\n            )) {\n                if (fileName in files)\n                    return {\n                        value: Program.fromText(`${path}/${fileName}`),\n                        cost: 1n,\n                    };\n            }\n            throw new Error(`Can't open ${fileName}${args.positionSuffix}.`);\n        }\n        function doRead(args: Program): ProgramOutput {\n            const fileName = args.first.toText();\n            let source: string | null = null;\n            for (const [path, files] of Object.entries(\n                fullOptions.includeFilePaths\n            )) {\n                for (const [file, content] of Object.entries(files)) {\n                    if (fileName === `${path}/${file}`) source = content;\n                }\n            }\n            if (source === null)\n                throw new Error(\n                    `Can't open ${fileName}${args.positionSuffix}.`\n                );\n            return { value: Program.fromSource(source), cost: 1n };\n        }\n        // Not functional, due to browser support. May reimplement later.\n        function doWrite(_args: Program): ProgramOutput {\n            return { value: Program.nil, cost: 1n };\n        }\n\n        function runProgram(program: Program, args: Program): ProgramOutput {\n            return program.run(args, fullOptions);\n        }\n        const bindings = {\n            com: makeDoCom(runProgram),\n            opt: makeDoOpt(runProgram),\n            _full_path_for_name: doFullPathForName,\n            _read: doRead,\n            _write: doWrite,\n        };\n        Object.assign(fullOptions.operators.operators, bindings);\n        return runProgram(\n            Program.fromSource('(a (opt (com 2)) 3)'),\n            Program.fromList([this])\n        );\n    }\n\n    public run(\n        environment: Program,\n        options: Partial<RunOptions> = {}\n    ): ProgramOutput {\n        const fullOptions: RunOptions = {\n            strict: false,\n            operators: makeDefaultOperators(),\n            ...options,\n        };\n        if (fullOptions.strict)\n            fullOptions.operators.unknown = (_operator, args) => {\n                throw new Error(\n                    `Unimplemented operator${args.positionSuffix}.`\n                );\n            };\n        const instructionStack: Array<Instruction> = [instructions.eval];\n        const stack: Array<Program> = [Program.cons(this, environment)];\n        let cost = 0n;\n        while (instructionStack.length) {\n            const instruction = instructionStack.pop()!;\n            cost += instruction(instructionStack, stack, fullOptions);\n            if (fullOptions.maxCost !== undefined && cost > fullOptions.maxCost)\n                throw new Error(\n                    `Exceeded cost of ${fullOptions.maxCost}${\n                        stack[stack.length - 1].positionSuffix\n                    }.`\n                );\n        }\n        return {\n            value: stack[stack.length - 1],\n            cost,\n        };\n    }\n\n    public toBytes(): Uint8Array {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to hex${\n                    this.positionSuffix\n                }.`\n            );\n        return this.atom;\n    }\n\n    public toJacobianPoint(): JacobianPoint {\n        if (this.isCons || (this.atom.length !== 48 && this.atom.length !== 96))\n            throw new Error(\n                `Cannot convert ${this.toString()} to JacobianPoint${\n                    this.positionSuffix\n                }.`\n            );\n        return this.atom.length === 48\n            ? JacobianPoint.fromBytesG1(this.atom)\n            : JacobianPoint.fromBytesG2(this.atom);\n    }\n\n    public toPrivateKey(): PrivateKey {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to private key${\n                    this.positionSuffix\n                }.`\n            );\n        return PrivateKey.fromBytes(this.atom);\n    }\n\n    public toHex(): string {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to hex${\n                    this.positionSuffix\n                }.`\n            );\n        return toHex(this.atom);\n    }\n\n    public toBool(): boolean {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to bool${\n                    this.positionSuffix\n                }.`\n            );\n        return !this.isNull;\n    }\n\n    public toInt(): number {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to int${\n                    this.positionSuffix\n                }.`\n            );\n        return decodeInt(this.atom);\n    }\n\n    public toBigInt(): bigint {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to bigint${\n                    this.positionSuffix\n                }.`\n            );\n        return decodeBigInt(this.atom);\n    }\n\n    public toText(): string {\n        if (this.isCons)\n            throw new Error(\n                `Cannot convert ${this.toString()} to text${\n                    this.positionSuffix\n                }.`\n            );\n        return new TextDecoder().decode(this.atom);\n    }\n\n    public toSource(showKeywords: boolean = true): string {\n        if (this.isAtom) {\n            if (this.isNull) return '()';\n            else if (this.value.length > 2) {\n                try {\n                    const string = this.toText();\n                    for (let i = 0; i < string.length; i++) {\n                        if (!printable.includes(string[i]))\n                            return `0x${this.toHex()}`;\n                    }\n                    if (string.includes('\"') && string.includes(\"'\"))\n                        return `0x${this.toHex()}`;\n                    const quote = string.includes('\"') ? \"'\" : '\"';\n                    return quote + string + quote;\n                } catch {\n                    return `0x${this.toHex()}`;\n                }\n            } else if (bytesEqual(encodeInt(decodeInt(this.atom)), this.atom))\n                return decodeInt(this.atom).toString();\n            else return `0x${this.toHex()}`;\n        } else {\n            let result = '(';\n            if (showKeywords && this.first.isAtom) {\n                const value = this.first.toBigInt();\n                const keyword = Object.keys(keywords).find(\n                    (keyword) =>\n                        keywords[keyword as keyof typeof keywords] === value\n                );\n                result += keyword ? keyword : this.first.toSource(showKeywords);\n            } else result += this.first.toSource(showKeywords);\n            let current = this.cons[1];\n            while (current.isCons) {\n                result += ` ${current.first.toSource(showKeywords)}`;\n                current = current.cons[1];\n            }\n            result +=\n                (current.isNull ? '' : ` . ${current.toSource(showKeywords)}`) +\n                ')';\n            return result;\n        }\n    }\n\n    public toList(strict: boolean = false): Program[] {\n        const result: Array<Program> = [];\n        let current: Program = this;\n        while (current.isCons) {\n            const item = current.first;\n            result.push(item);\n            current = current.rest;\n        }\n        if (!current.isNull && strict)\n            throw new Error(`Expected strict list${this.positionSuffix}.`);\n        return result;\n    }\n\n    public serialize(): Uint8Array {\n        if (this.isAtom) {\n            if (this.isNull) return Uint8Array.from([0x80]);\n            else if (this.atom.length === 1 && this.atom[0] <= 0x7f)\n                return this.atom;\n            else {\n                const size = this.atom.length;\n                const result: Array<number> = [];\n                if (size < 0x40) result.push(0x80 | size);\n                else if (size < 0x2000) {\n                    result.push(0xc0 | (size >> 8));\n                    result.push((size >> 0) & 0xff);\n                } else if (size < 0x100000) {\n                    result.push(0xe0 | (size >> 16));\n                    result.push((size >> 8) & 0xff);\n                    result.push((size >> 0) & 0xff);\n                } else if (size < 0x8000000) {\n                    result.push(0xf0 | (size >> 24));\n                    result.push((size >> 16) & 0xff);\n                    result.push((size >> 8) & 0xff);\n                    result.push((size >> 0) & 0xff);\n                } else if (size < 0x400000000) {\n                    result.push(0xf8 | (size >> 32));\n                    result.push((size >> 24) & 0xff);\n                    result.push((size >> 16) & 0xff);\n                    result.push((size >> 8) & 0xff);\n                    result.push((size >> 0) & 0xff);\n                } else\n                    throw new RangeError(\n                        `Cannot serialize ${this.toString()} as it is 17,179,869,184 or more bytes in size${\n                            this.positionSuffix\n                        }.`\n                    );\n                for (const byte of this.atom) result.push(byte);\n                return Uint8Array.from(result);\n            }\n        } else {\n            const result = [0xff];\n            for (const byte of this.first.serialize()) result.push(byte);\n            for (const byte of this.rest.serialize()) result.push(byte);\n            return Uint8Array.from(result);\n        }\n    }\n\n    public serializeHex(): string {\n        return toHex(this.serialize());\n    }\n\n    public equals(value: Program): boolean {\n        return (\n            this.isAtom === value.isAtom &&\n            (this.isAtom\n                ? bytesEqual(this.atom, value.atom)\n                : this.first.equals(value.first) &&\n                  this.rest.equals(value.rest))\n        );\n    }\n\n    public toString(): string {\n        return this.toSource();\n    }\n}\n","export const keywords = {\n    q: 0x01n,\n    a: 0x02n,\n    i: 0x03n,\n    c: 0x04n,\n    f: 0x05n,\n    r: 0x06n,\n    l: 0x07n,\n    x: 0x08n,\n    '=': 0x09n,\n    '>s': 0x0an,\n    sha256: 0x0bn,\n    substr: 0x0cn,\n    strlen: 0x0dn,\n    concat: 0x0en,\n    '+': 0x10n,\n    '-': 0x11n,\n    '*': 0x12n,\n    '/': 0x13n,\n    divmod: 0x14n,\n    '>': 0x15n,\n    ash: 0x16n,\n    lsh: 0x17n,\n    logand: 0x18n,\n    logior: 0x19n,\n    logxor: 0x1an,\n    lognot: 0x1bn,\n    point_add: 0x1dn,\n    pubkey_for_exp: 0x1en,\n    not: 0x20n,\n    any: 0x21n,\n    all: 0x22n,\n    '.': 0x23n,\n    softfork: 0x24n,\n};\n","export const printable = `0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+,-./:;<=>?@[\\]^_\\`{|}~ \t\n\n\u000b\f`;\n","import { bytesEqual, encodeBigInt, toHex } from 'chia-bls';\nimport { applyAtom, consAtom, quoteAtom } from '../constants/atoms';\nimport { keywords } from '../constants/keywords';\nimport { BetterSet } from '../types/BetterSet';\nimport { NodePath } from '../types/NodePath';\nimport { Program, ProgramOutput } from '../types/Program';\nimport { brunAsProgram, Eval, evalAsProgram, quoteAsProgram } from './helpers';\nimport { defaultMacroLookup } from './macros';\nimport { compileMod } from './mod';\nimport { Operator } from './operators';\n\nconst passThroughOperators = new BetterSet([\n    ...Object.values(keywords).map((value) => toHex(encodeBigInt(value))),\n    toHex(new TextEncoder().encode('com')),\n    toHex(new TextEncoder().encode('opt')),\n]);\n\nexport function compileQq(\n    args: Program,\n    macroLookup: Program,\n    symbolTable: Program,\n    runProgram: Eval,\n    level: number = 1\n): Program {\n    function com(program: Program): Program {\n        return doComProgram(program, macroLookup, symbolTable, runProgram);\n    }\n\n    const program = args.first;\n    if (!program.isCons) {\n        return quoteAsProgram(program);\n    }\n    if (!program.first.isCons) {\n        const op = program.first.toText();\n        if (op === 'qq') {\n            const expression = compileQq(\n                program.rest,\n                macroLookup,\n                symbolTable,\n                runProgram,\n                level + 1\n            );\n            return com(\n                Program.fromList([\n                    Program.fromBytes(consAtom),\n                    Program.fromText(op),\n                    Program.fromList([\n                        Program.fromBytes(consAtom),\n                        expression,\n                        quoteAsProgram(Program.nil),\n                    ]),\n                ])\n            );\n        } else if (op === 'unquote') {\n            if (level === 1) {\n                return com(program.rest.first);\n            }\n            const expression = compileQq(\n                program.rest,\n                macroLookup,\n                symbolTable,\n                runProgram,\n                level - 1\n            );\n            return com(\n                Program.fromList([\n                    Program.fromBytes(consAtom),\n                    Program.fromText(op),\n                    Program.fromList([\n                        Program.fromBytes(consAtom),\n                        expression,\n                        quoteAsProgram(Program.nil),\n                    ]),\n                ])\n            );\n        }\n    }\n    const first = com(\n        Program.fromList([Program.fromText('qq'), program.first])\n    );\n    const rest = com(Program.fromList([Program.fromText('qq'), program.rest]));\n    return Program.fromList([Program.fromBytes(consAtom), first, rest]);\n}\n\nexport function compileMacros(\n    _args: Program,\n    macroLookup: Program,\n    _symbolTable: Program,\n    _runProgram: Eval\n): Program {\n    return quoteAsProgram(macroLookup);\n}\n\nexport function compileSymbols(\n    _args: Program,\n    _macroLookup: Program,\n    symbolTable: Program,\n    _runProgram: Eval\n): Program {\n    return quoteAsProgram(symbolTable);\n}\n\nexport const compileBindings = {\n    qq: compileQq,\n    macros: compileMacros,\n    symbols: compileSymbols,\n    lambda: compileMod,\n    mod: compileMod,\n};\n\nexport function lowerQuote(\n    program: Program,\n    _macroLookup?: Program,\n    _symbolTable?: Program,\n    _runProgram?: Eval\n): Program {\n    if (program.isAtom) {\n        return program;\n    } else if (program.first.isAtom && program.first.toText() === 'quote') {\n        if (!program.rest.rest.isNull)\n            throw new Error(\n                `Compilation error while compiling ${program}. Quote takes exactly one argument${program.positionSuffix}.`\n            );\n        return quoteAsProgram(lowerQuote(program.rest.first));\n    } else\n        return Program.cons(\n            lowerQuote(program.first),\n            lowerQuote(program.rest)\n        );\n}\n\nexport function doComProgram(\n    program: Program,\n    macroLookup: Program,\n    symbolTable: Program,\n    runProgram: Eval\n): Program {\n    program = lowerQuote(program, macroLookup, symbolTable, runProgram);\n    if (!program.isCons) {\n        const atom = program.toText();\n        if (atom === '@') {\n            return Program.fromBytes(NodePath.top.asPath());\n        }\n        for (const pair of symbolTable.toList()) {\n            const symbol = pair.first;\n            const value = pair.rest.first;\n            if (symbol.isAtom && symbol.toText() === atom) {\n                return value;\n            }\n        }\n        return quoteAsProgram(program);\n    }\n    const operator = program.first;\n    if (operator.isCons) {\n        const inner = evalAsProgram(\n            Program.fromList([\n                Program.fromText('com'),\n                quoteAsProgram(operator),\n                quoteAsProgram(macroLookup),\n                quoteAsProgram(symbolTable),\n            ]),\n            Program.fromBytes(NodePath.top.asPath())\n        );\n        return Program.fromList([inner]);\n    }\n    const atom = operator.toText();\n    for (const macroPair of macroLookup.toList()) {\n        if (macroPair.first.isAtom && macroPair.first.toText() === atom) {\n            const macroCode = macroPair.rest.first;\n            const postProgram = brunAsProgram(macroCode, program.rest);\n            const result = evalAsProgram(\n                Program.fromList([\n                    Program.fromText('com'),\n                    postProgram,\n                    quoteAsProgram(macroLookup),\n                    quoteAsProgram(symbolTable),\n                ]),\n                Program.fromBytes(NodePath.top.asPath())\n            );\n            return result;\n        }\n    }\n    if (atom in compileBindings) {\n        const compiler = compileBindings[atom as keyof typeof compileBindings];\n        const postProgram = compiler(\n            program.rest,\n            macroLookup,\n            symbolTable,\n            runProgram\n        );\n        return evalAsProgram(\n            quoteAsProgram(postProgram),\n            Program.fromBytes(NodePath.top.asPath())\n        );\n    }\n    if (bytesEqual(operator.atom, quoteAtom)) {\n        return program;\n    }\n    const compiledArgs = program.rest\n        .toList()\n        .map((item) =>\n            doComProgram(item, macroLookup, symbolTable, runProgram)\n        );\n    let result = Program.fromList([operator, ...compiledArgs]);\n    if (\n        passThroughOperators.has(toHex(new TextEncoder().encode(atom))) ||\n        atom.startsWith('_')\n    ) {\n        return result;\n    }\n    for (const item of symbolTable.toList()) {\n        const [symbol, value] = item.toList();\n        if (!symbol.isAtom) continue;\n        const symbolText = symbol.toText();\n        if (symbolText === '*') {\n            return result;\n        } else if (symbolText === atom) {\n            const newArgs = evalAsProgram(\n                Program.fromList([\n                    Program.fromText('opt'),\n                    Program.fromList([\n                        Program.fromText('com'),\n                        quoteAsProgram(\n                            Program.fromList([\n                                Program.fromText('list'),\n                                ...program.rest.toList(),\n                            ])\n                        ),\n                        quoteAsProgram(macroLookup),\n                        quoteAsProgram(symbolTable),\n                    ]),\n                ]),\n                Program.fromBytes(NodePath.top.asPath())\n            );\n            return Program.fromList([\n                Program.fromBytes(applyAtom),\n                value,\n                Program.fromList([\n                    Program.fromBytes(consAtom),\n                    Program.fromBytes(NodePath.left.asPath()),\n                    newArgs,\n                ]),\n            ]);\n        }\n    }\n    throw new Error(\n        `Can't compile unknown operator ${program}${program.positionSuffix}.`\n    );\n}\n\nexport function makeDoCom(runProgram: Eval): Operator {\n    return (sexp: Program): ProgramOutput => {\n        const prog = sexp.first;\n        let symbolTable = Program.nil;\n        let macroLookup: Program;\n        if (!sexp.rest.isNull) {\n            macroLookup = sexp.rest.first;\n            if (!sexp.rest.rest.isNull) symbolTable = sexp.rest.rest.first;\n        } else {\n            macroLookup = defaultMacroLookup(runProgram);\n        }\n        return {\n            value: doComProgram(prog, macroLookup, symbolTable, runProgram),\n            cost: 1n,\n        };\n    };\n}\n","import { encodeBigInt } from 'chia-bls';\nimport { keywords } from './keywords';\n\nexport const quoteAtom = encodeBigInt(keywords['q']);\nexport const applyAtom = encodeBigInt(keywords['a']);\nexport const firstAtom = encodeBigInt(keywords['f']);\nexport const restAtom = encodeBigInt(keywords['r']);\nexport const consAtom = encodeBigInt(keywords['c']);\nexport const raiseAtom = encodeBigInt(keywords['x']);\n","export class BetterSet<T> extends Set<T> {\n    public isSuperset(set: Set<T>): boolean {\n        for (const item of set) if (!this.has(item)) return false;\n        return true;\n    }\n\n    public isSubset(set: Set<T>): boolean {\n        for (const item of this) if (!set.has(item)) return false;\n        return true;\n    }\n\n    public isSupersetProper(set: Set<T>): boolean {\n        return this.isSuperset(set) && !this.isSubset(set);\n    }\n\n    public isSubsetProper(set: Set<T>): boolean {\n        return this.isSubset(set) && !this.isSuperset(set);\n    }\n\n    public equals(set: Set<T>): boolean {\n        return this.isSubset(set) && this.isSuperset(set);\n    }\n\n    public union(set: Set<T>): BetterSet<T> {\n        const union = new BetterSet(this);\n        for (const item of set) union.add(item);\n        return union;\n    }\n\n    public intersection(set: Set<T>): BetterSet<T> {\n        const intersection = new BetterSet<T>();\n        for (const item of set) if (this.has(item)) intersection.add(item);\n        return intersection;\n    }\n\n    public symmetricDifference(set: Set<T>): BetterSet<T> {\n        const difference = new BetterSet<T>(this);\n        for (const item of set)\n            if (difference.has(item)) difference.delete(item);\n            else difference.add(item);\n        return difference;\n    }\n\n    public difference(set: Set<T>): BetterSet<T> {\n        const difference = new BetterSet<T>(this);\n        for (const item of set) difference.delete(item);\n        return difference;\n    }\n\n    public update(set: Set<T>): this {\n        for (const item of set) this.add(item);\n        return this;\n    }\n\n    public differenceUpdate(set: Set<T>): this {\n        for (const item of set) this.delete(item);\n        return this;\n    }\n\n    public symmetricDifferenceUpdate(set: Set<T>): this {\n        for (const item of set)\n            if (this.has(item)) this.delete(item);\n            else this.add(item);\n        return this;\n    }\n\n    public intersectionUpdate(set: Set<T>): this {\n        for (const item of this) if (!set.has(item)) this.delete(item);\n        return this;\n    }\n\n    public sort(sorter?: (a: T, b: T) => number): BetterSet<T> {\n        return new BetterSet([...this].sort(sorter));\n    }\n\n    public map<U>(\n        mapper: (value: T, index: number, array: BetterSet<T>) => U\n    ): BetterSet<U> {\n        const result = new BetterSet<U>();\n        let index = 0;\n        for (const item of this) result.add(mapper(item, index++, this));\n        return result;\n    }\n\n    public filter(\n        predicate: (value: T, index: number, array: BetterSet<T>) => unknown\n    ): BetterSet<T> {\n        const result = new BetterSet<T>();\n        let index = 0;\n        for (const item of this)\n            if (predicate(item, index++, this)) result.add(item);\n        return result;\n    }\n}\n","import { bigIntBitLength, bigIntToBytes, bytesToBigInt } from 'chia-bls';\n\nexport function composePaths(left: bigint, right: bigint): bigint {\n    let mask = 1n;\n    let tempPath = left;\n    while (tempPath > 1n) {\n        right <<= 1n;\n        mask <<= 1n;\n        tempPath >>= 1n;\n    }\n    mask -= 1n;\n    return right | (left & mask);\n}\n\nexport class NodePath {\n    public static top: NodePath = new NodePath();\n    public static left: NodePath = NodePath.top.first();\n    public static right: NodePath = NodePath.top.rest();\n\n    private index: bigint;\n\n    constructor(index: bigint = 1n) {\n        if (index < 0n) {\n            const byteCount = (bigIntBitLength(index) + 7) >> 3;\n            const blob = bigIntToBytes(index, byteCount, 'big', true);\n            index = bytesToBigInt(Uint8Array.from([0, ...blob]), 'big', false);\n        }\n        this.index = index;\n    }\n\n    public asPath(): Uint8Array {\n        const byteCount = (bigIntBitLength(this.index) + 7) >> 3;\n        return bigIntToBytes(this.index, byteCount, 'big');\n    }\n\n    public add(other: NodePath): NodePath {\n        return new NodePath(composePaths(this.index, other.index));\n    }\n\n    public first(): NodePath {\n        return new NodePath(this.index * 2n);\n    }\n\n    public rest(): NodePath {\n        return new NodePath(this.index * 2n + 1n);\n    }\n\n    public toString(): string {\n        return `NodePath: ${this.index}`;\n    }\n}\n","import { keywords } from '../constants/keywords';\nimport { NodePath } from '../types/NodePath';\nimport { Program, ProgramOutput } from '../types/Program';\n\nexport type Eval = (program: Program, args: Program) => ProgramOutput;\nexport type Group = Record<string, Program>;\n\nexport function quoteAsProgram(program: Program): Program {\n    return Program.cons(Program.fromBigInt(keywords['q']), program);\n}\n\nexport function evalAsProgram(program: Program, args: Program): Program {\n    return Program.fromList([Program.fromBigInt(keywords['a']), program, args]);\n}\n\nexport function runAsProgram(program: Program, macroLookup: Program): Program {\n    return evalAsProgram(\n        Program.fromList([\n            Program.fromText('com'),\n            program,\n            quoteAsProgram(macroLookup),\n        ]),\n        Program.fromBytes(NodePath.top.asPath())\n    );\n}\n\nexport function brunAsProgram(program: Program, args: Program): Program {\n    return evalAsProgram(quoteAsProgram(program), quoteAsProgram(args));\n}\n","import { Program } from '../index';\nimport { Eval } from './helpers';\n\nconst defaultMacroSources = [\n    `\n    ; we have to compile this externally, since it uses itself\n    ;(defmacro defmacro (name params body)\n    ;    (qq (list (unquote name) (mod (unquote params) (unquote body))))\n    ;)\n    (q . (\"defmacro\"\n       (c (q . \"list\")\n          (c (f 1)\n             (c (c (q . \"mod\")\n                   (c (f (r 1))\n                      (c (f (r (r 1)))\n                         (q . ()))))\n                (q . ()))))))\n    `,\n    `\n    ;(defmacro list ARGS\n    ;    ((c (mod args\n    ;        (defun compile-list\n    ;               (args)\n    ;               (if args\n    ;                   (qq (c (unquote (f args))\n    ;                         (unquote (compile-list (r args)))))\n    ;                   ()))\n    ;            (compile-list args)\n    ;        )\n    ;        ARGS\n    ;    ))\n    ;)\n    (q \"list\"\n        (a (q #a (q #a 2 (c 2 (c 3 (q))))\n                 (c (q #a (i 5\n                             (q #c (q . 4)\n                                   (c 9 (c (a 2 (c 2 (c 13 (q))))\n                                           (q)))\n                             )\n                             (q 1))\n                           1)\n                    1))\n            1))\n    `,\n    `(defmacro function (BODY)\n        (qq (opt (com (q . (unquote BODY))\n                 (qq (unquote (macros)))\n                 (qq (unquote (symbols)))))))`,\n    `(defmacro if (A B C)\n        (qq (a\n            (i (unquote A)\n               (function (unquote B))\n               (function (unquote C)))\n            @)))`,\n    `(defmacro / (A B) (qq (f (divmod (unquote A) (unquote B)))))`,\n];\n\nlet defaultMacroLookupProgram: Program | undefined;\n\nfunction buildDefaultMacroLookup(evalAsProgram: Eval): Program {\n    const run = Program.fromSource('(a (com 2 3) 1)');\n    for (const macroSource of defaultMacroSources) {\n        const macroProgram = Program.fromSource(macroSource);\n        const env = Program.cons(macroProgram, defaultMacroLookupProgram!);\n        const newMacro = evalAsProgram(run, env).value;\n        defaultMacroLookupProgram = Program.cons(\n            newMacro,\n            defaultMacroLookupProgram!\n        );\n    }\n    return defaultMacroLookupProgram!;\n}\n\nexport function defaultMacroLookup(evalAsProgram: Eval): Program {\n    if (!defaultMacroLookupProgram || defaultMacroLookupProgram.isNull) {\n        defaultMacroLookupProgram = Program.fromList([]);\n        buildDefaultMacroLookup(evalAsProgram);\n    }\n    return defaultMacroLookupProgram;\n}\n","import { consAtom } from '../constants/atoms';\nimport { Program } from '../index';\nimport { BetterSet } from '../types/BetterSet';\nimport { NodePath } from '../types/NodePath';\nimport { compareStrings } from './compare';\nimport { Eval, evalAsProgram, Group, quoteAsProgram } from './helpers';\nimport { optimizeProgram } from './optimize';\n\nconst mainName = '';\n\nexport function buildTree(items: Program[]): Program {\n    if (items.length === 0) return Program.nil;\n    else if (items.length === 1) return items[0];\n    const halfSize = items.length >> 1;\n    return Program.cons(\n        buildTree(items.slice(0, halfSize)),\n        buildTree(items.slice(halfSize))\n    );\n}\n\nexport function buildTreeProgram(items: Program[]): Program {\n    if (items.length === 0)\n        return Program.fromList([quoteAsProgram(Program.nil)]);\n    else if (items.length === 1) return items[0];\n    const halfSize = items.length >> 1;\n    return Program.fromList([\n        Program.fromBytes(consAtom),\n        buildTreeProgram(items.slice(0, halfSize)),\n        buildTreeProgram(items.slice(halfSize)),\n    ]);\n}\n\nexport function flatten(program: Program): string[] {\n    if (program.isCons)\n        return [...flatten(program.first), ...flatten(program.rest)];\n    else return [program.toText()];\n}\n\nexport function buildUsedConstantNames(\n    functions: Group,\n    constants: Group,\n    macros: Program[]\n): BetterSet<string> {\n    const macrosAsDict: Group = {};\n    for (const item of macros) macrosAsDict[item.rest.first.toText()] = item;\n    const possibleSymbols = new BetterSet(Object.keys(functions));\n    possibleSymbols.update(new BetterSet(Object.keys(constants)));\n    let newNames = new BetterSet([mainName]);\n    const usedNames = new BetterSet(newNames);\n    while (newNames.size) {\n        const priorNewNames = new BetterSet(newNames);\n        newNames = new BetterSet<string>();\n        for (const item of priorNewNames) {\n            for (const group of [functions, macrosAsDict]) {\n                if (item in group)\n                    newNames.update(new BetterSet(flatten(group[item])));\n            }\n        }\n        newNames.differenceUpdate(usedNames);\n        usedNames.update(newNames);\n    }\n    usedNames.intersectionUpdate(possibleSymbols);\n    usedNames.delete(mainName);\n    return usedNames.sort((a, b) => compareStrings(a, b));\n}\n\nexport function parseInclude(\n    name: Program,\n    namespace: BetterSet<string>,\n    functions: Group,\n    constants: Group,\n    macros: Program[],\n    runProgram: Eval\n): void {\n    const program = Program.fromSource('(_read (_full_path_for_name 1))');\n    const output = runProgram(program, name).value;\n    for (const item of output.toList())\n        parseModProgram(\n            item,\n            namespace,\n            functions,\n            constants,\n            macros,\n            runProgram\n        );\n}\n\nexport function unquoteArgs(program: Program, args: string[]): Program {\n    if (program.isCons) {\n        return Program.cons(\n            unquoteArgs(program.first, args),\n            unquoteArgs(program.rest, args)\n        );\n    } else if (args.includes(program.toText())) {\n        return Program.fromList([Program.fromText('unquote'), program]);\n    }\n    return program;\n}\n\nexport function defunInlineToMacro(program: Program): Program {\n    const second = program.rest;\n    const third = second.rest;\n    const items = [Program.fromText('defmacro'), second.first, third.first];\n    const code = third.rest.first;\n    const args = flatten(third.first).filter((item) => item.length);\n    const unquotedCode = unquoteArgs(code, args);\n    items.push(Program.fromList([Program.fromText('qq'), unquotedCode]));\n    return Program.fromList(items);\n}\n\nexport function parseModProgram(\n    declarationProgram: Program,\n    namespace: BetterSet<string>,\n    functions: Group,\n    constants: Group,\n    macros: Program[],\n    runProgram: Eval\n): void {\n    const op = declarationProgram.first.toText();\n    const nameProgram = declarationProgram.rest.first;\n    if (op === 'include') {\n        parseInclude(\n            nameProgram,\n            namespace,\n            functions,\n            constants,\n            macros,\n            runProgram\n        );\n        return;\n    }\n    const name = nameProgram.toText();\n    if (namespace.has(name)) {\n        throw new Error(`Symbol ${JSON.stringify(name)} redefined.`);\n    }\n    namespace.add(name);\n    if (op === 'defmacro') {\n        macros.push(declarationProgram);\n    } else if (op === 'defun') {\n        functions[name] = declarationProgram.rest.rest;\n    } else if (op === 'defun-inline') {\n        macros.push(defunInlineToMacro(declarationProgram));\n    } else if (op === 'defconstant') {\n        constants[name] = quoteAsProgram(declarationProgram.rest.rest.first);\n    } else {\n        throw new Error(\n            `Expected \"defun\", \"defun-inline\", \"defmacro\", or \"defconstant\", but got ${JSON.stringify(\n                op\n            )}.`\n        );\n    }\n}\n\nexport function compileModStage1(\n    args: Program,\n    runProgram: Eval\n): [functions: Group, constants: Group, macros: Program[]] {\n    const functions: Group = {};\n    const constants: Group = {};\n    const macros: Array<Program> = [];\n    const mainLocalArguments = args.first;\n    const namespace = new BetterSet<string>();\n    while (true) {\n        args = args.rest;\n        if (args.rest.isNull) break;\n        parseModProgram(\n            args.first,\n            namespace,\n            functions,\n            constants,\n            macros,\n            runProgram\n        );\n    }\n    const uncompiledMain = args.first;\n    functions[mainName] = Program.fromList([\n        mainLocalArguments,\n        uncompiledMain,\n    ]);\n    return [functions, constants, macros];\n}\n\nexport function symbolTableForTree(tree: Program, rootNode: NodePath): Program {\n    if (tree.isNull) return Program.nil;\n    else if (!tree.isCons)\n        return Program.fromList([\n            Program.fromList([tree, Program.fromBytes(rootNode.asPath())]),\n        ]);\n    const left = symbolTableForTree(tree.first, rootNode.add(NodePath.left));\n    const right = symbolTableForTree(tree.rest, rootNode.add(NodePath.right));\n    return Program.fromList([...left.toList(), ...right.toList()]);\n}\n\nexport function buildMacroLookupProgram(\n    macroLookup: Program,\n    macros: Program[],\n    runProgram: Eval\n): Program {\n    let macroLookupProgram = quoteAsProgram(macroLookup);\n    for (const macro of macros) {\n        macroLookupProgram = evalAsProgram(\n            Program.fromList([\n                Program.fromText('opt'),\n                Program.fromList([\n                    Program.fromText('com'),\n                    quoteAsProgram(\n                        Program.fromList([\n                            Program.fromBytes(consAtom),\n                            macro,\n                            macroLookupProgram,\n                        ])\n                    ),\n                    macroLookupProgram,\n                ]),\n            ]),\n            Program.fromBytes(NodePath.top.asPath())\n        );\n        macroLookupProgram = optimizeProgram(macroLookupProgram, runProgram);\n    }\n    return macroLookupProgram;\n}\n\nexport function compileFunctions(\n    functions: Group,\n    macroLookupProgram: Program,\n    constantSymbolTable: Program,\n    argsRootNode: NodePath\n): Group {\n    const compiledFunctions: Group = {};\n    for (const [name, lambdaExpression] of Object.entries(functions)) {\n        const localSymbolTable = symbolTableForTree(\n            lambdaExpression.first,\n            argsRootNode\n        );\n        const allSymbols = Program.fromList([\n            ...localSymbolTable.toList(),\n            ...constantSymbolTable.toList(),\n        ]);\n        compiledFunctions[name] = Program.fromList([\n            Program.fromText('opt'),\n            Program.fromList([\n                Program.fromText('com'),\n                quoteAsProgram(lambdaExpression.rest.first),\n                macroLookupProgram,\n                quoteAsProgram(allSymbols),\n            ]),\n        ]);\n    }\n    return compiledFunctions;\n}\n\nexport function compileMod(\n    args: Program,\n    macroLookup: Program,\n    _symbolTable: Program,\n    runProgram: Eval\n): Program {\n    const [functions, constants, macros] = compileModStage1(args, runProgram);\n    const macroLookupProgram = buildMacroLookupProgram(\n        macroLookup,\n        macros,\n        runProgram\n    );\n    const allConstantNames = buildUsedConstantNames(\n        functions,\n        constants,\n        macros\n    );\n    const hasConstantTree = allConstantNames.size > 0;\n    const constantTree = buildTree([\n        ...allConstantNames.map((item) => Program.fromText(item)),\n    ]);\n    const constantRootNode = NodePath.left;\n    const argsRootNode = hasConstantTree ? NodePath.right : NodePath.top;\n    const constantSymbolTable = symbolTableForTree(\n        constantTree,\n        constantRootNode\n    );\n    const compiledFunctions = compileFunctions(\n        functions,\n        macroLookupProgram,\n        constantSymbolTable,\n        argsRootNode\n    );\n    const mainPathSource = compiledFunctions[mainName].toString();\n    let argTreeSource: string;\n    if (hasConstantTree) {\n        const allConstantsLookup: Group = {};\n        for (const [key, value] of Object.entries(compiledFunctions))\n            if (allConstantNames.has(key)) allConstantsLookup[key] = value;\n        Object.assign(allConstantsLookup, constants);\n        const allConstantsList = [...allConstantNames].map(\n            (item) => allConstantsLookup[item]\n        );\n        const allConstantsTreeProgram = buildTreeProgram(allConstantsList);\n        const allConstantsTreeSource = allConstantsTreeProgram.toString();\n        argTreeSource = `(c ${allConstantsTreeSource} 1)`;\n    } else {\n        argTreeSource = '1';\n    }\n    return Program.fromSource(\n        `(opt (q . (a ${mainPathSource} ${argTreeSource})))`\n    );\n}\n","export function compareStrings(a: string, b: string): number {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import { bytesEqual } from 'chia-bls';\nimport { quoteAtom, raiseAtom } from '../constants/atoms';\nimport { keywords } from '../constants/keywords';\nimport { NodePath } from '../types/NodePath';\nimport { Program } from '../types/Program';\nimport { Eval, quoteAsProgram } from './helpers';\nimport { match } from './match';\nimport { Operator } from './operators';\n\nexport function seemsConstant(program: Program): boolean {\n    if (!program.isCons) return program.isNull;\n    const operator = program.first;\n    if (!operator.isCons) {\n        const value = operator.atom;\n        if (bytesEqual(value, quoteAtom)) return true;\n        else if (bytesEqual(value, raiseAtom)) return false;\n    } else if (!seemsConstant(operator)) return false;\n    return program.rest.toList().every((item) => seemsConstant(item));\n}\n\nexport function constantOptimizer(\n    program: Program,\n    evalAsProgram: Eval\n): Program {\n    if (seemsConstant(program) && !program.isNull) {\n        const newProgram = evalAsProgram(program, Program.nil).value;\n        program = quoteAsProgram(newProgram);\n    }\n    return program;\n}\n\nexport function isArgsCall(program: Program): boolean {\n    return program.isAtom && program.toBigInt() === 1n;\n}\n\nexport function consQuoteApplyOptimizer(\n    program: Program,\n    _evalAsProgram: Eval\n): Program {\n    const matched = match(\n        Program.fromSource('(a (q . (: . sexp)) (: . args))'),\n        program\n    );\n    if (matched && isArgsCall(matched['args'])) {\n        return matched['sexp'];\n    }\n    return program;\n}\n\nexport function consFirst(args: Program): Program {\n    const matched = match(\n        Program.fromSource('(c (: . first) (: . rest))'),\n        args\n    );\n    if (matched) {\n        return matched['first'];\n    }\n    return Program.fromList([Program.fromBigInt(keywords['f']), args]);\n}\n\nexport function consRest(args: Program): Program {\n    const matched = match(\n        Program.fromSource('(c (: . first) (: . rest))'),\n        args\n    );\n    if (matched) {\n        return matched['rest'];\n    }\n    return Program.fromList([Program.fromBigInt(keywords['r']), args]);\n}\n\nexport function pathFromArgs(program: Program, args: Program): Program {\n    const value = program.toBigInt();\n    if (value <= 1n) {\n        return args;\n    }\n    program = Program.fromBigInt(value >> 1n);\n    if (value & 1n) {\n        return pathFromArgs(program, consRest(args));\n    }\n    return pathFromArgs(program, consFirst(args));\n}\n\nexport function subArgs(program: Program, args: Program): Program {\n    if (!program.isCons) {\n        return pathFromArgs(program, args);\n    }\n    let first = program.first;\n    if (first.isCons) first = subArgs(first, args);\n    else if (bytesEqual(first.atom, quoteAtom)) {\n        return program;\n    }\n    return Program.fromList([\n        first,\n        ...program.rest.toList().map((item) => subArgs(item, args)),\n    ]);\n}\n\nexport function varChangeOptimizerConsEval(\n    program: Program,\n    evalAsProgram: Eval\n): Program {\n    const matched = match(\n        Program.fromSource('(a (q . (: . sexp)) (: . args))'),\n        program\n    );\n    if (!matched) {\n        return program;\n    }\n    const originalArgs = matched['args'];\n    const originalCall = matched['sexp'];\n    const newEvalProgramArgs = subArgs(originalCall, originalArgs);\n    if (seemsConstant(newEvalProgramArgs)) {\n        return optimizeProgram(newEvalProgramArgs, evalAsProgram);\n    }\n    const newOperands = newEvalProgramArgs.toList();\n    const optOperands = newOperands.map((item) =>\n        optimizeProgram(item, evalAsProgram)\n    );\n    const nonConstantCount = optOperands.filter(\n        (item) =>\n            item.isCons &&\n            (item.first.isCons || !bytesEqual(item.first.atom, quoteAtom))\n    ).length;\n    if (nonConstantCount < 1) {\n        return Program.fromList(optOperands);\n    }\n    return program;\n}\n\nexport function childrenOptimizer(\n    program: Program,\n    evalAsProgram: Eval\n): Program {\n    if (!program.isCons) {\n        return program;\n    }\n    const operator = program.first;\n    if (operator.isAtom && bytesEqual(operator.atom, quoteAtom)) {\n        return program;\n    }\n    return Program.fromList(\n        program.toList().map((item) => optimizeProgram(item, evalAsProgram))\n    );\n}\n\nexport function consOptimizer(program: Program, _evalAsProgram: Eval): Program {\n    let matched = match(\n        Program.fromSource('(f (c (: . first) (: . rest)))'),\n        program\n    );\n    if (matched) {\n        return matched['first'];\n    }\n    matched = match(\n        Program.fromSource('(r (c (: . first) (: . rest)))'),\n        program\n    );\n    if (matched) {\n        return matched['rest'];\n    }\n    return program;\n}\n\nexport function pathOptimizer(program: Program, _evalAsProgram: Eval): Program {\n    let matched = match(Program.fromSource('(f ($ . atom))'), program);\n    if (matched && !matched['atom'].isNull) {\n        const node = new NodePath(matched['atom'].toBigInt()).add(\n            NodePath.left\n        );\n        return Program.fromBytes(node.asPath());\n    }\n    matched = match(Program.fromSource('(r ($ . atom))'), program);\n    if (matched && !matched['atom'].isNull) {\n        const node = new NodePath(matched['atom'].toBigInt()).add(\n            NodePath.right\n        );\n        return Program.fromBytes(node.asPath());\n    }\n    return program;\n}\n\nexport function quoteNullOptimizer(\n    program: Program,\n    _evalAsProgram: Eval\n): Program {\n    const matched = match(Program.fromSource('(q . 0)'), program);\n    if (matched) {\n        return Program.nil;\n    }\n    return program;\n}\n\nexport function applyNullOptimizer(\n    program: Program,\n    _evalAsProgram: Eval\n): Program {\n    const matched = match(Program.fromSource('(a 0 . (: . rest))'), program);\n    if (matched) {\n        return Program.nil;\n    }\n    return program;\n}\n\nexport function optimizeProgram(\n    program: Program,\n    evalAsProgram: Eval\n): Program {\n    if (program.isAtom) {\n        return program;\n    }\n    const optimizers = [\n        consOptimizer,\n        constantOptimizer,\n        consQuoteApplyOptimizer,\n        varChangeOptimizerConsEval,\n        childrenOptimizer,\n        pathOptimizer,\n        quoteNullOptimizer,\n        applyNullOptimizer,\n    ];\n    while (program.isCons) {\n        const startProgram = program;\n        for (const optimizer of optimizers) {\n            program = optimizer(program, evalAsProgram);\n            if (!startProgram.equals(program)) break;\n        }\n        if (startProgram.equals(program)) {\n            return program;\n        }\n    }\n    return program;\n}\n\nexport function makeDoOpt(runProgram: Eval): Operator {\n    return (args) => {\n        return {\n            value: optimizeProgram(args.first, runProgram),\n            cost: 1n,\n        };\n    };\n}\n","import { bytesEqual } from 'chia-bls';\nimport { Program } from '../index';\nimport { Group } from './helpers';\n\nconst atomMatch = new TextEncoder().encode('$');\nconst sexpMatch = new TextEncoder().encode(':');\n\nexport function unifyBindings(\n    bindings: Group,\n    key: string,\n    valueProgram: Program\n): Group | null {\n    if (key in bindings) {\n        if (!bindings[key].equals(valueProgram)) return null;\n        return bindings;\n    }\n    return { ...bindings, [key]: valueProgram };\n}\n\nexport function match(\n    pattern: Program,\n    sexp: Program,\n    knownBindings: Group = {}\n): Group | null {\n    if (!pattern.isCons) {\n        if (sexp.isCons) return null;\n        return bytesEqual(pattern.atom, sexp.atom) ? knownBindings : null;\n    }\n    const left = pattern.first;\n    const right = pattern.rest;\n    if (left.isAtom && bytesEqual(left.atom, atomMatch)) {\n        if (sexp.isCons) return null;\n        if (right.isAtom && bytesEqual(right.atom, atomMatch)) {\n            if (bytesEqual(sexp.atom, atomMatch)) return {};\n            return null;\n        }\n        return unifyBindings(knownBindings, right.toText(), sexp);\n    }\n    if (left.isAtom && bytesEqual(left.atom, sexpMatch)) {\n        if (right.isAtom && bytesEqual(right.atom, sexpMatch)) {\n            if (bytesEqual(sexp.atom, sexpMatch)) return {};\n            return null;\n        }\n        return unifyBindings(knownBindings, right.toText(), sexp);\n    }\n    if (!sexp.isCons) return null;\n    const newBindings = match(left, sexp.first, knownBindings);\n    if (!newBindings) return newBindings;\n    return match(right, sexp.rest, newBindings);\n}\n","import { bytesEqual } from 'chia-bls';\nimport { applyAtom, quoteAtom } from '../constants/atoms';\nimport { costs } from '../constants/costs';\nimport { Instruction, Program } from '../types/Program';\nimport { traversePath } from './environment';\nimport { runOperator } from './operators';\n\nexport const instructions = {\n    swap: ((_instructionStack, stack, _options) => {\n        const second = stack.pop()!;\n        const first = stack.pop()!;\n        stack.push(second, first);\n        return 0n;\n    }) as Instruction,\n    cons: ((_instructionStack, stack, _options) => {\n        const first = stack.pop()!;\n        const second = stack.pop()!;\n        stack.push(Program.cons(first, second));\n        return 0n;\n    }) as Instruction,\n    eval: ((instructionStack, stack, _options) => {\n        const pair = stack.pop()!;\n        const program = pair.first;\n        const args = pair.rest;\n        if (program.isAtom) {\n            const output = traversePath(program, args);\n            stack.push(output.value);\n            return output.cost;\n        }\n        const op = program.first;\n        if (op.isCons) {\n            const [newOperator, mustBeNil] = op.cons;\n            if (newOperator.isCons || !mustBeNil.isNull)\n                throw new Error(\n                    `Operators that are lists must contain a single atom${op.positionSuffix}.`\n                );\n            const newOperandList = program.rest;\n            stack.push(newOperator, newOperandList);\n            instructionStack.push(instructions.apply);\n            return costs.apply;\n        }\n        let operandList = program.rest;\n        if (bytesEqual(op.atom, quoteAtom)) {\n            stack.push(operandList);\n            return costs.quote;\n        }\n        instructionStack.push(instructions.apply);\n        stack.push(op);\n        while (!operandList.isNull) {\n            stack.push(Program.cons(operandList.first, args));\n            instructionStack.push(\n                instructions.cons,\n                instructions.eval,\n                instructions.swap\n            );\n            operandList = operandList.rest;\n        }\n        stack.push(Program.nil);\n        return 1n;\n    }) as Instruction,\n    apply: ((instructionStack, stack, options) => {\n        const operandList = stack.pop()!;\n        const op = stack.pop()!;\n        if (op.isCons)\n            throw new Error(`An internal error occurred${op.positionSuffix}.`);\n        if (bytesEqual(op.atom, applyAtom)) {\n            const args = operandList.toList();\n            if (args.length !== 2)\n                throw new Error(\n                    `Expected 2 arguments in \"a\" operator${operandList.positionSuffix}.`\n                );\n            stack.push(Program.cons(args[0], args[1]));\n            instructionStack.push(instructions.eval);\n            return costs.apply;\n        }\n        const output = runOperator(op, operandList, options);\n        stack.push(output.value);\n        return output.cost;\n    }) as Instruction,\n};\n","export const costs = {\n    if: 33n,\n    cons: 50n,\n    first: 30n,\n    rest: 30n,\n    listp: 19n,\n    mallocPerByte: 10n,\n    arithBase: 99n,\n    arithPerByte: 3n,\n    arithPerArg: 320n,\n    logBase: 100n,\n    logPerByte: 3n,\n    logPerArg: 264n,\n    grsBase: 117n,\n    grsPerByte: 1n,\n    eqBase: 117n,\n    eqPerByte: 1n,\n    grBase: 498n,\n    grPerByte: 2n,\n    divmodBase: 1116n,\n    divmodPerByte: 6n,\n    divBase: 988n,\n    divPerByte: 4n,\n    sha256Base: 87n,\n    sha256PerByte: 2n,\n    sha256PerArg: 134n,\n    pointAddBase: 101094n,\n    pointAddPerArg: 1343980n,\n    pubkeyBase: 1325730n,\n    pubkeyPerByte: 38n,\n    mulBase: 92n,\n    mulPerOp: 885n,\n    mulLinearPerByte: 6n,\n    mulSquarePerByteDivider: 128n,\n    strlenBase: 173n,\n    strlenPerByte: 1n,\n    pathLookupBase: 40n,\n    pathLookupPerLeg: 4n,\n    pathLookupPerZeroByte: 4n,\n    concatBase: 142n,\n    concatPerByte: 3n,\n    concatPerArg: 135n,\n    boolBase: 200n,\n    boolPerArg: 300n,\n    ashiftBase: 596n,\n    ashiftPerByte: 3n,\n    lshiftBase: 277n,\n    lshiftPerByte: 3n,\n    lognotBase: 331n,\n    lognotPerByte: 3n,\n    apply: 90n,\n    quote: 20n,\n};\n","import { costs } from '../constants/costs';\nimport { Program, ProgramOutput } from '../types/Program';\n\nexport function msbMask(byte: number): number {\n    byte |= byte >> 1;\n    byte |= byte >> 2;\n    byte |= byte >> 4;\n    return (byte + 1) >> 1;\n}\n\nexport function traversePath(\n    value: Program,\n    environment: Program\n): ProgramOutput {\n    let cost = costs.pathLookupBase + costs.pathLookupPerLeg;\n    if (value.isNull) return { value: Program.nil, cost };\n    let endByteCursor = 0;\n    const atom = value.atom;\n    while (endByteCursor < atom.length && atom[endByteCursor] === 0)\n        endByteCursor++;\n    cost += BigInt(endByteCursor) * costs.pathLookupPerZeroByte;\n    if (endByteCursor === atom.length) return { value: Program.nil, cost };\n    const endBitMask = msbMask(atom[endByteCursor]);\n    let byteCursor = atom.length - 1;\n    let bitMask = 0x01;\n    while (byteCursor > endByteCursor || bitMask < endBitMask) {\n        if (environment.isAtom)\n            throw new Error(\n                `Cannot traverse into ${environment}${environment.positionSuffix}.`\n            );\n        if ((atom[byteCursor] & bitMask) !== 0) environment = environment.rest;\n        else environment = environment.first;\n        cost += costs.pathLookupPerLeg;\n        bitMask <<= 1;\n        if (bitMask === 0x100) {\n            byteCursor--;\n            bitMask = 0x01;\n        }\n    }\n    return { value: environment, cost };\n}\n","import {\n    bigIntToBytes,\n    bytesEqual,\n    bytesToBigInt,\n    bytesToInt,\n    defaultEc,\n    hash256,\n    JacobianPoint,\n    mod,\n    PrivateKey,\n} from 'chia-bls';\nimport { costs } from '../constants/costs';\nimport { keywords } from '../constants/keywords';\nimport { Program, ProgramOutput, RunOptions } from '../types/Program';\n\nexport type Operator = (args: Program) => ProgramOutput;\n\nexport interface Operators {\n    operators: Record<string, Operator>;\n    unknown: (operator: Program, args: Program) => ProgramOutput;\n    quote: string;\n    apply: string;\n}\n\nexport const operators = {\n    i: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'i', 3);\n        return { value: list[0].isNull ? list[2] : list[1], cost: costs.if };\n    }) as Operator,\n    c: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'c', 2);\n        return { value: Program.cons(list[0], list[1]), cost: costs.cons };\n    }) as Operator,\n    f: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'f', 1, 'cons');\n        return { value: list[0].first, cost: costs.first };\n    }) as Operator,\n    r: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'r', 1, 'cons');\n        return { value: list[0].rest, cost: costs.rest };\n    }) as Operator,\n    l: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'l', 1);\n        return { value: Program.fromBool(list[0].isCons), cost: costs.listp };\n    }) as Operator,\n    x: ((args: Program): ProgramOutput => {\n        throw new Error(`The error ${args} was raised${args.positionSuffix}.`);\n    }) as Operator,\n    '=': ((args: Program): ProgramOutput => {\n        const list = toList(args, '=', 2, 'atom');\n        return {\n            value: Program.fromBool(bytesEqual(list[0].atom, list[1].atom)),\n            cost:\n                costs.eqBase +\n                (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) *\n                    costs.eqPerByte,\n        };\n    }) as Operator,\n    sha256: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'sha256', undefined, 'atom');\n        let cost = costs.sha256Base;\n        let argLength = 0;\n        const bytes: Array<number> = [];\n        for (const item of list) {\n            for (const byte of item.atom) bytes.push(byte);\n            argLength += item.atom.length;\n            cost += costs.sha256PerArg;\n        }\n        cost += BigInt(argLength) * costs.sha256PerByte;\n        return mallocCost({\n            value: Program.fromBytes(hash256(Uint8Array.from(bytes))),\n            cost,\n        });\n    }) as Operator,\n    '+': ((args: Program): ProgramOutput => {\n        const list = toList(args, '+', undefined, 'atom');\n        let total = 0n;\n        let cost = costs.arithBase;\n        let argSize = 0;\n        for (const item of list) {\n            total += item.toBigInt();\n            argSize += item.atom.length;\n            cost += costs.arithPerArg;\n        }\n        cost += BigInt(argSize) * costs.arithPerByte;\n        return mallocCost({ value: Program.fromBigInt(total), cost });\n    }) as Operator,\n    '-': ((args: Program): ProgramOutput => {\n        let cost = costs.arithBase;\n        if (args.isNull) return { value: Program.nil, cost: cost };\n        const list = toList(args, '-', undefined, 'atom');\n        let total = 0n;\n        let sign = 1n;\n        let argSize = 0;\n        for (const item of list) {\n            total += sign * item.toBigInt();\n            sign = -1n;\n            argSize += item.atom.length;\n            cost += costs.arithPerArg;\n        }\n        cost += BigInt(argSize) * costs.arithPerByte;\n        return mallocCost({ value: Program.fromBigInt(total), cost });\n    }) as Operator,\n    '*': ((args: Program): ProgramOutput => {\n        const list = toList(args, '*', undefined, 'atom');\n        let cost = costs.mulBase;\n        if (!list.length) return mallocCost({ value: Program.true, cost });\n        let value = list[0].toBigInt();\n        let size = list[0].atom.length;\n        for (const item of list.slice(1)) {\n            cost +=\n                costs.mulPerOp +\n                (BigInt(item.atom.length) + BigInt(size)) *\n                    costs.mulLinearPerByte +\n                (BigInt(item.atom.length) * BigInt(size)) /\n                    costs.mulSquarePerByteDivider;\n            value *= item.toBigInt();\n            size = limbsForBigInt(value);\n        }\n        return mallocCost({ value: Program.fromBigInt(value), cost });\n    }) as Operator,\n    divmod: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'divmod', 2, 'atom');\n        let cost = costs.divmodBase;\n        const numerator = list[0].toBigInt();\n        const denominator = list[1].toBigInt();\n        if (denominator === 0n)\n            throw new Error(\n                `Cannot divide by zero in \"divmod\" operator${args.positionSuffix}.`\n            );\n        cost +=\n            (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) *\n            costs.divmodPerByte;\n        let quotientValue = numerator / denominator;\n        const remainderValue = mod(numerator, denominator);\n        if (numerator < 0n !== denominator < 0n && remainderValue !== 0n)\n            quotientValue -= 1n;\n        const quotient = Program.fromBigInt(quotientValue);\n        const remainder = Program.fromBigInt(remainderValue);\n        cost +=\n            (BigInt(quotient.atom.length) + BigInt(remainder.atom.length)) *\n            costs.mallocPerByte;\n        return { value: Program.cons(quotient, remainder), cost };\n    }) as Operator,\n    '/': ((args: Program): ProgramOutput => {\n        const list = toList(args, '/', 2, 'atom');\n        let cost = costs.divBase;\n        const numerator = list[0].toBigInt();\n        const denominator = list[1].toBigInt();\n        if (denominator === 0n)\n            throw new Error(\n                `Cannot divide by zero in \"/\" operator${args.positionSuffix}.`\n            );\n        cost +=\n            (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) *\n            costs.divPerByte;\n        let quotientValue = numerator / denominator;\n        const remainderValue = mod(numerator, denominator);\n        if (numerator < 0n !== denominator < 0n && quotientValue < 0n)\n            quotientValue -= 1n;\n        const quotient = Program.fromBigInt(quotientValue);\n        return mallocCost({ value: quotient, cost });\n    }) as Operator,\n    '>': ((args: Program): ProgramOutput => {\n        const list = toList(args, '>', 2, 'atom');\n        const cost =\n            costs.grBase +\n            (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) *\n                costs.grPerByte;\n        return {\n            value: Program.fromBool(list[0].toBigInt() > list[1].toBigInt()),\n            cost,\n        };\n    }) as Operator,\n    '>s': ((args: Program): ProgramOutput => {\n        const list = toList(args, '>s', 2, 'atom');\n        const cost =\n            costs.grsBase +\n            (BigInt(list[0].atom.length) + BigInt(list[1].atom.length)) *\n                costs.grsPerByte;\n        return {\n            value: Program.fromBool(\n                list[0].toHex().localeCompare(list[1].toHex()) === 1\n            ),\n            cost,\n        };\n    }) as Operator,\n    pubkey_for_exp: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'pubkey_for_exp', 1, 'atom');\n        const value = mod(list[0].toBigInt(), defaultEc.n);\n        const exponent = PrivateKey.fromBytes(bigIntToBytes(value, 32, 'big'));\n        const cost =\n            costs.pubkeyBase +\n            BigInt(list[0].atom.length) * costs.pubkeyPerByte;\n        return mallocCost({\n            value: Program.fromBytes(exponent.getG1().toBytes()),\n            cost,\n        });\n    }) as Operator,\n    point_add: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'point_add', undefined, 'atom');\n        let cost = costs.pointAddBase;\n        let point = JacobianPoint.infinityG1();\n        for (const item of list) {\n            point = point.add(JacobianPoint.fromBytes(item.atom, false));\n            cost += costs.pointAddPerArg;\n        }\n        return mallocCost({ value: Program.fromBytes(point.toBytes()), cost });\n    }) as Operator,\n    strlen: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'strlen', 1, 'atom');\n        const size = list[0].atom.length;\n        const cost = costs.strlenBase + BigInt(size) * costs.strlenPerByte;\n        return mallocCost({ value: Program.fromInt(size), cost });\n    }) as Operator,\n    substr: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'substr', [2, 3], 'atom');\n        const value = list[0].atom;\n        if (\n            list[1].atom.length > 4 ||\n            (list.length === 3 && list[2].atom.length > 4)\n        )\n            throw new Error(\n                `Expected 4 byte indices in \"substr\" operator${args.positionSuffix}.`\n            );\n        const from = list[1].toInt();\n        const to = list.length === 3 ? list[2].toInt() : value.length;\n        if (to > value.length || to < from || to < 0 || from < 0)\n            throw new Error(\n                `Invalid indices in \"substr\" operator${args.positionSuffix}.`\n            );\n        return { value: Program.fromBytes(value.slice(from, to)), cost: 1n };\n    }) as Operator,\n    concat: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'concat', undefined, 'atom');\n        let cost = costs.concatBase;\n        const bytes: Array<number> = [];\n        for (const item of list) {\n            for (const byte of item.atom) bytes.push(byte);\n            cost += costs.concatPerArg;\n        }\n        cost += BigInt(bytes.length) * costs.concatPerByte;\n        return mallocCost({\n            value: Program.fromBytes(Uint8Array.from(bytes)),\n            cost,\n        });\n    }) as Operator,\n    ash: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'ash', 2, 'atom');\n        if (list[1].atom.length > 4)\n            throw new Error(\n                `Shift must be 32 bits in \"ash\" operator${args.positionSuffix}.`\n            );\n        const shift = list[1].toBigInt();\n        if ((shift < 0n ? -shift : shift) > 65535n)\n            throw new Error(\n                `Shift too large in \"ash\" operator${args.positionSuffix}.`\n            );\n        let value = list[0].toBigInt();\n        if (shift >= 0) value <<= shift;\n        else value >>= -shift;\n        const cost =\n            costs.ashiftBase +\n            (BigInt(list[0].atom.length) + BigInt(limbsForBigInt(value))) *\n                costs.ashiftPerByte;\n        return mallocCost({ value: Program.fromBigInt(value), cost });\n    }) as Operator,\n    lsh: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'lsh', 2, 'atom');\n        if (list[1].atom.length > 4)\n            throw new Error(\n                `Shift must be 32 bits in \"lsh\" operator${args.positionSuffix}.`\n            );\n        const shift = list[1].toBigInt();\n        if ((shift < 0n ? -shift : shift) > 65535n)\n            throw new Error(\n                `Shift too large in \"lsh\" operator${args.positionSuffix}.`\n            );\n        let value = bytesToBigInt(list[0].atom, 'big', false);\n        if (value < 0n) value = -value;\n        if (shift >= 0) value <<= shift;\n        else value >>= -shift;\n        const cost =\n            costs.lshiftBase +\n            (BigInt(list[0].atom.length) + BigInt(limbsForBigInt(value))) *\n                costs.lshiftPerByte;\n        return mallocCost({ value: Program.fromBigInt(value), cost });\n    }) as Operator,\n    logand: ((args: Program): ProgramOutput =>\n        binopReduction('logand', -1n, args, (a, b) => a & b)) as Operator,\n    logior: ((args: Program): ProgramOutput =>\n        binopReduction('logior', 0n, args, (a, b) => a | b)) as Operator,\n    logxor: ((args: Program): ProgramOutput =>\n        binopReduction('logxor', 0n, args, (a, b) => a ^ b)) as Operator,\n    lognot: ((args: Program): ProgramOutput => {\n        const items = toList(args, 'lognot', 1, 'atom');\n        const cost =\n            costs.lognotBase +\n            BigInt(items[0].atom.length) * costs.lognotPerByte;\n        return mallocCost({\n            value: Program.fromBigInt(~items[0].toBigInt()),\n            cost,\n        });\n    }) as Operator,\n    not: ((args: Program): ProgramOutput => {\n        const items = toList(args, 'not', 1);\n        const cost = costs.boolBase;\n        return { value: Program.fromBool(items[0].isNull), cost: cost };\n    }) as Operator,\n    any: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'any');\n        const cost = costs.boolBase + BigInt(list.length) * costs.boolPerArg;\n        let result = false;\n        for (const item of list) {\n            if (!item.isNull) {\n                result = true;\n                break;\n            }\n        }\n        return { value: Program.fromBool(result), cost: cost };\n    }) as Operator,\n    all: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'all');\n        const cost = costs.boolBase + BigInt(list.length) * costs.boolPerArg;\n        let result = true;\n        for (const item of list) {\n            if (item.isNull) {\n                result = false;\n                break;\n            }\n        }\n        return { value: Program.fromBool(result), cost: cost };\n    }) as Operator,\n    softfork: ((args: Program): ProgramOutput => {\n        const list = toList(args, 'softfork', [1, Infinity]);\n        if (!list[0].isAtom)\n            throw new Error(\n                `Expected atom argument in \"softfork\" operator at ${list[0].positionSuffix}.`\n            );\n        const cost = list[0].toBigInt();\n        if (cost < 1n)\n            throw new Error(\n                `Cost must be greater than zero in \"softfork\" operator${args.positionSuffix}.`\n            );\n        return { value: Program.false, cost: cost };\n    }) as Operator,\n};\n\nexport const defaultOperators = {\n    operators,\n    unknown: defaultUnknownOperator,\n    quote: 'q',\n    apply: 'a',\n};\n\nexport function makeDefaultOperators() {\n    return {\n        ...defaultOperators,\n        operators: { ...defaultOperators.operators },\n    };\n}\n\nexport function toList(\n    program: Program,\n    name: string,\n    length?: [number, number] | number,\n    type?: 'atom' | 'cons'\n): Program[] {\n    const list = program.toList();\n    if (typeof length === 'number' && list.length !== length)\n        throw new Error(\n            `Expected ${length} arguments in ${JSON.stringify(name)} operator${\n                program.positionSuffix\n            }.`\n        );\n    else if (\n        Array.isArray(length) &&\n        (list.length < length[0] || list.length > length[1])\n    )\n        throw new Error(\n            `Expected ${\n                length[1] === Infinity\n                    ? `at least ${length[0]}`\n                    : `between ${length[0]} and ${length[1]}`\n            } arguments in ${JSON.stringify(name)} operator${\n                program.positionSuffix\n            }.`\n        );\n    if (type !== undefined)\n        list.forEach((item) => {\n            if (\n                (type === 'atom' && !item.isAtom) ||\n                (type === 'cons' && !item.isCons)\n            )\n                throw new Error(\n                    `Expected ${type} argument in ${JSON.stringify(\n                        name\n                    )} operator${item.positionSuffix}.`\n                );\n        });\n    return list;\n}\n\nexport function limbsForBigInt(value: bigint): number {\n    let length =\n        value === 0n ? 0 : (value < 0n ? -value : value).toString(2).length;\n    if (value < 0n) length++;\n    return (length + 7) >> 3;\n}\n\nexport function mallocCost(output: ProgramOutput): ProgramOutput {\n    return {\n        value: output.value,\n        cost:\n            output.cost +\n            BigInt(output.value.atom.length) * costs.mallocPerByte,\n    };\n}\n\nexport function binopReduction(\n    opName: string,\n    initialValue: bigint,\n    args: Program,\n    opFunction: (a: bigint, b: bigint) => bigint\n): ProgramOutput {\n    let total = initialValue;\n    let argSize = 0;\n    let cost = costs.logBase;\n    for (const item of args.toList().map((item) => {\n        if (!item.isAtom)\n            throw new Error(\n                `Expected atom argument in ${JSON.stringify(opName)} operator${\n                    item.positionSuffix\n                }.`\n            );\n        return item;\n    })) {\n        total = opFunction(total, item.toBigInt());\n        argSize += item.atom.length;\n        cost += costs.logPerArg;\n    }\n    cost += BigInt(argSize) * costs.logPerByte;\n    return mallocCost({ value: Program.fromBigInt(total), cost });\n}\n\nexport function defaultUnknownOperator(\n    op: Program,\n    args: Program\n): ProgramOutput {\n    if (\n        !op.atom.length ||\n        bytesEqual(op.atom.slice(0, 2), Uint8Array.from([0xff, 0xff]))\n    )\n        throw new Error(`Reserved operator${op.positionSuffix}.`);\n    if (op.atom.length > 5)\n        throw new Error(`Invalid operator${op.positionSuffix}.`);\n    const costFunction = (op.atom[op.atom.length - 1] & 0xc0) >> 6;\n    const costMultiplier =\n        bytesToInt(op.atom.slice(0, op.atom.length - 1), 'big') + 1;\n    let cost: bigint;\n    if (costFunction === 0) cost = 1n;\n    else if (costFunction === 1) {\n        cost = costs.arithBase;\n        let argSize = 0;\n        for (const item of args.toList()) {\n            if (!item.isAtom)\n                throw new Error(\n                    `Expected atom argument${item.positionSuffix}.`\n                );\n            argSize += item.atom.length;\n            cost += costs.arithPerArg;\n        }\n        cost += BigInt(argSize) * costs.arithPerByte;\n    } else if (costFunction === 2) {\n        cost = costs.mulBase;\n        const argList = args.toList();\n        if (argList.length) {\n            const first = argList[0];\n            if (!first.isAtom)\n                throw new Error(\n                    `Expected atom argument${first.positionSuffix}.`\n                );\n            let current = first.atom.length;\n            for (const item of argList.slice(1)) {\n                if (!item.isAtom)\n                    throw new Error(\n                        `Expected atom argument${item.positionSuffix}.`\n                    );\n                cost +=\n                    costs.mulPerOp +\n                    (BigInt(item.atom.length) + BigInt(current)) *\n                        costs.mulLinearPerByte +\n                    (BigInt(item.atom.length) * BigInt(current)) /\n                        costs.mulSquarePerByteDivider;\n                current += item.atom.length;\n            }\n        }\n    } else if (costFunction === 3) {\n        cost = costs.concatBase;\n        let length = 0;\n        for (const item of args.toList()) {\n            if (!item.isAtom)\n                throw new Error(\n                    `Expected atom argument${item.positionSuffix}.`\n                );\n            cost += costs.concatPerArg;\n            length += item.atom.length;\n        }\n        cost += BigInt(length) * costs.concatPerByte;\n    } else throw new Error(`Unknown cost function${op.positionSuffix}.`);\n    cost *= BigInt(costMultiplier);\n    if (cost >= 2n ** 32n)\n        throw new Error(`Invalid operator${op.positionSuffix}.`);\n    return { value: Program.nil, cost: cost };\n}\n\nexport function runOperator(\n    op: Program,\n    args: Program,\n    options: RunOptions\n): ProgramOutput {\n    const symbol = op.toBigInt();\n    const keyword =\n        Object.entries(keywords).find((entry) => entry[1] === symbol)?.[0] ??\n        op.toText();\n    if (keyword in options.operators.operators) {\n        const result = options.operators.operators[keyword](args);\n        return result;\n    } else return options.operators.unknown(op, args);\n}\n","import { decodeInt } from 'chia-bls';\nimport { ParserError } from '../types/ParserError';\nimport { Program } from '../types/Program';\n\nexport function deserialize(program: number[]): Program {\n    const sizeBytes: Array<number> = [];\n    if (program[0] <= 0x7f)\n        return Program.fromBytes(Uint8Array.from([program[0]]));\n    else if (program[0] <= 0xbf) sizeBytes.push(program[0] & 0x3f);\n    else if (program[0] <= 0xdf) {\n        sizeBytes.push(program[0] & 0x1f);\n        program.shift();\n        if (!program.length)\n            throw new ParserError('Expected next byte in source.');\n        sizeBytes.push(program[0]);\n    } else if (program[0] <= 0xef) {\n        sizeBytes.push(program[0] & 0x0f);\n        for (let i = 0; i < 2; i++) {\n            program.shift();\n            if (!program.length)\n                throw new ParserError('Expected next byte in source.');\n            sizeBytes.push(program[0]);\n        }\n    } else if (program[0] <= 0xf7) {\n        sizeBytes.push(program[0] & 0x07);\n        for (let i = 0; i < 3; i++) {\n            program.shift();\n            if (!program.length)\n                throw new ParserError('Expected next byte in source.');\n            sizeBytes.push(program[0]);\n        }\n    } else if (program[0] <= 0xfb) {\n        sizeBytes.push(program[0] & 0x03);\n        for (let i = 0; i < 4; i++) {\n            program.shift();\n            if (!program.length)\n                throw new ParserError('Expected next byte in source.');\n            sizeBytes.push(program[0]);\n        }\n    } else if (program[0] === 0xff) {\n        program.shift();\n        if (!program.length)\n            throw new ParserError('Expected next byte in source.');\n        const first = deserialize(program);\n        program.shift();\n        if (!program.length)\n            throw new ParserError('Expected next byte in source.');\n        const rest = deserialize(program);\n        return Program.cons(first, rest);\n    } else throw new ParserError('Invalid encoding.');\n    const size = decodeInt(Uint8Array.from(sizeBytes));\n    let bytes: Array<number> = [];\n    for (let i = 0; i < size; i++) {\n        program.shift();\n        if (!program.length) {\n            throw new ParserError('Expected next byte in atom.');\n        }\n        bytes.push(program[0]);\n    }\n    return Program.fromBytes(Uint8Array.from(bytes));\n}\n","import { keywords } from '../constants/keywords';\nimport { ParserError } from '../types/ParserError';\nimport { Position } from '../types/Position';\nimport { Program } from '../types/Program';\nimport { Token } from '../types/Token';\n\nexport function next(tokens: Token[]): Token | undefined {\n    tokens.shift();\n    return tokens[0];\n}\n\nexport function expect(source: string, tokens: Token[]): void {\n    const token = tokens[0];\n    if (!next(tokens))\n        throw new ParserError(\n            `Unexpected end of source at ${new Position(source, token.index)}.`\n        );\n}\n\nexport function isSpace(char: string): boolean {\n    return /^[\\u0020\\u202F\\u205F\\u2028\\u2029\\u3000\\u0085\\u1680\\u00A0\\u2000-\\u200A\\u0009-\\u000D\\u001C-\\u001F]$/.test(\n        char\n    );\n}\n\nexport function consumeWhitespace(text: string, index: number): number {\n    while (true) {\n        while (index < text.length && isSpace(text[index])) index++;\n        if (index >= text.length || text[index] !== ';') break;\n        while (index < text.length && !'\\n\\r'.includes(text[index])) index++;\n    }\n    return index;\n}\n\nexport function consumeUntilWhitespace(text: string, index: number): Token {\n    const start = index;\n    while (index < text.length && !isSpace(text[index]) && text[index] !== ')')\n        index++;\n    return { text: text.slice(start, index), index };\n}\n\nexport function tokenizeCons(source: string, tokens: Token[]): Program {\n    let token = tokens[0];\n    if (token.text === ')')\n        return Program.fromBytes(Uint8Array.from([])).at(\n            new Position(source, token.index)\n        );\n    const consStart = token.index;\n    const first = tokenizeExpr(source, tokens);\n    expect(source, tokens);\n    token = tokens[0];\n    let rest: Program;\n    if (token.text === '.') {\n        const dotStart = token.index;\n        expect(source, tokens);\n        token = tokens[0];\n        rest = tokenizeExpr(source, tokens);\n        expect(source, tokens);\n        token = tokens[0];\n        if (token.text !== ')')\n            throw new ParserError(\n                `Illegal dot expression at ${new Position(source, dotStart)}.`\n            );\n    } else rest = tokenizeCons(source, tokens);\n    return Program.cons(first, rest).at(new Position(source, consStart));\n}\n\nexport function tokenizeInt(source: string, token: Token): Program | null {\n    return /^[+\\-]?[0-9]+(?:_[0-9]+)*$/.test(token.text)\n        ? Program.fromBigInt(BigInt(token.text.replaceAll('_', ''))).at(\n              new Position(source, token.index)\n          )\n        : null;\n}\n\nexport function tokenizeHex(source: string, token: Token): Program | null {\n    if (\n        token.text.length >= 2 &&\n        token.text.slice(0, 2).toLowerCase() === '0x'\n    ) {\n        let hex = token.text.slice(2);\n        if (hex.length % 2 === 1) hex = `0${hex}`;\n        try {\n            return Program.fromHex(hex).at(new Position(source, token.index));\n        } catch (e) {\n            throw new ParserError(\n                `Invalid hex ${JSON.stringify(token.text)} at ${new Position(\n                    source,\n                    token.index\n                )}.`\n            );\n        }\n    } else return null;\n}\n\nexport function tokenizeQuotes(source: string, token: Token): Program | null {\n    if (token.text.length < 2) return null;\n    const quote = token.text[0];\n    if (!'\"\\''.includes(quote)) return null;\n    if (token.text[token.text.length - 1] !== quote)\n        throw new ParserError(\n            `Unterminated string ${JSON.stringify(\n                token.text\n            )} at ${new Position(source, token.index)}.`\n        );\n    return Program.fromText(token.text.slice(1, token.text.length - 1)).at(\n        new Position(source, token.index)\n    );\n}\n\nexport function tokenizeSymbol(source: string, token: Token): Program | null {\n    let text = token.text;\n    if (text.startsWith('#')) text = text.slice(1);\n    const keyword: bigint | undefined = keywords[text as keyof typeof keywords];\n    return (\n        keyword === undefined\n            ? Program.fromText(text)\n            : Program.fromBigInt(keyword)\n    ).at(new Position(source, token.index));\n}\n\nexport function tokenizeExpr(source: string, tokens: Token[]): Program {\n    const token = tokens[0];\n    if (token.text === '(') {\n        expect(source, tokens);\n        return tokenizeCons(source, tokens);\n    }\n    const result =\n        tokenizeInt(source, token) ??\n        tokenizeHex(source, token) ??\n        tokenizeQuotes(source, token) ??\n        tokenizeSymbol(source, token);\n    if (!result)\n        throw new ParserError(\n            `Invalid expression ${JSON.stringify(token.text)} at ${new Position(\n                source,\n                token.index\n            )}.`\n        );\n    return result;\n}\n\nexport function* tokenStream(source: string): IterableIterator<Token> {\n    let index = 0;\n    while (index < source.length) {\n        index = consumeWhitespace(source, index);\n        if (index >= source.length) break;\n        const char = source[index];\n        if ('(.)'.includes(char)) {\n            yield { text: char, index };\n            index++;\n            continue;\n        }\n        if ('\"\\''.includes(char)) {\n            const start = index;\n            const quote = source[index];\n            index++;\n            while (index < source.length && source[index] !== quote) index++;\n            if (index < source.length) {\n                yield { text: source.slice(start, index + 1), index: start };\n                index++;\n                continue;\n            } else\n                throw new ParserError(\n                    `Unterminated string at ${new Position(source, index)}.`\n                );\n        }\n        const token = consumeUntilWhitespace(source, index);\n        yield { text: token.text, index };\n        index = token.index;\n    }\n}\n","export class Position {\n    public line: number;\n    public column: number;\n\n    constructor(source: string, index: number) {\n        source = source.replaceAll('\\r\\n', '\\n');\n        let line = 1;\n        let column = 1;\n        for (let i = 0; i < index; i++) {\n            if (source[i] === '\\n') {\n                line++;\n                column = 1;\n            } else {\n                column++;\n            }\n        }\n        this.line = line;\n        this.column = column;\n    }\n\n    public toString(): string {\n        return `${this.line}:${this.column}`;\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;ACAO,MAAMA,yCAAA,SAAoBC,KAAA;EAC7BC,YAAYC,OAAe,EAAE;IACzB,KAAK,CAACA,OAAA;IACNC,MAAA,CAAOC,cAAc,CAAC,IAAI,EAAEL,yCAAA,CAAYM,SAAS;EACrD;AACJ;AELO,MAAMC,yCAAA,GAAW;EACpBC,CAAA,EAAG,KAAK;EACRC,CAAA,EAAG,KAAK;EACRC,CAAA,EAAG,KAAK;EACRC,CAAA,EAAG,KAAK;EACRC,CAAA,EAAG,KAAK;EACRC,CAAA,EAAG,KAAK;EACRC,CAAA,EAAG,KAAK;EACRC,CAAA,EAAG,KAAK;EACR,KAAK,KAAK;EACV,MAAM,KAAK;EACXC,MAAA,EAAQ,KAAK;EACbC,MAAA,EAAQ,KAAK;EACbC,MAAA,EAAQ,KAAK;EACbC,MAAA,EAAQ,KAAK;EACb,KAAK,KAAK;EACV,KAAK,KAAK;EACV,KAAK,KAAK;EACV,KAAK,KAAK;EACVC,MAAA,EAAQ,KAAK;EACb,KAAK,KAAK;EACVC,GAAA,EAAK,KAAK;EACVC,GAAA,EAAK,KAAK;EACVC,MAAA,EAAQ,KAAK;EACbC,MAAA,EAAQ,KAAK;EACbC,MAAA,EAAQ,KAAK;EACbC,MAAA,EAAQ,KAAK;EACbC,SAAA,EAAW,KAAK;EAChBC,cAAA,EAAgB,KAAK;EACrBC,GAAA,EAAK,KAAK;EACVC,GAAA,EAAK,KAAK;EACVC,GAAA,EAAK,KAAK;EACV,KAAK,KAAK;EACVC,QAAA,EAAU;AACd;AClCO,MAAMC,yCAAA,GAAY;;GAEtB;AECI,MAAMC,yCAAA,GAAY,IAAAC,cAAA,CAAAC,YAAW,EAAE,IAAA7B,yCAAO,EAAE,IAAI;AAC5C,MAAM8B,yCAAA,GAAY,IAAAF,cAAA,CAAAC,YAAW,EAAE,IAAA7B,yCAAO,EAAE,IAAI;AAC5C,MAAM+B,yCAAA,GAAY,IAAAH,cAAA,CAAAC,YAAW,EAAE,IAAA7B,yCAAO,EAAE,IAAI;AAC5C,MAAMgC,yCAAA,GAAW,IAAAJ,cAAA,CAAAC,YAAW,EAAE,IAAA7B,yCAAO,EAAE,IAAI;AAC3C,MAAMiC,yCAAA,GAAW,IAAAL,cAAA,CAAAC,YAAW,EAAE,IAAA7B,yCAAO,EAAE,IAAI;AAC3C,MAAMkC,yCAAA,GAAY,IAAAN,cAAA,CAAAC,YAAW,EAAE,IAAA7B,yCAAO,EAAE,IAAI;ACR5C,MAAMmC,yCAAA,SAAqBC,GAAA;EACvBC,WAAWC,GAAW,EAAW;IACpC,KAAK,MAAMC,IAAA,IAAQD,GAAA,EAAK,IAAI,CAAC,IAAI,CAACE,GAAG,CAACD,IAAA,GAAO,OAAO;IACpD,OAAO;EACX;EAEOE,SAASH,GAAW,EAAW;IAClC,KAAK,MAAMC,IAAA,IAAQ,IAAI,EAAE,IAAI,CAACD,GAAA,CAAIE,GAAG,CAACD,IAAA,GAAO,OAAO;IACpD,OAAO;EACX;EAEOG,iBAAiBJ,GAAW,EAAW;IAC1C,OAAO,IAAI,CAACD,UAAU,CAACC,GAAA,KAAQ,CAAC,IAAI,CAACG,QAAQ,CAACH,GAAA;EAClD;EAEOK,eAAeL,GAAW,EAAW;IACxC,OAAO,IAAI,CAACG,QAAQ,CAACH,GAAA,KAAQ,CAAC,IAAI,CAACD,UAAU,CAACC,GAAA;EAClD;EAEOM,OAAON,GAAW,EAAW;IAChC,OAAO,IAAI,CAACG,QAAQ,CAACH,GAAA,KAAQ,IAAI,CAACD,UAAU,CAACC,GAAA;EACjD;EAEOO,MAAMP,GAAW,EAAgB;IACpC,MAAMO,KAAA,GAAQ,IAAIV,yCAAA,CAAU,IAAI;IAChC,KAAK,MAAMI,IAAA,IAAQD,GAAA,EAAKO,KAAA,CAAMC,GAAG,CAACP,IAAA;IAClC,OAAOM,KAAA;EACX;EAEOE,aAAaT,GAAW,EAAgB;IAC3C,MAAMS,YAAA,GAAe,IAAIZ,yCAAA;IACzB,KAAK,MAAMI,IAAA,IAAQD,GAAA,EAAK,IAAI,IAAI,CAACE,GAAG,CAACD,IAAA,GAAOQ,YAAA,CAAaD,GAAG,CAACP,IAAA;IAC7D,OAAOQ,YAAA;EACX;EAEOC,oBAAoBV,GAAW,EAAgB;IAClD,MAAMW,UAAA,GAAa,IAAId,yCAAA,CAAa,IAAI;IACxC,KAAK,MAAMI,IAAA,IAAQD,GAAA,EACf,IAAIW,UAAA,CAAWT,GAAG,CAACD,IAAA,GAAOU,UAAA,CAAWC,MAAM,CAACX,IAAA,OACvCU,UAAA,CAAWH,GAAG,CAACP,IAAA;IACxB,OAAOU,UAAA;EACX;EAEOA,WAAWX,GAAW,EAAgB;IACzC,MAAMW,UAAA,GAAa,IAAId,yCAAA,CAAa,IAAI;IACxC,KAAK,MAAMI,IAAA,IAAQD,GAAA,EAAKW,UAAA,CAAWC,MAAM,CAACX,IAAA;IAC1C,OAAOU,UAAA;EACX;EAEOE,OAAOb,GAAW,EAAQ;IAC7B,KAAK,MAAMC,IAAA,IAAQD,GAAA,EAAK,IAAI,CAACQ,GAAG,CAACP,IAAA;IACjC,OAAO,IAAI;EACf;EAEOa,iBAAiBd,GAAW,EAAQ;IACvC,KAAK,MAAMC,IAAA,IAAQD,GAAA,EAAK,IAAI,CAACY,MAAM,CAACX,IAAA;IACpC,OAAO,IAAI;EACf;EAEOc,0BAA0Bf,GAAW,EAAQ;IAChD,KAAK,MAAMC,IAAA,IAAQD,GAAA,EACf,IAAI,IAAI,CAACE,GAAG,CAACD,IAAA,GAAO,IAAI,CAACW,MAAM,CAACX,IAAA,OAC3B,IAAI,CAACO,GAAG,CAACP,IAAA;IAClB,OAAO,IAAI;EACf;EAEOe,mBAAmBhB,GAAW,EAAQ;IACzC,KAAK,MAAMC,IAAA,IAAQ,IAAI,EAAE,IAAI,CAACD,GAAA,CAAIE,GAAG,CAACD,IAAA,GAAO,IAAI,CAACW,MAAM,CAACX,IAAA;IACzD,OAAO,IAAI;EACf;EAEOgB,KAAKC,MAA+B,EAAgB;IACvD,OAAO,IAAIrB,yCAAA,CAAU,C,GAAI,IAAI,CAAC,CAACoB,IAAI,CAACC,MAAA;EACxC;EAEOC,IACHC,MAA2D,EAC/C;IACZ,MAAMC,MAAA,GAAS,IAAIxB,yCAAA;IACnB,IAAIyB,KAAA,GAAQ;IACZ,KAAK,MAAMrB,IAAA,IAAQ,IAAI,EAAEoB,MAAA,CAAOb,GAAG,CAACY,MAAA,CAAOnB,IAAA,EAAMqB,KAAA,IAAS,IAAI;IAC9D,OAAOD,MAAA;EACX;EAEOE,OACHC,SAAoE,EACxD;IACZ,MAAMH,MAAA,GAAS,IAAIxB,yCAAA;IACnB,IAAIyB,KAAA,GAAQ;IACZ,KAAK,MAAMrB,IAAA,IAAQ,IAAI,EACnB,IAAIuB,SAAA,CAAUvB,IAAA,EAAMqB,KAAA,IAAS,IAAI,GAAGD,MAAA,CAAOb,GAAG,CAACP,IAAA;IACnD,OAAOoB,MAAA;EACX;AACJ;AC3FO,SAASI,0CAAaC,IAAY,EAAEC,KAAa;EACpD,IAAIC,IAAA,GAAO,EAAE;EACb,IAAIC,QAAA,GAAWH,IAAA;EACf,OAAOG,QAAA,GAAW,EAAE,EAAE;IAClBF,KAAA,KAAU,EAAE;IACZC,IAAA,KAAS,EAAE;IACXC,QAAA,KAAa,EAAE;EACnB;EACAD,IAAA,IAAQ,EAAE;EACV,OAAOD,KAAA,GAASD,IAAA,GAAOE,IAAA;AAC3B;AAEO,MAAME,yCAAA;EACT,OAAcC,GAAA,GAAgB,IAAID,yCAAA;EAClC,OAAcJ,IAAA,GAAiBI,yCAAA,CAASC,GAAG,CAACC,KAAK;EACjD,OAAcL,KAAA,GAAkBG,yCAAA,CAASC,GAAG,CAACE,IAAI;EAEzCX,KAAA;EAERjE,YAAYiE,KAAA,GAAgB,EAAE,EAAE;IAC5B,IAAIA,KAAA,GAAQ,EAAE,EAAE;MACZ,MAAMY,SAAA,GAAY,CAAC,GAAA5C,cAAA,CAAA6C,eAAc,EAAEb,KAAA,IAAS,KAAM;MAClD,MAAMc,IAAA,GAAO,IAAA9C,cAAA,CAAA+C,aAAY,EAAEf,KAAA,EAAOY,SAAA,EAAW,OAAO;MACpDZ,KAAA,GAAQ,IAAAhC,cAAA,CAAAgD,aAAY,EAAEC,UAAA,CAAWC,IAAI,CAAC,CAAC,G,GAAMJ,IAAA,CAAK,GAAG,OAAO;IAChE;IACA,IAAI,CAACd,KAAK,GAAGA,KAAA;EACjB;EAEOmB,OAAA,EAAqB;IACxB,MAAMP,SAAA,GAAY,CAAC,GAAA5C,cAAA,CAAA6C,eAAc,EAAE,IAAI,CAACb,KAAK,IAAI,KAAM;IACvD,OAAO,IAAAhC,cAAA,CAAA+C,aAAY,EAAE,IAAI,CAACf,KAAK,EAAEY,SAAA,EAAW;EAChD;EAEO1B,IAAIkC,KAAe,EAAY;IAClC,OAAO,IAAIZ,yCAAA,CAASL,yCAAA,CAAa,IAAI,CAACH,KAAK,EAAEoB,KAAA,CAAMpB,KAAK;EAC5D;EAEOU,MAAA,EAAkB;IACrB,OAAO,IAAIF,yCAAA,CAAS,IAAI,CAACR,KAAK,GAAG,EAAE;EACvC;EAEOW,KAAA,EAAiB;IACpB,OAAO,IAAIH,yCAAA,CAAS,IAAI,CAACR,KAAK,GAAG,EAAE,GAAG,EAAE;EAC5C;EAEOqB,SAAA,EAAmB;IACtB,OAAO,aAAa,IAAI,CAACrB,KAAK,EAAE;EACpC;AACJ;AC3CO,SAASsB,0CAAeC,OAAgB;EAC3C,OAAO,IAAAC,yCAAM,EAAEC,IAAI,CAAC,IAAAD,yCAAM,EAAEE,UAAU,CAAC,IAAAtF,yCAAO,EAAE,IAAI,GAAGmF,OAAA;AAC3D;AAEO,SAASI,0CAAcJ,OAAgB,EAAEK,IAAa;EACzD,OAAO,IAAAJ,yCAAM,EAAEK,QAAQ,CAAC,CAAC,IAAAL,yCAAM,EAAEE,UAAU,CAAC,IAAAtF,yCAAO,EAAE,IAAI,GAAGmF,OAAA,EAASK,IAAA,CAAK;AAC9E;AAEO,SAASE,0CAAaP,OAAgB,EAAEQ,WAAoB;EAC/D,OAAOJ,yCAAA,CACH,IAAAH,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,QACjBT,OAAA,EACAD,yCAAA,CAAeS,WAAA,EAClB,GACD,IAAAP,yCAAM,EAAES,SAAS,CAAC,IAAAzB,yCAAO,EAAEC,GAAG,CAACU,MAAM;AAE7C;AAEO,SAASe,0CAAcX,OAAgB,EAAEK,IAAa;EACzD,OAAOD,yCAAA,CAAcL,yCAAA,CAAeC,OAAA,GAAUD,yCAAA,CAAeM,IAAA;AACjE;ACzBA,MAAMO,yCAAA,GAAsB,CACxB;;;;;;;;;;;;;KAaC,EACD;;;;;;;;;;;;;;;;;;;;;;;;;KAyBC,EACD;;;8CAG0C,EAC1C;;;;;iBAKa,EACb,8DAA8D,CACjE;AAED,IAAIC,+CAAA;AAEJ,SAASC,8CAAwBC,aAAmB;EAChD,MAAMC,GAAA,GAAM,IAAAf,yCAAM,EAAEgB,UAAU,CAAC;EAC/B,KAAK,MAAMC,WAAA,IAAeN,yCAAA,EAAqB;IAC3C,MAAMO,YAAA,GAAe,IAAAlB,yCAAM,EAAEgB,UAAU,CAACC,WAAA;IACxC,MAAME,GAAA,GAAM,IAAAnB,yCAAM,EAAEC,IAAI,CAACiB,YAAA,EAAcN,+CAAA;IACvC,MAAMQ,QAAA,GAAWN,aAAA,CAAcC,GAAA,EAAKI,GAAA,EAAKE,KAAK;IAC9CT,+CAAA,GAA4B,IAAAZ,yCAAM,EAAEC,IAAI,CACpCmB,QAAA,EACAR,+CAAA;EAER;EACA,OAAOA,+CAAA;AACX;AAEO,SAASU,0CAAmBR,aAAmB;EAClD,IAAI,CAACF,+CAAA,IAA6BA,+CAAA,CAA0BW,MAAM,EAAE;IAChEX,+CAAA,GAA4B,IAAAZ,yCAAM,EAAEK,QAAQ,CAAC,EAAE;IAC/CQ,6CAAA,CAAwBC,aAAA;EAC5B;EACA,OAAOF,+CAAA;AACX;AE/EO,SAASY,0CAAe1G,CAAS,EAAE2G,CAAS;EAC/C,OAAO3G,CAAA,GAAI2G,CAAA,GAAI,KAAK3G,CAAA,GAAI2G,CAAA,GAAI,IAAI;AACpC;AEEA,MAAMC,+BAAA,GAAY,IAAIC,WAAA,GAAcC,MAAM,CAAC;AAC3C,MAAMC,+BAAA,GAAY,IAAIF,WAAA,GAAcC,MAAM,CAAC;AAEpC,SAASE,0CACZC,QAAe,EACfC,GAAW,EACXC,YAAqB;EAErB,IAAID,GAAA,IAAOD,QAAA,EAAU;IACjB,IAAI,CAACA,QAAQ,CAACC,GAAA,CAAI,CAACxE,MAAM,CAACyE,YAAA,GAAe,OAAO;IAChD,OAAOF,QAAA;EACX;EACA,OAAO;IAAE,GAAGA,QAAQ;IAAE,CAACC,GAAA,GAAMC;EAAa;AAC9C;AAEO,SAASC,0CACZC,OAAgB,EAChBC,IAAa,EACbC,aAAA,GAAuB,CAAC,CAAC;EAEzB,IAAI,CAACF,OAAA,CAAQG,MAAM,EAAE;IACjB,IAAIF,IAAA,CAAKE,MAAM,EAAE,OAAO;IACxB,OAAO,IAAA9F,cAAA,CAAA+F,UAAS,EAAEJ,OAAA,CAAQK,IAAI,EAAEJ,IAAA,CAAKI,IAAI,IAAIH,aAAA,GAAgB;EACjE;EACA,MAAMzD,IAAA,GAAOuD,OAAA,CAAQjD,KAAK;EAC1B,MAAML,KAAA,GAAQsD,OAAA,CAAQhD,IAAI;EAC1B,IAAIP,IAAA,CAAK6D,MAAM,IAAI,IAAAjG,cAAA,CAAA+F,UAAS,EAAE3D,IAAA,CAAK4D,IAAI,EAAEd,+BAAA,GAAY;IACjD,IAAIU,IAAA,CAAKE,MAAM,EAAE,OAAO;IACxB,IAAIzD,KAAA,CAAM4D,MAAM,IAAI,IAAAjG,cAAA,CAAA+F,UAAS,EAAE1D,KAAA,CAAM2D,IAAI,EAAEd,+BAAA,GAAY;MACnD,IAAI,IAAAlF,cAAA,CAAA+F,UAAS,EAAEH,IAAA,CAAKI,IAAI,EAAEd,+BAAA,GAAY,OAAO,CAAC;MAC9C,OAAO;IACX;IACA,OAAOI,yCAAA,CAAcO,aAAA,EAAexD,KAAA,CAAM6D,MAAM,IAAIN,IAAA;EACxD;EACA,IAAIxD,IAAA,CAAK6D,MAAM,IAAI,IAAAjG,cAAA,CAAA+F,UAAS,EAAE3D,IAAA,CAAK4D,IAAI,EAAEX,+BAAA,GAAY;IACjD,IAAIhD,KAAA,CAAM4D,MAAM,IAAI,IAAAjG,cAAA,CAAA+F,UAAS,EAAE1D,KAAA,CAAM2D,IAAI,EAAEX,+BAAA,GAAY;MACnD,IAAI,IAAArF,cAAA,CAAA+F,UAAS,EAAEH,IAAA,CAAKI,IAAI,EAAEX,+BAAA,GAAY,OAAO,CAAC;MAC9C,OAAO;IACX;IACA,OAAOC,yCAAA,CAAcO,aAAA,EAAexD,KAAA,CAAM6D,MAAM,IAAIN,IAAA;EACxD;EACA,IAAI,CAACA,IAAA,CAAKE,MAAM,EAAE,OAAO;EACzB,MAAMK,WAAA,GAAcT,yCAAA,CAAMtD,IAAA,EAAMwD,IAAA,CAAKlD,KAAK,EAAEmD,aAAA;EAC5C,IAAI,CAACM,WAAA,EAAa,OAAOA,WAAA;EACzB,OAAOT,yCAAA,CAAMrD,KAAA,EAAOuD,IAAA,CAAKjD,IAAI,EAAEwD,WAAA;AACnC;ADxCO,SAASC,0CAAc7C,OAAgB;EAC1C,IAAI,CAACA,OAAA,CAAQuC,MAAM,EAAE,OAAOvC,OAAA,CAAQwB,MAAM;EAC1C,MAAMsB,QAAA,GAAW9C,OAAA,CAAQb,KAAK;EAC9B,IAAI,CAAC2D,QAAA,CAASP,MAAM,EAAE;IAClB,MAAMjB,KAAA,GAAQwB,QAAA,CAASL,IAAI;IAC3B,IAAI,IAAAhG,cAAA,CAAA+F,UAAS,EAAElB,KAAA,GAAO,GAAA9E,yCAAQ,IAAI,OAAO,UACpC,IAAI,IAAAC,cAAA,CAAA+F,UAAS,EAAElB,KAAA,GAAO,GAAAvE,yCAAQ,IAAI,OAAO;EAClD,OAAO,IAAI,CAAC8F,yCAAA,CAAcC,QAAA,GAAW,OAAO;EAC5C,OAAO9C,OAAA,CAAQZ,IAAI,CAAC2D,MAAM,GAAGC,KAAK,CAAE5F,IAAA,IAASyF,yCAAA,CAAczF,IAAA;AAC/D;AAEO,SAAS6F,0CACZjD,OAAgB,EAChBe,aAAmB;EAEnB,IAAI8B,yCAAA,CAAc7C,OAAA,KAAY,CAACA,OAAA,CAAQwB,MAAM,EAAE;IAC3C,MAAM0B,UAAA,GAAanC,aAAA,CAAcf,OAAA,EAAS,IAAAC,yCAAM,EAAEkD,GAAG,EAAE7B,KAAK;IAC5DtB,OAAA,GAAU,IAAAD,yCAAa,EAAEmD,UAAA;EAC7B;EACA,OAAOlD,OAAA;AACX;AAEO,SAASoD,0CAAWpD,OAAgB;EACvC,OAAOA,OAAA,CAAQ0C,MAAM,IAAI1C,OAAA,CAAQqD,QAAQ,OAAO,EAAE;AACtD;AAEO,SAASC,0CACZtD,OAAgB,EAChBuD,cAAoB;EAEpB,MAAMC,OAAA,GAAU,IAAArB,yCAAI,EAChB,IAAAlC,yCAAM,EAAEgB,UAAU,CAAC,oCACnBjB,OAAA;EAEJ,IAAIwD,OAAA,IAAWJ,yCAAA,CAAWI,OAAO,CAAC,OAAO,GACrC,OAAOA,OAAO,CAAC,OAAO;EAE1B,OAAOxD,OAAA;AACX;AAEO,SAASyD,0CAAUpD,IAAa;EACnC,MAAMmD,OAAA,GAAU,IAAArB,yCAAI,EAChB,IAAAlC,yCAAM,EAAEgB,UAAU,CAAC,+BACnBZ,IAAA;EAEJ,IAAImD,OAAA,EACA,OAAOA,OAAO,CAAC,QAAQ;EAE3B,OAAO,IAAAvD,yCAAM,EAAEK,QAAQ,CAAC,CAAC,IAAAL,yCAAM,EAAEE,UAAU,CAAC,IAAAtF,yCAAO,EAAE,IAAI,GAAGwF,IAAA,CAAK;AACrE;AAEO,SAASqD,0CAASrD,IAAa;EAClC,MAAMmD,OAAA,GAAU,IAAArB,yCAAI,EAChB,IAAAlC,yCAAM,EAAEgB,UAAU,CAAC,+BACnBZ,IAAA;EAEJ,IAAImD,OAAA,EACA,OAAOA,OAAO,CAAC,OAAO;EAE1B,OAAO,IAAAvD,yCAAM,EAAEK,QAAQ,CAAC,CAAC,IAAAL,yCAAM,EAAEE,UAAU,CAAC,IAAAtF,yCAAO,EAAE,IAAI,GAAGwF,IAAA,CAAK;AACrE;AAEO,SAASsD,0CAAa3D,OAAgB,EAAEK,IAAa;EACxD,MAAMiB,KAAA,GAAQtB,OAAA,CAAQqD,QAAQ;EAC9B,IAAI/B,KAAA,IAAS,EAAE,EACX,OAAOjB,IAAA;EAEXL,OAAA,GAAU,IAAAC,yCAAM,EAAEE,UAAU,CAACmB,KAAA,IAAS,EAAE;EACxC,IAAIA,KAAA,GAAQ,EAAE,EACV,OAAOqC,yCAAA,CAAa3D,OAAA,EAAS0D,yCAAA,CAASrD,IAAA;EAE1C,OAAOsD,yCAAA,CAAa3D,OAAA,EAASyD,yCAAA,CAAUpD,IAAA;AAC3C;AAEO,SAASuD,0CAAQ5D,OAAgB,EAAEK,IAAa;EACnD,IAAI,CAACL,OAAA,CAAQuC,MAAM,EACf,OAAOoB,yCAAA,CAAa3D,OAAA,EAASK,IAAA;EAEjC,IAAIlB,KAAA,GAAQa,OAAA,CAAQb,KAAK;EACzB,IAAIA,KAAA,CAAMoD,MAAM,EAAEpD,KAAA,GAAQyE,yCAAA,CAAQzE,KAAA,EAAOkB,IAAA,OACpC,IAAI,IAAA5D,cAAA,CAAA+F,UAAS,EAAErD,KAAA,CAAMsD,IAAI,GAAE,GAAAjG,yCAAQ,IACpC,OAAOwD,OAAA;EAEX,OAAO,IAAAC,yCAAM,EAAEK,QAAQ,CAAC,CACpBnB,KAAA,E,GACGa,OAAA,CAAQZ,IAAI,CAAC2D,MAAM,GAAGzE,GAAG,CAAElB,IAAA,IAASwG,yCAAA,CAAQxG,IAAA,EAAMiD,IAAA,GACxD;AACL;AAEO,SAASwD,0CACZ7D,OAAgB,EAChBe,aAAmB;EAEnB,MAAMyC,OAAA,GAAU,IAAArB,yCAAI,EAChB,IAAAlC,yCAAM,EAAEgB,UAAU,CAAC,oCACnBjB,OAAA;EAEJ,IAAI,CAACwD,OAAA,EACD,OAAOxD,OAAA;EAEX,MAAM8D,YAAA,GAAeN,OAAO,CAAC,OAAO;EACpC,MAAMO,YAAA,GAAeP,OAAO,CAAC,OAAO;EACpC,MAAMQ,kBAAA,GAAqBJ,yCAAA,CAAQG,YAAA,EAAcD,YAAA;EACjD,IAAIjB,yCAAA,CAAcmB,kBAAA,GACd,OAAOC,uCAAA,CAAgBD,kBAAA,EAAoBjD,aAAA;EAE/C,MAAMmD,WAAA,GAAcF,kBAAA,CAAmBjB,MAAM;EAC7C,MAAMoB,WAAA,GAAcD,WAAA,CAAY5F,GAAG,CAAElB,IAAA,IACjC6G,uCAAA,CAAgB7G,IAAA,EAAM2D,aAAA;EAE1B,MAAMqD,gBAAA,GAAmBD,WAAA,CAAYzF,MAAM,CACtCtB,IAAA,IACGA,IAAA,CAAKmF,MAAM,KACVnF,IAAA,CAAK+B,KAAK,CAACoD,MAAM,IAAI,CAAC,IAAA9F,cAAA,CAAA+F,UAAS,EAAEpF,IAAA,CAAK+B,KAAK,CAACsD,IAAI,GAAE,GAAAjG,yCAAQ,EAAC,GAClE6H,MAAM;EACR,IAAID,gBAAA,GAAmB,GACnB,OAAO,IAAAnE,yCAAM,EAAEK,QAAQ,CAAC6D,WAAA;EAE5B,OAAOnE,OAAA;AACX;AAEO,SAASsE,0CACZtE,OAAgB,EAChBe,aAAmB;EAEnB,IAAI,CAACf,OAAA,CAAQuC,MAAM,EACf,OAAOvC,OAAA;EAEX,MAAM8C,QAAA,GAAW9C,OAAA,CAAQb,KAAK;EAC9B,IAAI2D,QAAA,CAASJ,MAAM,IAAI,IAAAjG,cAAA,CAAA+F,UAAS,EAAEM,QAAA,CAASL,IAAI,GAAE,GAAAjG,yCAAQ,IACrD,OAAOwD,OAAA;EAEX,OAAO,IAAAC,yCAAM,EAAEK,QAAQ,CACnBN,OAAA,CAAQ+C,MAAM,GAAGzE,GAAG,CAAElB,IAAA,IAAS6G,uCAAA,CAAgB7G,IAAA,EAAM2D,aAAA;AAE7D;AAEO,SAASwD,0CAAcvE,OAAgB,EAAEuD,cAAoB;EAChE,IAAIC,OAAA,GAAU,IAAArB,yCAAI,EACd,IAAAlC,yCAAM,EAAEgB,UAAU,CAAC,mCACnBjB,OAAA;EAEJ,IAAIwD,OAAA,EACA,OAAOA,OAAO,CAAC,QAAQ;EAE3BA,OAAA,GAAU,IAAArB,yCAAI,EACV,IAAAlC,yCAAM,EAAEgB,UAAU,CAAC,mCACnBjB,OAAA;EAEJ,IAAIwD,OAAA,EACA,OAAOA,OAAO,CAAC,OAAO;EAE1B,OAAOxD,OAAA;AACX;AAEO,SAASwE,0CAAcxE,OAAgB,EAAEuD,cAAoB;EAChE,IAAIC,OAAA,GAAU,IAAArB,yCAAI,EAAE,IAAAlC,yCAAM,EAAEgB,UAAU,CAAC,mBAAmBjB,OAAA;EAC1D,IAAIwD,OAAA,IAAW,CAACA,OAAO,CAAC,OAAO,CAAChC,MAAM,EAAE;IACpC,MAAMiD,IAAA,GAAO,KAAI,GAAAxF,yCAAO,EAAEuE,OAAO,CAAC,OAAO,CAACH,QAAQ,IAAI1F,GAAG,CACrD,IAAAsB,yCAAO,EAAEJ,IAAI;IAEjB,OAAO,IAAAoB,yCAAM,EAAES,SAAS,CAAC+D,IAAA,CAAK7E,MAAM;EACxC;EACA4D,OAAA,GAAU,IAAArB,yCAAI,EAAE,IAAAlC,yCAAM,EAAEgB,UAAU,CAAC,mBAAmBjB,OAAA;EACtD,IAAIwD,OAAA,IAAW,CAACA,OAAO,CAAC,OAAO,CAAChC,MAAM,EAAE;IACpC,MAAMiD,IAAA,GAAO,KAAI,GAAAxF,yCAAO,EAAEuE,OAAO,CAAC,OAAO,CAACH,QAAQ,IAAI1F,GAAG,CACrD,IAAAsB,yCAAO,EAAEH,KAAK;IAElB,OAAO,IAAAmB,yCAAM,EAAES,SAAS,CAAC+D,IAAA,CAAK7E,MAAM;EACxC;EACA,OAAOI,OAAA;AACX;AAEO,SAAS0E,0CACZ1E,OAAgB,EAChBuD,cAAoB;EAEpB,MAAMC,OAAA,GAAU,IAAArB,yCAAI,EAAE,IAAAlC,yCAAM,EAAEgB,UAAU,CAAC,YAAYjB,OAAA;EACrD,IAAIwD,OAAA,EACA,OAAO,IAAAvD,yCAAM,EAAEkD,GAAG;EAEtB,OAAOnD,OAAA;AACX;AAEO,SAAS2E,0CACZ3E,OAAgB,EAChBuD,cAAoB;EAEpB,MAAMC,OAAA,GAAU,IAAArB,yCAAI,EAAE,IAAAlC,yCAAM,EAAEgB,UAAU,CAAC,uBAAuBjB,OAAA;EAChE,IAAIwD,OAAA,EACA,OAAO,IAAAvD,yCAAM,EAAEkD,GAAG;EAEtB,OAAOnD,OAAA;AACX;AAEO,SAASiE,wCACZjE,OAAgB,EAChBe,aAAmB;EAEnB,IAAIf,OAAA,CAAQ0C,MAAM,EACd,OAAO1C,OAAA;EAEX,MAAM4E,UAAA,GAAa,CACfL,yCAAA,EACAtB,yCAAA,EACAK,yCAAA,EACAO,yCAAA,EACAS,yCAAA,EACAE,yCAAA,EACAE,yCAAA,EACAC,yCAAA,CACH;EACD,OAAO3E,OAAA,CAAQuC,MAAM,EAAE;IACnB,MAAMsC,YAAA,GAAe7E,OAAA;IACrB,KAAK,MAAM8E,SAAA,IAAaF,UAAA,EAAY;MAChC5E,OAAA,GAAU8E,SAAA,CAAU9E,OAAA,EAASe,aAAA;MAC7B,IAAI,CAAC8D,YAAA,CAAapH,MAAM,CAACuC,OAAA,GAAU;IACvC;IACA,IAAI6E,YAAA,CAAapH,MAAM,CAACuC,OAAA,GACpB,OAAOA,OAAA;EAEf;EACA,OAAOA,OAAA;AACX;AAEO,SAAS+E,0CAAUC,UAAgB;EACtC,OAAQ3E,IAAA;IACJ,OAAO;MACHiB,KAAA,EAAO2C,uCAAA,CAAgB5D,IAAA,CAAKlB,KAAK,EAAE6F,UAAA;MACnCC,IAAA,EAAM;IACV;EACJ;AACJ;AFzOA,MAAMC,8BAAA,GAAW;AAEV,SAASC,0CAAUC,KAAgB;EACtC,IAAIA,KAAA,CAAMf,MAAM,KAAK,GAAG,OAAO,IAAApE,yCAAM,EAAEkD,GAAG,MACrC,IAAIiC,KAAA,CAAMf,MAAM,KAAK,GAAG,OAAOe,KAAK,CAAC,EAAE;EAC5C,MAAMC,QAAA,GAAWD,KAAA,CAAMf,MAAM,IAAI;EACjC,OAAO,IAAApE,yCAAM,EAAEC,IAAI,CACfiF,yCAAA,CAAUC,KAAA,CAAME,KAAK,CAAC,GAAGD,QAAA,IACzBF,yCAAA,CAAUC,KAAA,CAAME,KAAK,CAACD,QAAA;AAE9B;AAEO,SAASE,0CAAiBH,KAAgB;EAC7C,IAAIA,KAAA,CAAMf,MAAM,KAAK,GACjB,OAAO,IAAApE,yCAAM,EAAEK,QAAQ,CAAC,CAAC,IAAAP,yCAAa,EAAE,IAAAE,yCAAM,EAAEkD,GAAG,EAAE,OACpD,IAAIiC,KAAA,CAAMf,MAAM,KAAK,GAAG,OAAOe,KAAK,CAAC,EAAE;EAC5C,MAAMC,QAAA,GAAWD,KAAA,CAAMf,MAAM,IAAI;EACjC,OAAO,IAAApE,yCAAM,EAAEK,QAAQ,CAAC,CACpB,IAAAL,yCAAM,EAAES,SAAS,EAAC,GAAA5D,yCAAO,IACzByI,yCAAA,CAAiBH,KAAA,CAAME,KAAK,CAAC,GAAGD,QAAA,IAChCE,yCAAA,CAAiBH,KAAA,CAAME,KAAK,CAACD,QAAA,GAChC;AACL;AAEO,SAASG,0CAAQxF,OAAgB;EACpC,IAAIA,OAAA,CAAQuC,MAAM,EACd,OAAO,C,GAAIiD,yCAAA,CAAQxF,OAAA,CAAQb,KAAK,G,GAAMqG,yCAAA,CAAQxF,OAAA,CAAQZ,IAAI,EAAE,MAC3D,OAAO,CAACY,OAAA,CAAQ2C,MAAM,GAAG;AAClC;AAEO,SAAS8C,0CACZC,SAAgB,EAChBC,SAAgB,EAChBC,MAAiB;EAEjB,MAAMC,YAAA,GAAsB,CAAC;EAC7B,KAAK,MAAMzI,IAAA,IAAQwI,MAAA,EAAQC,YAAY,CAACzI,IAAA,CAAKgC,IAAI,CAACD,KAAK,CAACwD,MAAM,GAAG,GAAGvF,IAAA;EACpE,MAAM0I,eAAA,GAAkB,KAAI,GAAA9I,yCAAQ,EAAEtC,MAAA,CAAOqL,IAAI,CAACL,SAAA;EAClDI,eAAA,CAAgB9H,MAAM,CAAC,KAAI,GAAAhB,yCAAQ,EAAEtC,MAAA,CAAOqL,IAAI,CAACJ,SAAA;EACjD,IAAIK,QAAA,GAAW,KAAI,GAAAhJ,yCAAQ,EAAE,CAACkI,8BAAA,CAAS;EACvC,MAAMe,SAAA,GAAY,KAAI,GAAAjJ,yCAAQ,EAAEgJ,QAAA;EAChC,OAAOA,QAAA,CAASE,IAAI,EAAE;IAClB,MAAMC,aAAA,GAAgB,KAAI,GAAAnJ,yCAAQ,EAAEgJ,QAAA;IACpCA,QAAA,GAAW,KAAI,GAAAhJ,yCAAQ;IACvB,KAAK,MAAMI,IAAA,IAAQ+I,aAAA,EAAe;MAC9B,KAAK,MAAMC,KAAA,IAAS,CAACV,SAAA,EAAWG,YAAA,CAAa,EACzC,IAAIzI,IAAA,IAAQgJ,KAAA,EACRJ,QAAA,CAAShI,MAAM,CAAC,KAAI,GAAAhB,yCAAQ,EAAEwI,yCAAA,CAAQY,KAAK,CAAChJ,IAAA,CAAK;IAE7D;IACA4I,QAAA,CAAS/H,gBAAgB,CAACgI,SAAA;IAC1BA,SAAA,CAAUjI,MAAM,CAACgI,QAAA;EACrB;EACAC,SAAA,CAAU9H,kBAAkB,CAAC2H,eAAA;EAC7BG,SAAA,CAAUlI,MAAM,CAACmH,8BAAA;EACjB,OAAOe,SAAA,CAAU7H,IAAI,CAAC,CAACrD,CAAA,EAAG2G,CAAA,KAAM,IAAAD,yCAAa,EAAE1G,CAAA,EAAG2G,CAAA;AACtD;AAEO,SAAS2E,0CACZC,IAAa,EACbC,SAA4B,EAC5Bb,SAAgB,EAChBC,SAAgB,EAChBC,MAAiB,EACjBZ,UAAgB;EAEhB,MAAMhF,OAAA,GAAU,IAAAC,yCAAM,EAAEgB,UAAU,CAAC;EACnC,MAAMuF,MAAA,GAASxB,UAAA,CAAWhF,OAAA,EAASsG,IAAA,EAAMhF,KAAK;EAC9C,KAAK,MAAMlE,IAAA,IAAQoJ,MAAA,CAAOzD,MAAM,IAC5B0D,yCAAA,CACIrJ,IAAA,EACAmJ,SAAA,EACAb,SAAA,EACAC,SAAA,EACAC,MAAA,EACAZ,UAAA;AAEZ;AAEO,SAAS0B,0CAAY1G,OAAgB,EAAEK,IAAc;EACxD,IAAIL,OAAA,CAAQuC,MAAM,EACd,OAAO,IAAAtC,yCAAM,EAAEC,IAAI,CACfwG,yCAAA,CAAY1G,OAAA,CAAQb,KAAK,EAAEkB,IAAA,GAC3BqG,yCAAA,CAAY1G,OAAA,CAAQZ,IAAI,EAAEiB,IAAA,QAE3B,IAAIA,IAAA,CAAKsG,QAAQ,CAAC3G,OAAA,CAAQ2C,MAAM,KACnC,OAAO,IAAA1C,yCAAM,EAAEK,QAAQ,CAAC,CAAC,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,YAAYT,OAAA,CAAQ;EAElE,OAAOA,OAAA;AACX;AAEO,SAAS4G,0CAAmB5G,OAAgB;EAC/C,MAAM6G,MAAA,GAAS7G,OAAA,CAAQZ,IAAI;EAC3B,MAAM0H,KAAA,GAAQD,MAAA,CAAOzH,IAAI;EACzB,MAAMgG,KAAA,GAAQ,CAAC,IAAAnF,yCAAM,EAAEQ,QAAQ,CAAC,aAAaoG,MAAA,CAAO1H,KAAK,EAAE2H,KAAA,CAAM3H,KAAK,CAAC;EACvE,MAAM4H,IAAA,GAAOD,KAAA,CAAM1H,IAAI,CAACD,KAAK;EAC7B,MAAMkB,IAAA,GAAOmF,yCAAA,CAAQsB,KAAA,CAAM3H,KAAK,EAAET,MAAM,CAAEtB,IAAA,IAASA,IAAA,CAAKiH,MAAM;EAC9D,MAAM2C,YAAA,GAAeN,yCAAA,CAAYK,IAAA,EAAM1G,IAAA;EACvC+E,KAAA,CAAM6B,IAAI,CAAC,IAAAhH,yCAAM,EAAEK,QAAQ,CAAC,CAAC,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,OAAOuG,YAAA,CAAa;EAClE,OAAO,IAAA/G,yCAAM,EAAEK,QAAQ,CAAC8E,KAAA;AAC5B;AAEO,SAASqB,0CACZS,kBAA2B,EAC3BX,SAA4B,EAC5Bb,SAAgB,EAChBC,SAAgB,EAChBC,MAAiB,EACjBZ,UAAgB;EAEhB,MAAMmC,EAAA,GAAKD,kBAAA,CAAmB/H,KAAK,CAACwD,MAAM;EAC1C,MAAMyE,WAAA,GAAcF,kBAAA,CAAmB9H,IAAI,CAACD,KAAK;EACjD,IAAIgI,EAAA,KAAO,WAAW;IAClBd,yCAAA,CACIe,WAAA,EACAb,SAAA,EACAb,SAAA,EACAC,SAAA,EACAC,MAAA,EACAZ,UAAA;IAEJ;EACJ;EACA,MAAMsB,IAAA,GAAOc,WAAA,CAAYzE,MAAM;EAC/B,IAAI4D,SAAA,CAAUlJ,GAAG,CAACiJ,IAAA,GACd,MAAM,IAAI/L,KAAA,CAAM,UAAU8M,IAAA,CAAKC,SAAS,CAAChB,IAAA,cAAkB;EAE/DC,SAAA,CAAU5I,GAAG,CAAC2I,IAAA;EACd,IAAIa,EAAA,KAAO,YACPvB,MAAA,CAAOqB,IAAI,CAACC,kBAAA,OACT,IAAIC,EAAA,KAAO,SACdzB,SAAS,CAACY,IAAA,CAAK,GAAGY,kBAAA,CAAmB9H,IAAI,CAACA,IAAI,MAC3C,IAAI+H,EAAA,KAAO,gBACdvB,MAAA,CAAOqB,IAAI,CAACL,yCAAA,CAAmBM,kBAAA,QAC5B,IAAIC,EAAA,KAAO,eACdxB,SAAS,CAACW,IAAA,CAAK,GAAG,IAAAvG,yCAAa,EAAEmH,kBAAA,CAAmB9H,IAAI,CAACA,IAAI,CAACD,KAAK,OAEnE,MAAM,IAAI5E,KAAA,CACN,2EAA2E8M,IAAA,CAAKC,SAAS,CACrFH,EAAA,IACA;AAGhB;AAEO,SAASI,0CACZlH,IAAa,EACb2E,UAAgB;EAEhB,MAAMU,SAAA,GAAmB,CAAC;EAC1B,MAAMC,SAAA,GAAmB,CAAC;EAC1B,MAAMC,MAAA,GAAyB,EAAE;EACjC,MAAM4B,kBAAA,GAAqBnH,IAAA,CAAKlB,KAAK;EACrC,MAAMoH,SAAA,GAAY,KAAI,GAAAvJ,yCAAQ;EAC9B,OAAO,MAAM;IACTqD,IAAA,GAAOA,IAAA,CAAKjB,IAAI;IAChB,IAAIiB,IAAA,CAAKjB,IAAI,CAACoC,MAAM,EAAE;IACtBiF,yCAAA,CACIpG,IAAA,CAAKlB,KAAK,EACVoH,SAAA,EACAb,SAAA,EACAC,SAAA,EACAC,MAAA,EACAZ,UAAA;EAER;EACA,MAAMyC,cAAA,GAAiBpH,IAAA,CAAKlB,KAAK;EACjCuG,SAAS,CAACR,8BAAA,CAAS,GAAG,IAAAjF,yCAAM,EAAEK,QAAQ,CAAC,CACnCkH,kBAAA,EACAC,cAAA,CACH;EACD,OAAO,CAAC/B,SAAA,EAAWC,SAAA,EAAWC,MAAA,CAAO;AACzC;AAEO,SAAS8B,0CAAmBC,IAAa,EAAEC,QAAkB;EAChE,IAAID,IAAA,CAAKnG,MAAM,EAAE,OAAO,IAAAvB,yCAAM,EAAEkD,GAAG,MAC9B,IAAI,CAACwE,IAAA,CAAKpF,MAAM,EACjB,OAAO,IAAAtC,yCAAM,EAAEK,QAAQ,CAAC,CACpB,IAAAL,yCAAM,EAAEK,QAAQ,CAAC,CAACqH,IAAA,EAAM,IAAA1H,yCAAM,EAAES,SAAS,CAACkH,QAAA,CAAShI,MAAM,IAAI,EAChE;EACL,MAAMf,IAAA,GAAO6I,yCAAA,CAAmBC,IAAA,CAAKxI,KAAK,EAAEyI,QAAA,CAASjK,GAAG,CAAC,IAAAsB,yCAAO,EAAEJ,IAAI;EACtE,MAAMC,KAAA,GAAQ4I,yCAAA,CAAmBC,IAAA,CAAKvI,IAAI,EAAEwI,QAAA,CAASjK,GAAG,CAAC,IAAAsB,yCAAO,EAAEH,KAAK;EACvE,OAAO,IAAAmB,yCAAM,EAAEK,QAAQ,CAAC,C,GAAIzB,IAAA,CAAKkE,MAAM,I,GAAOjE,KAAA,CAAMiE,MAAM,GAAG;AACjE;AAEO,SAAS8E,0CACZrH,WAAoB,EACpBoF,MAAiB,EACjBZ,UAAgB;EAEhB,IAAI8C,kBAAA,GAAqB,IAAA/H,yCAAa,EAAES,WAAA;EACxC,KAAK,MAAMuH,KAAA,IAASnC,MAAA,EAAQ;IACxBkC,kBAAA,GAAqB,IAAA1H,yCAAY,EAC7B,IAAAH,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,QACjB,IAAAR,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,QACjB,IAAAV,yCAAa,EACT,IAAAE,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAES,SAAS,EAAC,GAAA5D,yCAAO,IACzBiL,KAAA,EACAD,kBAAA,CACH,IAELA,kBAAA,CACH,EACJ,GACD,IAAA7H,yCAAM,EAAES,SAAS,CAAC,IAAAzB,yCAAO,EAAEC,GAAG,CAACU,MAAM;IAEzCkI,kBAAA,GAAqB,IAAA7D,uCAAc,EAAE6D,kBAAA,EAAoB9C,UAAA;EAC7D;EACA,OAAO8C,kBAAA;AACX;AAEO,SAASE,0CACZtC,SAAgB,EAChBoC,kBAA2B,EAC3BG,mBAA4B,EAC5BC,YAAsB;EAEtB,MAAMC,iBAAA,GAA2B,CAAC;EAClC,KAAK,MAAM,CAAC7B,IAAA,EAAM8B,gBAAA,CAAiB,IAAI1N,MAAA,CAAO2N,OAAO,CAAC3C,SAAA,GAAY;IAC9D,MAAM4C,gBAAA,GAAmBZ,yCAAA,CACrBU,gBAAA,CAAiBjJ,KAAK,EACtB+I,YAAA;IAEJ,MAAMK,UAAA,GAAa,IAAAtI,yCAAM,EAAEK,QAAQ,CAAC,C,GAC7BgI,gBAAA,CAAiBvF,MAAM,I,GACvBkF,mBAAA,CAAoBlF,MAAM,GAChC;IACDoF,iBAAiB,CAAC7B,IAAA,CAAK,GAAG,IAAArG,yCAAM,EAAEK,QAAQ,CAAC,CACvC,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,QACjB,IAAAR,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,QACjB,IAAAV,yCAAa,EAAEqI,gBAAA,CAAiBhJ,IAAI,CAACD,KAAK,GAC1C2I,kBAAA,EACA,IAAA/H,yCAAa,EAAEwI,UAAA,EAClB,EACJ;EACL;EACA,OAAOJ,iBAAA;AACX;AAEO,SAASK,0CACZnI,IAAa,EACbG,WAAoB,EACpBiI,YAAqB,EACrBzD,UAAgB;EAEhB,MAAM,CAACU,SAAA,EAAWC,SAAA,EAAWC,MAAA,CAAO,GAAG2B,yCAAA,CAAiBlH,IAAA,EAAM2E,UAAA;EAC9D,MAAM8C,kBAAA,GAAqBD,yCAAA,CACvBrH,WAAA,EACAoF,MAAA,EACAZ,UAAA;EAEJ,MAAM0D,gBAAA,GAAmBjD,yCAAA,CACrBC,SAAA,EACAC,SAAA,EACAC,MAAA;EAEJ,MAAM+C,eAAA,GAAkBD,gBAAA,CAAiBxC,IAAI,GAAG;EAChD,MAAM0C,YAAA,GAAezD,yCAAA,CAAU,C,GACxBuD,gBAAA,CAAiBpK,GAAG,CAAElB,IAAA,IAAS,IAAA6C,yCAAM,EAAEQ,QAAQ,CAACrD,IAAA,GACtD;EACD,MAAMyL,gBAAA,GAAmB,IAAA5J,yCAAO,EAAEJ,IAAI;EACtC,MAAMqJ,YAAA,GAAeS,eAAA,GAAkB,IAAA1J,yCAAO,EAAEH,KAAK,GAAG,IAAAG,yCAAO,EAAEC,GAAG;EACpE,MAAM+I,mBAAA,GAAsBP,yCAAA,CACxBkB,YAAA,EACAC,gBAAA;EAEJ,MAAMV,iBAAA,GAAoBH,yCAAA,CACtBtC,SAAA,EACAoC,kBAAA,EACAG,mBAAA,EACAC,YAAA;EAEJ,MAAMY,cAAA,GAAiBX,iBAAiB,CAACjD,8BAAA,CAAS,CAACpF,QAAQ;EAC3D,IAAIiJ,aAAA;EACJ,IAAIJ,eAAA,EAAiB;IACjB,MAAMK,kBAAA,GAA4B,CAAC;IACnC,KAAK,MAAM,CAAC/G,GAAA,EAAKX,KAAA,CAAM,IAAI5G,MAAA,CAAO2N,OAAO,CAACF,iBAAA,GACtC,IAAIO,gBAAA,CAAiBrL,GAAG,CAAC4E,GAAA,GAAM+G,kBAAkB,CAAC/G,GAAA,CAAI,GAAGX,KAAA;IAC7D5G,MAAA,CAAOuO,MAAM,CAACD,kBAAA,EAAoBrD,SAAA;IAClC,MAAMuD,gBAAA,GAAmB,C,GAAIR,gBAAA,CAAiB,CAACpK,GAAG,CAC7ClB,IAAA,IAAS4L,kBAAkB,CAAC5L,IAAA,CAAK;IAEtC,MAAM+L,uBAAA,GAA0B5D,yCAAA,CAAiB2D,gBAAA;IACjD,MAAME,sBAAA,GAAyBD,uBAAA,CAAwBrJ,QAAQ;IAC/DiJ,aAAA,GAAgB,MAAMK,sBAAA,KAA2B;EACrD,OACIL,aAAA,GAAgB;EAEpB,OAAO,IAAA9I,yCAAM,EAAEgB,UAAU,CACrB,gBAAgB6H,cAAA,IAAkBC,aAAA,KAAkB;AAE5D;ANpSA,MAAMM,0CAAA,GAAuB,KAAI,GAAArM,yCAAQ,EAAE,C,GACpCtC,MAAA,CAAO4O,MAAM,EAAC,GAAAzO,yCAAO,GAAGyD,GAAG,CAAEgD,KAAA,IAAU,IAAA7E,cAAA,CAAA8M,KAAI,EAAE,IAAA9M,cAAA,CAAAC,YAAW,EAAE4E,KAAA,KAC7D,IAAA7E,cAAA,CAAA8M,KAAI,EAAE,IAAI3H,WAAA,GAAcC,MAAM,CAAC,SAC/B,IAAApF,cAAA,CAAA8M,KAAI,EAAE,IAAI3H,WAAA,GAAcC,MAAM,CAAC,QAClC;AAEM,SAAS2H,0CACZnJ,IAAa,EACbG,WAAoB,EACpBiJ,WAAoB,EACpBzE,UAAgB,EAChB0E,KAAA,GAAgB,CAAC;EAEjB,SAASC,IAAI3J,OAAgB;IACzB,OAAO4J,yCAAA,CAAa5J,OAAA,EAASQ,WAAA,EAAaiJ,WAAA,EAAazE,UAAA;EAC3D;EAEA,MAAMhF,OAAA,GAAUK,IAAA,CAAKlB,KAAK;EAC1B,IAAI,CAACa,OAAA,CAAQuC,MAAM,EACf,OAAO,IAAAxC,yCAAa,EAAEC,OAAA;EAE1B,IAAI,CAACA,OAAA,CAAQb,KAAK,CAACoD,MAAM,EAAE;IACvB,MAAM4E,EAAA,GAAKnH,OAAA,CAAQb,KAAK,CAACwD,MAAM;IAC/B,IAAIwE,EAAA,KAAO,MAAM;MACb,MAAM0C,UAAA,GAAaL,yCAAA,CACfxJ,OAAA,CAAQZ,IAAI,EACZoB,WAAA,EACAiJ,WAAA,EACAzE,UAAA,EACA0E,KAAA,GAAQ;MAEZ,OAAOC,GAAA,CACH,IAAA1J,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAES,SAAS,EAAC,GAAA5D,yCAAO,IACzB,IAAAmD,yCAAM,EAAEQ,QAAQ,CAAC0G,EAAA,GACjB,IAAAlH,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAES,SAAS,EAAC,GAAA5D,yCAAO,IACzB+M,UAAA,EACA,IAAA9J,yCAAa,EAAE,IAAAE,yCAAM,EAAEkD,GAAG,EAC7B,EACJ;IAET,OAAO,IAAIgE,EAAA,KAAO,WAAW;MACzB,IAAIuC,KAAA,KAAU,GACV,OAAOC,GAAA,CAAI3J,OAAA,CAAQZ,IAAI,CAACD,KAAK;MAEjC,MAAM0K,UAAA,GAAaL,yCAAA,CACfxJ,OAAA,CAAQZ,IAAI,EACZoB,WAAA,EACAiJ,WAAA,EACAzE,UAAA,EACA0E,KAAA,GAAQ;MAEZ,OAAOC,GAAA,CACH,IAAA1J,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAES,SAAS,EAAC,GAAA5D,yCAAO,IACzB,IAAAmD,yCAAM,EAAEQ,QAAQ,CAAC0G,EAAA,GACjB,IAAAlH,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAES,SAAS,EAAC,GAAA5D,yCAAO,IACzB+M,UAAA,EACA,IAAA9J,yCAAa,EAAE,IAAAE,yCAAM,EAAEkD,GAAG,EAC7B,EACJ;IAET;EACJ;EACA,MAAMhE,KAAA,GAAQwK,GAAA,CACV,IAAA1J,yCAAM,EAAEK,QAAQ,CAAC,CAAC,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,OAAOT,OAAA,CAAQb,KAAK,CAAC;EAE5D,MAAMC,IAAA,GAAOuK,GAAA,CAAI,IAAA1J,yCAAM,EAAEK,QAAQ,CAAC,CAAC,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,OAAOT,OAAA,CAAQZ,IAAI,CAAC;EACxE,OAAO,IAAAa,yCAAM,EAAEK,QAAQ,CAAC,CAAC,IAAAL,yCAAM,EAAES,SAAS,EAAC,GAAA5D,yCAAO,IAAIqC,KAAA,EAAOC,IAAA,CAAK;AACtE;AAEO,SAAS0K,0CACZC,KAAc,EACdvJ,WAAoB,EACpBiI,YAAqB,EACrBuB,WAAiB;EAEjB,OAAO,IAAAjK,yCAAa,EAAES,WAAA;AAC1B;AAEO,SAASyJ,0CACZF,KAAc,EACdG,YAAqB,EACrBT,WAAoB,EACpBO,WAAiB;EAEjB,OAAO,IAAAjK,yCAAa,EAAE0J,WAAA;AAC1B;AAEO,MAAMU,yCAAA,GAAkB;EAC3BC,EAAA,EAAIZ,yCAAA;EACJ5D,MAAA,EAAQkE,yCAAA;EACRO,OAAA,EAASJ,yCAAA;EACTK,MAAA,GAAQ,GAAA9B,yCAAS;EACjB+B,GAAA,GAAK,GAAA/B,yCAAS;AAClB;AAEO,SAASgC,0CACZxK,OAAgB,EAChBkK,YAAsB,EACtBzB,YAAsB,EACtBuB,WAAkB;EAElB,IAAIhK,OAAA,CAAQ0C,MAAM,EACd,OAAO1C,OAAA,MACJ,IAAIA,OAAA,CAAQb,KAAK,CAACuD,MAAM,IAAI1C,OAAA,CAAQb,KAAK,CAACwD,MAAM,OAAO,SAAS;IACnE,IAAI,CAAC3C,OAAA,CAAQZ,IAAI,CAACA,IAAI,CAACoC,MAAM,EACzB,MAAM,IAAIjH,KAAA,CACN,qCAAqCyF,OAAA,qCAA4CA,OAAA,CAAQyK,cAAc,GAAG;IAElH,OAAO,IAAA1K,yCAAa,EAAEyK,yCAAA,CAAWxK,OAAA,CAAQZ,IAAI,CAACD,KAAK;EACvD,OACI,OAAO,IAAAc,yCAAM,EAAEC,IAAI,CACfsK,yCAAA,CAAWxK,OAAA,CAAQb,KAAK,GACxBqL,yCAAA,CAAWxK,OAAA,CAAQZ,IAAI;AAEnC;AAEO,SAASwK,0CACZ5J,OAAgB,EAChBQ,WAAoB,EACpBiJ,WAAoB,EACpBzE,UAAgB;EAEhBhF,OAAA,GAAUwK,yCAAA,CAAWxK,OAAA,EAASQ,WAAA,EAAaiJ,WAAA,EAAazE,UAAA;EACxD,IAAI,CAAChF,OAAA,CAAQuC,MAAM,EAAE;IACjB,MAAME,IAAA,GAAOzC,OAAA,CAAQ2C,MAAM;IAC3B,IAAIF,IAAA,KAAS,KACT,OAAO,IAAAxC,yCAAM,EAAES,SAAS,CAAC,IAAAzB,yCAAO,EAAEC,GAAG,CAACU,MAAM;IAEhD,KAAK,MAAM8K,IAAA,IAAQjB,WAAA,CAAY1G,MAAM,IAAI;MACrC,MAAM4H,MAAA,GAASD,IAAA,CAAKvL,KAAK;MACzB,MAAMmC,KAAA,GAAQoJ,IAAA,CAAKtL,IAAI,CAACD,KAAK;MAC7B,IAAIwL,MAAA,CAAOjI,MAAM,IAAIiI,MAAA,CAAOhI,MAAM,OAAOF,IAAA,EACrC,OAAOnB,KAAA;IAEf;IACA,OAAO,IAAAvB,yCAAa,EAAEC,OAAA;EAC1B;EACA,MAAM8C,QAAA,GAAW9C,OAAA,CAAQb,KAAK;EAC9B,IAAI2D,QAAA,CAASP,MAAM,EAAE;IACjB,MAAMqI,KAAA,GAAQ,IAAAxK,yCAAY,EACtB,IAAAH,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,QACjB,IAAAV,yCAAa,EAAE+C,QAAA,GACf,IAAA/C,yCAAa,EAAES,WAAA,GACf,IAAAT,yCAAa,EAAE0J,WAAA,EAClB,GACD,IAAAxJ,yCAAM,EAAES,SAAS,CAAC,IAAAzB,yCAAO,EAAEC,GAAG,CAACU,MAAM;IAEzC,OAAO,IAAAK,yCAAM,EAAEK,QAAQ,CAAC,CAACsK,KAAA,CAAM;EACnC;EACA,MAAMnI,IAAA,GAAOK,QAAA,CAASH,MAAM;EAC5B,KAAK,MAAMkI,SAAA,IAAarK,WAAA,CAAYuC,MAAM,IACtC,IAAI8H,SAAA,CAAU1L,KAAK,CAACuD,MAAM,IAAImI,SAAA,CAAU1L,KAAK,CAACwD,MAAM,OAAOF,IAAA,EAAM;IAC7D,MAAMqI,SAAA,GAAYD,SAAA,CAAUzL,IAAI,CAACD,KAAK;IACtC,MAAM4L,WAAA,GAAc,IAAApK,yCAAY,EAAEmK,SAAA,EAAW9K,OAAA,CAAQZ,IAAI;IACzD,MAAMZ,MAAA,GAAS,IAAA4B,yCAAY,EACvB,IAAAH,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,QACjBsK,WAAA,EACA,IAAAhL,yCAAa,EAAES,WAAA,GACf,IAAAT,yCAAa,EAAE0J,WAAA,EAClB,GACD,IAAAxJ,yCAAM,EAAES,SAAS,CAAC,IAAAzB,yCAAO,EAAEC,GAAG,CAACU,MAAM;IAEzC,OAAOpB,MAAA;EACX;EAEJ,IAAIiE,IAAA,IAAQ0H,yCAAA,EAAiB;IACzB,MAAMa,QAAA,GAAWb,yCAAe,CAAC1H,IAAA,CAAqC;IACtE,MAAMsI,WAAA,GAAcC,QAAA,CAChBhL,OAAA,CAAQZ,IAAI,EACZoB,WAAA,EACAiJ,WAAA,EACAzE,UAAA;IAEJ,OAAO,IAAA5E,yCAAY,EACf,IAAAL,yCAAa,EAAEgL,WAAA,GACf,IAAA9K,yCAAM,EAAES,SAAS,CAAC,IAAAzB,yCAAO,EAAEC,GAAG,CAACU,MAAM;EAE7C;EACA,IAAI,IAAAnD,cAAA,CAAA+F,UAAS,EAAEM,QAAA,CAASL,IAAI,GAAE,GAAAjG,yCAAQ,IAClC,OAAOwD,OAAA;EAEX,MAAMiL,YAAA,GAAejL,OAAA,CAAQZ,IAAI,CAC5B2D,MAAM,GACNzE,GAAG,CAAElB,IAAA,IACFwM,yCAAA,CAAaxM,IAAA,EAAMoD,WAAA,EAAaiJ,WAAA,EAAazE,UAAA;EAErD,IAAIxG,MAAA,GAAS,IAAAyB,yCAAM,EAAEK,QAAQ,CAAC,CAACwC,QAAA,E,GAAamI,YAAA,CAAa;EACzD,IACI5B,0CAAA,CAAqBhM,GAAG,CAAC,IAAAZ,cAAA,CAAA8M,KAAI,EAAE,IAAI3H,WAAA,GAAcC,MAAM,CAACY,IAAA,OACxDA,IAAA,CAAKyI,UAAU,CAAC,MAEhB,OAAO1M,MAAA;EAEX,KAAK,MAAMpB,IAAA,IAAQqM,WAAA,CAAY1G,MAAM,IAAI;IACrC,MAAM,CAAC4H,MAAA,EAAQrJ,KAAA,CAAM,GAAGlE,IAAA,CAAK2F,MAAM;IACnC,IAAI,CAAC4H,MAAA,CAAOjI,MAAM,EAAE;IACpB,MAAMyI,UAAA,GAAaR,MAAA,CAAOhI,MAAM;IAChC,IAAIwI,UAAA,KAAe,KACf,OAAO3M,MAAA,MACJ,IAAI2M,UAAA,KAAe1I,IAAA,EAAM;MAC5B,MAAM2I,OAAA,GAAU,IAAAhL,yCAAY,EACxB,IAAAH,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,QACjB,IAAAR,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,QACjB,IAAAV,yCAAa,EACT,IAAAE,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAEQ,QAAQ,CAAC,S,GACdT,OAAA,CAAQZ,IAAI,CAAC2D,MAAM,GACzB,IAEL,IAAAhD,yCAAa,EAAES,WAAA,GACf,IAAAT,yCAAa,EAAE0J,WAAA,EAClB,EACJ,GACD,IAAAxJ,yCAAM,EAAES,SAAS,CAAC,IAAAzB,yCAAO,EAAEC,GAAG,CAACU,MAAM;MAEzC,OAAO,IAAAK,yCAAM,EAAEK,QAAQ,CAAC,CACpB,IAAAL,yCAAM,EAAES,SAAS,EAAC,GAAA/D,yCAAQ,IAC1B2E,KAAA,EACA,IAAArB,yCAAM,EAAEK,QAAQ,CAAC,CACb,IAAAL,yCAAM,EAAES,SAAS,EAAC,GAAA5D,yCAAO,IACzB,IAAAmD,yCAAM,EAAES,SAAS,CAAC,IAAAzB,yCAAO,EAAEJ,IAAI,CAACe,MAAM,KACtCwL,OAAA,CACH,EACJ;IACL;EACJ;EACA,MAAM,IAAI7Q,KAAA,CACN,kCAAkCyF,OAAA,GAAUA,OAAA,CAAQyK,cAAc,GAAG;AAE7E;AAEO,SAASY,0CAAUrG,UAAgB;EACtC,OAAQ3C,IAAA;IACJ,MAAMiJ,IAAA,GAAOjJ,IAAA,CAAKlD,KAAK;IACvB,IAAIsK,WAAA,GAAc,IAAAxJ,yCAAM,EAAEkD,GAAG;IAC7B,IAAI3C,WAAA;IACJ,IAAI,CAAC6B,IAAA,CAAKjD,IAAI,CAACoC,MAAM,EAAE;MACnBhB,WAAA,GAAc6B,IAAA,CAAKjD,IAAI,CAACD,KAAK;MAC7B,IAAI,CAACkD,IAAA,CAAKjD,IAAI,CAACA,IAAI,CAACoC,MAAM,EAAEiI,WAAA,GAAcpH,IAAA,CAAKjD,IAAI,CAACA,IAAI,CAACD,KAAK;IAClE,OACIqB,WAAA,GAAc,IAAAe,yCAAiB,EAAEyD,UAAA;IAErC,OAAO;MACH1D,KAAA,EAAOsI,yCAAA,CAAa0B,IAAA,EAAM9K,WAAA,EAAaiJ,WAAA,EAAazE,UAAA;MACpDC,IAAA,EAAM;IACV;EACJ;AACJ;AW1QO,MAAMsG,yCAAA,GAAQ;EACjBC,EAAA,EAAI,GAAG;EACPtL,IAAA,EAAM,GAAG;EACTf,KAAA,EAAO,GAAG;EACVC,IAAA,EAAM,GAAG;EACTqM,KAAA,EAAO,GAAG;EACVC,aAAA,EAAe,GAAG;EAClBC,SAAA,EAAW,GAAG;EACdC,YAAA,EAAc,EAAE;EAChBC,WAAA,EAAa,IAAI;EACjBC,OAAA,EAAS,IAAI;EACbC,UAAA,EAAY,EAAE;EACdC,SAAA,EAAW,IAAI;EACfC,OAAA,EAAS,IAAI;EACbC,UAAA,EAAY,EAAE;EACdC,MAAA,EAAQ,IAAI;EACZC,SAAA,EAAW,EAAE;EACbC,MAAA,EAAQ,IAAI;EACZC,SAAA,EAAW,EAAE;EACbC,UAAA,EAAY,KAAK;EACjBC,aAAA,EAAe,EAAE;EACjBC,OAAA,EAAS,IAAI;EACbC,UAAA,EAAY,EAAE;EACdC,UAAA,EAAY,GAAG;EACfC,aAAA,EAAe,EAAE;EACjBC,YAAA,EAAc,IAAI;EAClBC,YAAA,EAAc,OAAO;EACrBC,cAAA,EAAgB,QAAQ;EACxBC,UAAA,EAAY,QAAQ;EACpBC,aAAA,EAAe,GAAG;EAClBC,OAAA,EAAS,GAAG;EACZC,QAAA,EAAU,IAAI;EACdC,gBAAA,EAAkB,EAAE;EACpBC,uBAAA,EAAyB,IAAI;EAC7BC,UAAA,EAAY,IAAI;EAChBC,aAAA,EAAe,EAAE;EACjBC,cAAA,EAAgB,GAAG;EACnBC,gBAAA,EAAkB,EAAE;EACpBC,qBAAA,EAAuB,EAAE;EACzBC,UAAA,EAAY,IAAI;EAChBC,aAAA,EAAe,EAAE;EACjBC,YAAA,EAAc,IAAI;EAClBC,QAAA,EAAU,IAAI;EACdC,UAAA,EAAY,IAAI;EAChBC,UAAA,EAAY,IAAI;EAChBC,aAAA,EAAe,EAAE;EACjBC,UAAA,EAAY,IAAI;EAChBC,aAAA,EAAe,EAAE;EACjBC,UAAA,EAAY,IAAI;EAChBC,aAAA,EAAe,EAAE;EACjBC,KAAA,EAAO,GAAG;EACVC,KAAA,EAAO;AACX;ACjDO,SAASC,0CAAQC,IAAY;EAChCA,IAAA,IAAQA,IAAA,IAAQ;EAChBA,IAAA,IAAQA,IAAA,IAAQ;EAChBA,IAAA,IAAQA,IAAA,IAAQ;EAChB,OAAOA,IAAC,GAAO,KAAM;AACzB;AAEO,SAASC,0CACZpN,KAAc,EACdqN,WAAoB;EAEpB,IAAI1J,IAAA,GAAO,IAAAsG,yCAAI,EAAEiC,cAAc,GAAG,IAAAjC,yCAAI,EAAEkC,gBAAgB;EACxD,IAAInM,KAAA,CAAME,MAAM,EAAE,OAAO;IAAEF,KAAA,EAAO,IAAArB,yCAAM,EAAEkD,GAAG;UAAE8B;EAAK;EACpD,IAAI2J,aAAA,GAAgB;EACpB,MAAMnM,IAAA,GAAOnB,KAAA,CAAMmB,IAAI;EACvB,OAAOmM,aAAA,GAAgBnM,IAAA,CAAK4B,MAAM,IAAI5B,IAAI,CAACmM,aAAA,CAAc,KAAK,GAC1DA,aAAA;EACJ3J,IAAA,IAAQ4J,MAAA,CAAOD,aAAA,IAAiB,IAAArD,yCAAI,EAAEmC,qBAAqB;EAC3D,IAAIkB,aAAA,KAAkBnM,IAAA,CAAK4B,MAAM,EAAE,OAAO;IAAE/C,KAAA,EAAO,IAAArB,yCAAM,EAAEkD,GAAG;UAAE8B;EAAK;EACrE,MAAM6J,UAAA,GAAaN,yCAAA,CAAQ/L,IAAI,CAACmM,aAAA,CAAc;EAC9C,IAAIG,UAAA,GAAatM,IAAA,CAAK4B,MAAM,GAAG;EAC/B,IAAI2K,OAAA,GAAU;EACd,OAAOD,UAAA,GAAaH,aAAA,IAAiBI,OAAA,GAAUF,UAAA,EAAY;IACvD,IAAIH,WAAA,CAAYjM,MAAM,EAClB,MAAM,IAAInI,KAAA,CACN,wBAAwBoU,WAAA,GAAcA,WAAA,CAAYlE,cAAc,GAAG;IAE3E,IAAI,CAAChI,IAAI,CAACsM,UAAA,CAAW,GAAGC,OAAM,MAAO,GAAGL,WAAA,GAAcA,WAAA,CAAYvP,IAAI,MACjEuP,WAAA,GAAcA,WAAA,CAAYxP,KAAK;IACpC8F,IAAA,IAAQ,IAAAsG,yCAAI,EAAEkC,gBAAgB;IAC9BuB,OAAA,KAAY;IACZ,IAAIA,OAAA,KAAY,OAAO;MACnBD,UAAA;MACAC,OAAA,GAAU;IACd;EACJ;EACA,OAAO;IAAE1N,KAAA,EAAOqN,WAAA;UAAa1J;EAAK;AACtC;AChBO,MAAMgK,yCAAA,GAAY;EACrBjU,CAAA,EAAKqF,IAAA;IACD,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,KAAK;IAC/B,OAAO;MAAEiB,KAAA,EAAO4N,IAAI,CAAC,EAAE,CAAC1N,MAAM,GAAG0N,IAAI,CAAC,EAAE,GAAGA,IAAI,CAAC,EAAE;MAAEjK,IAAA,EAAM,IAAAsG,yCAAI,EAAEC;IAAG;EACvE;EACAvQ,CAAA,EAAKoF,IAAA;IACD,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,KAAK;IAC/B,OAAO;MAAEiB,KAAA,EAAO,IAAArB,yCAAM,EAAEC,IAAI,CAACgP,IAAI,CAAC,EAAE,EAAEA,IAAI,CAAC,EAAE;MAAGjK,IAAA,EAAM,IAAAsG,yCAAI,EAAErL;IAAK;EACrE;EACAhF,CAAA,EAAKmF,IAAA;IACD,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,KAAK,GAAG;IAClC,OAAO;MAAEiB,KAAA,EAAO4N,IAAI,CAAC,EAAE,CAAC/P,KAAK;MAAE8F,IAAA,EAAM,IAAAsG,yCAAI,EAAEpM;IAAM;EACrD;EACAhE,CAAA,EAAKkF,IAAA;IACD,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,KAAK,GAAG;IAClC,OAAO;MAAEiB,KAAA,EAAO4N,IAAI,CAAC,EAAE,CAAC9P,IAAI;MAAE6F,IAAA,EAAM,IAAAsG,yCAAI,EAAEnM;IAAK;EACnD;EACAhE,CAAA,EAAKiF,IAAA;IACD,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,KAAK;IAC/B,OAAO;MAAEiB,KAAA,EAAO,IAAArB,yCAAM,EAAEmP,QAAQ,CAACF,IAAI,CAAC,EAAE,CAAC3M,MAAM;MAAG0C,IAAA,EAAM,IAAAsG,yCAAI,EAAEE;IAAM;EACxE;EACApQ,CAAA,EAAKgF,IAAA;IACD,MAAM,IAAI9F,KAAA,CAAM,aAAa8F,IAAA,cAAkBA,IAAA,CAAKoK,cAAc,GAAG;EACzE;EACA,KAAOpK,IAAA;IACH,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,KAAK,GAAG;IAClC,OAAO;MACHiB,KAAA,EAAO,IAAArB,yCAAM,EAAEmP,QAAQ,CAAC,IAAA3S,cAAA,CAAA+F,UAAS,EAAE0M,IAAI,CAAC,EAAE,CAACzM,IAAI,EAAEyM,IAAI,CAAC,EAAE,CAACzM,IAAI;MAC7DwC,IAAA,EACI,IAAAsG,yCAAI,EAAEY,MAAM,GACZ,CAAC0C,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,KACrD,IAAAkH,yCAAI,EAAEa;IAClB;EACJ;EACA9Q,MAAA,EAAU+E,IAAA;IACN,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,UAAUgP,SAAA,EAAW;IAC/C,IAAIpK,IAAA,GAAO,IAAAsG,yCAAI,EAAEoB,UAAU;IAC3B,IAAI2C,SAAA,GAAY;IAChB,MAAMC,KAAA,GAAuB,EAAE;IAC/B,KAAK,MAAMnS,IAAA,IAAQ8R,IAAA,EAAM;MACrB,KAAK,MAAMT,IAAA,IAAQrR,IAAA,CAAKqF,IAAI,EAAE8M,KAAA,CAAMtI,IAAI,CAACwH,IAAA;MACzCa,SAAA,IAAalS,IAAA,CAAKqF,IAAI,CAAC4B,MAAM;MAC7BY,IAAA,IAAQ,IAAAsG,yCAAI,EAAEsB,YAAY;IAC9B;IACA5H,IAAA,IAAQ4J,MAAA,CAAOS,SAAA,IAAa,IAAA/D,yCAAI,EAAEqB,aAAa;IAC/C,OAAO4C,yCAAA,CAAW;MACdlO,KAAA,EAAO,IAAArB,yCAAM,EAAES,SAAS,CAAC,IAAAjE,cAAA,CAAAgT,OAAM,EAAE/P,UAAA,CAAWC,IAAI,CAAC4P,KAAA;YACjDtK;IACJ;EACJ;EACA,KAAO5E,IAAA;IACH,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,KAAKgP,SAAA,EAAW;IAC1C,IAAIK,KAAA,GAAQ,EAAE;IACd,IAAIzK,IAAA,GAAO,IAAAsG,yCAAI,EAAEI,SAAS;IAC1B,IAAIgE,OAAA,GAAU;IACd,KAAK,MAAMvS,IAAA,IAAQ8R,IAAA,EAAM;MACrBQ,KAAA,IAAStS,IAAA,CAAKiG,QAAQ;MACtBsM,OAAA,IAAWvS,IAAA,CAAKqF,IAAI,CAAC4B,MAAM;MAC3BY,IAAA,IAAQ,IAAAsG,yCAAI,EAAEM,WAAW;IAC7B;IACA5G,IAAA,IAAQ4J,MAAA,CAAOc,OAAA,IAAW,IAAApE,yCAAI,EAAEK,YAAY;IAC5C,OAAO4D,yCAAA,CAAW;MAAElO,KAAA,EAAO,IAAArB,yCAAM,EAAEE,UAAU,CAACuP,KAAA;YAAQzK;IAAK;EAC/D;EACA,KAAO5E,IAAA;IACH,IAAI4E,IAAA,GAAO,IAAAsG,yCAAI,EAAEI,SAAS;IAC1B,IAAItL,IAAA,CAAKmB,MAAM,EAAE,OAAO;MAAEF,KAAA,EAAO,IAAArB,yCAAM,EAAEkD,GAAG;MAAE8B,IAAA,EAAMA;IAAK;IACzD,MAAMiK,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,KAAKgP,SAAA,EAAW;IAC1C,IAAIK,KAAA,GAAQ,EAAE;IACd,IAAIE,IAAA,GAAO,EAAE;IACb,IAAID,OAAA,GAAU;IACd,KAAK,MAAMvS,IAAA,IAAQ8R,IAAA,EAAM;MACrBQ,KAAA,IAASE,IAAA,GAAOxS,IAAA,CAAKiG,QAAQ;MAC7BuM,IAAA,GAAO,CAAC,EAAE;MACVD,OAAA,IAAWvS,IAAA,CAAKqF,IAAI,CAAC4B,MAAM;MAC3BY,IAAA,IAAQ,IAAAsG,yCAAI,EAAEM,WAAW;IAC7B;IACA5G,IAAA,IAAQ4J,MAAA,CAAOc,OAAA,IAAW,IAAApE,yCAAI,EAAEK,YAAY;IAC5C,OAAO4D,yCAAA,CAAW;MAAElO,KAAA,EAAO,IAAArB,yCAAM,EAAEE,UAAU,CAACuP,KAAA;YAAQzK;IAAK;EAC/D;EACA,KAAO5E,IAAA;IACH,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,KAAKgP,SAAA,EAAW;IAC1C,IAAIpK,IAAA,GAAO,IAAAsG,yCAAI,EAAE2B,OAAO;IACxB,IAAI,CAACgC,IAAA,CAAK7K,MAAM,EAAE,OAAOmL,yCAAA,CAAW;MAAElO,KAAA,EAAO,IAAArB,yCAAM,EAAE4P,IAAI;YAAE5K;IAAK;IAChE,IAAI3D,KAAA,GAAQ4N,IAAI,CAAC,EAAE,CAAC7L,QAAQ;IAC5B,IAAI6C,IAAA,GAAOgJ,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM;IAC9B,KAAK,MAAMjH,IAAA,IAAQ8R,IAAA,CAAK5J,KAAK,CAAC,IAAI;MAC9BL,IAAA,IACI,IAAAsG,yCAAI,EAAE4B,QAAQ,GACd,CAAC0B,MAAA,CAAOzR,IAAA,CAAKqF,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAO3I,IAAA,CAAI,IACnC,IAAAqF,yCAAI,EAAE6B,gBAAgB,GAC1ByB,MAAC,CAAOzR,IAAA,CAAKqF,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAO3I,IAAA,IAC/B,IAAAqF,yCAAI,EAAE8B,uBAAuB;MACrC/L,KAAA,IAASlE,IAAA,CAAKiG,QAAQ;MACtB6C,IAAA,GAAO4J,yCAAA,CAAexO,KAAA;IAC1B;IACA,OAAOkO,yCAAA,CAAW;MAAElO,KAAA,EAAO,IAAArB,yCAAM,EAAEE,UAAU,CAACmB,KAAA;YAAQ2D;IAAK;EAC/D;EACAvJ,MAAA,EAAU2E,IAAA;IACN,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,UAAU,GAAG;IACvC,IAAI4E,IAAA,GAAO,IAAAsG,yCAAI,EAAEgB,UAAU;IAC3B,MAAMwD,SAAA,GAAYb,IAAI,CAAC,EAAE,CAAC7L,QAAQ;IAClC,MAAM2M,WAAA,GAAcd,IAAI,CAAC,EAAE,CAAC7L,QAAQ;IACpC,IAAI2M,WAAA,KAAgB,EAAE,EAClB,MAAM,IAAIzV,KAAA,CACN,6CAA6C8F,IAAA,CAAKoK,cAAc,GAAG;IAE3ExF,IAAA,IACI,CAAC4J,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,KACzD,IAAAkH,yCAAI,EAAEiB,aAAa;IACvB,IAAIyD,aAAA,GAAgBF,SAAA,GAAYC,WAAA;IAChC,MAAME,cAAA,GAAiB,IAAAzT,cAAA,CAAA8N,GAAE,EAAEwF,SAAA,EAAWC,WAAA;IACtC,IAAID,SAAA,GAAY,EAAE,KAAKC,WAAA,GAAc,EAAE,IAAIE,cAAA,KAAmB,EAAE,EAC5DD,aAAA,IAAiB,EAAE;IACvB,MAAME,QAAA,GAAW,IAAAlQ,yCAAM,EAAEE,UAAU,CAAC8P,aAAA;IACpC,MAAMG,SAAA,GAAY,IAAAnQ,yCAAM,EAAEE,UAAU,CAAC+P,cAAA;IACrCjL,IAAA,IACI,CAAC4J,MAAA,CAAOsB,QAAA,CAAS1N,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAOuB,SAAA,CAAU3N,IAAI,CAAC4B,MAAM,KAC5D,IAAAkH,yCAAI,EAAEG,aAAa;IACvB,OAAO;MAAEpK,KAAA,EAAO,IAAArB,yCAAM,EAAEC,IAAI,CAACiQ,QAAA,EAAUC,SAAA;YAAYnL;IAAK;EAC5D;EACA,KAAO5E,IAAA;IACH,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,KAAK,GAAG;IAClC,IAAI4E,IAAA,GAAO,IAAAsG,yCAAI,EAAEkB,OAAO;IACxB,MAAMsD,SAAA,GAAYb,IAAI,CAAC,EAAE,CAAC7L,QAAQ;IAClC,MAAM2M,WAAA,GAAcd,IAAI,CAAC,EAAE,CAAC7L,QAAQ;IACpC,IAAI2M,WAAA,KAAgB,EAAE,EAClB,MAAM,IAAIzV,KAAA,CACN,wCAAwC8F,IAAA,CAAKoK,cAAc,GAAG;IAEtExF,IAAA,IACI,CAAC4J,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,KACzD,IAAAkH,yCAAI,EAAEmB,UAAU;IACpB,IAAIuD,aAAA,GAAgBF,SAAA,GAAYC,WAAA;IAChC,MAAME,cAAA,GAAiB,IAAAzT,cAAA,CAAA8N,GAAE,EAAEwF,SAAA,EAAWC,WAAA;IACtC,IAAID,SAAA,GAAY,EAAE,KAAKC,WAAA,GAAc,EAAE,IAAIC,aAAA,GAAgB,EAAE,EACzDA,aAAA,IAAiB,EAAE;IACvB,MAAME,QAAA,GAAW,IAAAlQ,yCAAM,EAAEE,UAAU,CAAC8P,aAAA;IACpC,OAAOT,yCAAA,CAAW;MAAElO,KAAA,EAAO6O,QAAA;YAAUlL;IAAK;EAC9C;EACA,KAAO5E,IAAA;IACH,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,KAAK,GAAG;IAClC,MAAM4E,IAAA,GACF,IAAAsG,yCAAI,EAAEc,MAAM,GACZ,CAACwC,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,KACrD,IAAAkH,yCAAI,EAAEe,SAAS;IACvB,OAAO;MACHhL,KAAA,EAAO,IAAArB,yCAAM,EAAEmP,QAAQ,CAACF,IAAI,CAAC,EAAE,CAAC7L,QAAQ,KAAK6L,IAAI,CAAC,EAAE,CAAC7L,QAAQ;YAC7D4B;IACJ;EACJ;EACA,MAAQ5E,IAAA;IACJ,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,MAAM,GAAG;IACnC,MAAM4E,IAAA,GACF,IAAAsG,yCAAI,EAAEU,OAAO,GACb,CAAC4C,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,KACrD,IAAAkH,yCAAI,EAAEW,UAAU;IACxB,OAAO;MACH5K,KAAA,EAAO,IAAArB,yCAAM,EAAEmP,QAAQ,CACnBF,IAAI,CAAC,EAAE,CAAC3F,KAAK,GAAG8G,aAAa,CAACnB,IAAI,CAAC,EAAE,CAAC3F,KAAK,QAAQ;YAEvDtE;IACJ;EACJ;EACA/I,cAAA,EAAkBmE,IAAA;IACd,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,kBAAkB,GAAG;IAC/C,MAAMiB,KAAA,GAAQ,IAAA7E,cAAA,CAAA8N,GAAE,EAAE2E,IAAI,CAAC,EAAE,CAAC7L,QAAQ,IAAI,IAAA5G,cAAA,CAAA6T,SAAQ,EAAEC,CAAC;IACjD,MAAMC,QAAA,GAAW,IAAA/T,cAAA,CAAAgU,UAAS,EAAE/P,SAAS,CAAC,IAAAjE,cAAA,CAAA+C,aAAY,EAAE8B,KAAA,EAAO,IAAI;IAC/D,MAAM2D,IAAA,GACF,IAAAsG,yCAAI,EAAEyB,UAAU,GAChB6B,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,IAAI,IAAAkH,yCAAI,EAAE0B,aAAa;IACrD,OAAOuC,yCAAA,CAAW;MACdlO,KAAA,EAAO,IAAArB,yCAAM,EAAES,SAAS,CAAC8P,QAAA,CAASE,KAAK,GAAGC,OAAO;YACjD1L;IACJ;EACJ;EACAhJ,SAAA,EAAaoE,IAAA;IACT,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,aAAagP,SAAA,EAAW;IAClD,IAAIpK,IAAA,GAAO,IAAAsG,yCAAI,EAAEuB,YAAY;IAC7B,IAAI8D,KAAA,GAAQ,IAAAnU,cAAA,CAAAoU,aAAY,EAAEC,UAAU;IACpC,KAAK,MAAM1T,IAAA,IAAQ8R,IAAA,EAAM;MACrB0B,KAAA,GAAQA,KAAA,CAAMjT,GAAG,CAAC,IAAAlB,cAAA,CAAAoU,aAAY,EAAEnQ,SAAS,CAACtD,IAAA,CAAKqF,IAAI,EAAE;MACrDwC,IAAA,IAAQ,IAAAsG,yCAAI,EAAEwB,cAAc;IAChC;IACA,OAAOyC,yCAAA,CAAW;MAAElO,KAAA,EAAO,IAAArB,yCAAM,EAAES,SAAS,CAACkQ,KAAA,CAAMD,OAAO;YAAK1L;IAAK;EACxE;EACAzJ,MAAA,EAAU6E,IAAA;IACN,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,UAAU,GAAG;IACvC,MAAM6F,IAAA,GAAOgJ,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM;IAChC,MAAMY,IAAA,GAAO,IAAAsG,yCAAI,EAAE+B,UAAU,GAAGuB,MAAA,CAAO3I,IAAA,IAAQ,IAAAqF,yCAAI,EAAEgC,aAAa;IAClE,OAAOiC,yCAAA,CAAW;MAAElO,KAAA,EAAO,IAAArB,yCAAM,EAAE8Q,OAAO,CAAC7K,IAAA;YAAOjB;IAAK;EAC3D;EACA1J,MAAA,EAAU8E,IAAA;IACN,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,UAAU,CAAC,GAAG,EAAE,EAAE;IAC5C,MAAMiB,KAAA,GAAQ4N,IAAI,CAAC,EAAE,CAACzM,IAAI;IAC1B,IACIyM,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,GAAG,KACrB6K,IAAA,CAAK7K,MAAM,KAAK,KAAK6K,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,GAAG,GAE5C,MAAM,IAAI9J,KAAA,CACN,+CAA+C8F,IAAA,CAAKoK,cAAc,GAAG;IAE7E,MAAM9K,IAAA,GAAOuP,IAAI,CAAC,EAAE,CAAC8B,KAAK;IAC1B,MAAMC,EAAA,GAAK/B,IAAA,CAAK7K,MAAM,KAAK,IAAI6K,IAAI,CAAC,EAAE,CAAC8B,KAAK,KAAK1P,KAAA,CAAM+C,MAAM;IAC7D,IAAI4M,EAAA,GAAK3P,KAAA,CAAM+C,MAAM,IAAI4M,EAAA,GAAKtR,IAAA,IAAQsR,EAAA,GAAK,KAAKtR,IAAA,GAAO,GACnD,MAAM,IAAIpF,KAAA,CACN,uCAAuC8F,IAAA,CAAKoK,cAAc,GAAG;IAErE,OAAO;MAAEnJ,KAAA,EAAO,IAAArB,yCAAM,EAAES,SAAS,CAACY,KAAA,CAAMgE,KAAK,CAAC3F,IAAA,EAAMsR,EAAA;MAAMhM,IAAA,EAAM;IAAG;EACvE;EACAxJ,MAAA,EAAU4E,IAAA;IACN,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,UAAUgP,SAAA,EAAW;IAC/C,IAAIpK,IAAA,GAAO,IAAAsG,yCAAI,EAAEoC,UAAU;IAC3B,MAAM4B,KAAA,GAAuB,EAAE;IAC/B,KAAK,MAAMnS,IAAA,IAAQ8R,IAAA,EAAM;MACrB,KAAK,MAAMT,IAAA,IAAQrR,IAAA,CAAKqF,IAAI,EAAE8M,KAAA,CAAMtI,IAAI,CAACwH,IAAA;MACzCxJ,IAAA,IAAQ,IAAAsG,yCAAI,EAAEsC,YAAY;IAC9B;IACA5I,IAAA,IAAQ4J,MAAA,CAAOU,KAAA,CAAMlL,MAAM,IAAI,IAAAkH,yCAAI,EAAEqC,aAAa;IAClD,OAAO4B,yCAAA,CAAW;MACdlO,KAAA,EAAO,IAAArB,yCAAM,EAAES,SAAS,CAAChB,UAAA,CAAWC,IAAI,CAAC4P,KAAA;YACzCtK;IACJ;EACJ;EACAtJ,GAAA,EAAO0E,IAAA;IACH,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,OAAO,GAAG;IACpC,IAAI6O,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,GAAG,GACtB,MAAM,IAAI9J,KAAA,CACN,0CAA0C8F,IAAA,CAAKoK,cAAc,GAAG;IAExE,MAAMyG,KAAA,GAAQhC,IAAI,CAAC,EAAE,CAAC7L,QAAQ;IAC9B,IAAI,CAAC6N,KAAA,GAAQ,EAAE,GAAG,CAACA,KAAA,GAAQA,KAAI,IAAK,MAAM,EACtC,MAAM,IAAI3W,KAAA,CACN,oCAAoC8F,IAAA,CAAKoK,cAAc,GAAG;IAElE,IAAInJ,KAAA,GAAQ4N,IAAI,CAAC,EAAE,CAAC7L,QAAQ;IAC5B,IAAI6N,KAAA,IAAS,GAAG5P,KAAA,KAAU4P,KAAA,MACrB5P,KAAA,KAAU,CAAC4P,KAAA;IAChB,MAAMjM,IAAA,GACF,IAAAsG,yCAAI,EAAEyC,UAAU,GAChB,CAACa,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAOiB,yCAAA,CAAexO,KAAA,EAAM,IACvD,IAAAiK,yCAAI,EAAE0C,aAAa;IAC3B,OAAOuB,yCAAA,CAAW;MAAElO,KAAA,EAAO,IAAArB,yCAAM,EAAEE,UAAU,CAACmB,KAAA;YAAQ2D;IAAK;EAC/D;EACArJ,GAAA,EAAOyE,IAAA;IACH,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,OAAO,GAAG;IACpC,IAAI6O,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,GAAG,GACtB,MAAM,IAAI9J,KAAA,CACN,0CAA0C8F,IAAA,CAAKoK,cAAc,GAAG;IAExE,MAAMyG,KAAA,GAAQhC,IAAI,CAAC,EAAE,CAAC7L,QAAQ;IAC9B,IAAI,CAAC6N,KAAA,GAAQ,EAAE,GAAG,CAACA,KAAA,GAAQA,KAAI,IAAK,MAAM,EACtC,MAAM,IAAI3W,KAAA,CACN,oCAAoC8F,IAAA,CAAKoK,cAAc,GAAG;IAElE,IAAInJ,KAAA,GAAQ,IAAA7E,cAAA,CAAAgD,aAAY,EAAEyP,IAAI,CAAC,EAAE,CAACzM,IAAI,EAAE,OAAO;IAC/C,IAAInB,KAAA,GAAQ,EAAE,EAAEA,KAAA,GAAQ,CAACA,KAAA;IACzB,IAAI4P,KAAA,IAAS,GAAG5P,KAAA,KAAU4P,KAAA,MACrB5P,KAAA,KAAU,CAAC4P,KAAA;IAChB,MAAMjM,IAAA,GACF,IAAAsG,yCAAI,EAAE2C,UAAU,GAChB,CAACW,MAAA,CAAOK,IAAI,CAAC,EAAE,CAACzM,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAOiB,yCAAA,CAAexO,KAAA,EAAM,IACvD,IAAAiK,yCAAI,EAAE4C,aAAa;IAC3B,OAAOqB,yCAAA,CAAW;MAAElO,KAAA,EAAO,IAAArB,yCAAM,EAAEE,UAAU,CAACmB,KAAA;YAAQ2D;IAAK;EAC/D;EACApJ,MAAA,EAAUwE,IAAA,IACN8Q,yCAAA,CAAe,UAAU,CAAC,EAAE,EAAE9Q,IAAA,EAAM,CAACtF,CAAA,EAAG2G,CAAA,KAAM3G,CAAA,GAAI2G,CAAA;EACtD5F,MAAA,EAAUuE,IAAA,IACN8Q,yCAAA,CAAe,UAAU,EAAE,EAAE9Q,IAAA,EAAM,CAACtF,CAAA,EAAG2G,CAAA,KAAM3G,CAAA,GAAI2G,CAAA;EACrD3F,MAAA,EAAUsE,IAAA,IACN8Q,yCAAA,CAAe,UAAU,EAAE,EAAE9Q,IAAA,EAAM,CAACtF,CAAA,EAAG2G,CAAA,KAAM3G,CAAA,GAAI2G,CAAA;EACrD1F,MAAA,EAAUqE,IAAA;IACN,MAAM+E,KAAA,GAAQ+J,wCAAA,CAAO9O,IAAA,EAAM,UAAU,GAAG;IACxC,MAAM4E,IAAA,GACF,IAAAsG,yCAAI,EAAE6C,UAAU,GAChBS,MAAA,CAAOzJ,KAAK,CAAC,EAAE,CAAC3C,IAAI,CAAC4B,MAAM,IAAI,IAAAkH,yCAAI,EAAE8C,aAAa;IACtD,OAAOmB,yCAAA,CAAW;MACdlO,KAAA,EAAO,IAAArB,yCAAM,EAAEE,UAAU,CAAC,CAACiF,KAAK,CAAC,EAAE,CAAC/B,QAAQ;YAC5C4B;IACJ;EACJ;EACA9I,GAAA,EAAOkE,IAAA;IACH,MAAM+E,KAAA,GAAQ+J,wCAAA,CAAO9O,IAAA,EAAM,OAAO;IAClC,MAAM4E,IAAA,GAAO,IAAAsG,yCAAI,EAAEuC,QAAQ;IAC3B,OAAO;MAAExM,KAAA,EAAO,IAAArB,yCAAM,EAAEmP,QAAQ,CAAChK,KAAK,CAAC,EAAE,CAAC5D,MAAM;MAAGyD,IAAA,EAAMA;IAAK;EAClE;EACA7I,GAAA,EAAOiE,IAAA;IACH,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM;IAC1B,MAAM4E,IAAA,GAAO,IAAAsG,yCAAI,EAAEuC,QAAQ,GAAGe,MAAA,CAAOK,IAAA,CAAK7K,MAAM,IAAI,IAAAkH,yCAAI,EAAEwC,UAAU;IACpE,IAAIvP,MAAA,GAAS;IACb,KAAK,MAAMpB,IAAA,IAAQ8R,IAAA,EACf,IAAI,CAAC9R,IAAA,CAAKoE,MAAM,EAAE;MACdhD,MAAA,GAAS;MACT;IACJ;IAEJ,OAAO;MAAE8C,KAAA,EAAO,IAAArB,yCAAM,EAAEmP,QAAQ,CAAC5Q,MAAA;MAASyG,IAAA,EAAMA;IAAK;EACzD;EACA5I,GAAA,EAAOgE,IAAA;IACH,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM;IAC1B,MAAM4E,IAAA,GAAO,IAAAsG,yCAAI,EAAEuC,QAAQ,GAAGe,MAAA,CAAOK,IAAA,CAAK7K,MAAM,IAAI,IAAAkH,yCAAI,EAAEwC,UAAU;IACpE,IAAIvP,MAAA,GAAS;IACb,KAAK,MAAMpB,IAAA,IAAQ8R,IAAA,EACf,IAAI9R,IAAA,CAAKoE,MAAM,EAAE;MACbhD,MAAA,GAAS;MACT;IACJ;IAEJ,OAAO;MAAE8C,KAAA,EAAO,IAAArB,yCAAM,EAAEmP,QAAQ,CAAC5Q,MAAA;MAASyG,IAAA,EAAMA;IAAK;EACzD;EACA3I,QAAA,EAAY+D,IAAA;IACR,MAAM6O,IAAA,GAAOC,wCAAA,CAAO9O,IAAA,EAAM,YAAY,CAAC,GAAG+Q,QAAA,CAAS;IACnD,IAAI,CAAClC,IAAI,CAAC,EAAE,CAACxM,MAAM,EACf,MAAM,IAAInI,KAAA,CACN,oDAAoD2U,IAAI,CAAC,EAAE,CAACzE,cAAc,GAAG;IAErF,MAAMxF,IAAA,GAAOiK,IAAI,CAAC,EAAE,CAAC7L,QAAQ;IAC7B,IAAI4B,IAAA,GAAO,EAAE,EACT,MAAM,IAAI1K,KAAA,CACN,wDAAwD8F,IAAA,CAAKoK,cAAc,GAAG;IAEtF,OAAO;MAAEnJ,KAAA,EAAO,IAAArB,yCAAM,EAAEoR,KAAK;MAAEpM,IAAA,EAAMA;IAAK;EAC9C;AACJ;AAEO,MAAMqM,yCAAA,GAAmB;aAC5BrC,yCAAA;EACAsC,OAAA,EAASC,wCAAA;EACTjD,KAAA,EAAO;EACPD,KAAA,EAAO;AACX;AAEO,SAASmD,0CAAA;EACZ,OAAO;IACH,GAAGH,yCAAgB;IACnBI,SAAA,EAAW;MAAE,GAAGJ,yCAAA,CAAiBI;IAAU;EAC/C;AACJ;AAEO,SAASvC,yCACZnP,OAAgB,EAChBsG,IAAY,EACZjC,MAAkC,EAClCsN,IAAsB;EAEtB,MAAMzC,IAAA,GAAOlP,OAAA,CAAQ+C,MAAM;EAC3B,IAAI,OAAOsB,MAAA,KAAW,YAAY6K,IAAA,CAAK7K,MAAM,KAAKA,MAAA,EAC9C,MAAM,IAAI9J,KAAA,CACN,YAAY8J,MAAA,iBAAuBgD,IAAA,CAAKC,SAAS,CAAChB,IAAA,aAC9CtG,OAAA,CAAQyK,cAAc,GACvB,OAEN,IACDmH,KAAA,CAAMC,OAAO,CAACxN,MAAA,MACb6K,IAAA,CAAK7K,MAAM,GAAGA,MAAM,CAAC,EAAE,IAAI6K,IAAA,CAAK7K,MAAM,GAAGA,MAAM,CAAC,EAAE,CAAD,EAElD,MAAM,IAAI9J,KAAA,CACN,YACI8J,MAAM,CAAC,EAAE,KAAK+M,QAAA,GACR,YAAY/M,MAAM,CAAC,EAAE,EAAE,GACvB,WAAWA,MAAM,CAAC,EAAE,QAAQA,MAAM,CAAC,EAAE,EAAE,iBAChCgD,IAAA,CAAKC,SAAS,CAAChB,IAAA,aAC5BtG,OAAA,CAAQyK,cAAc,GACvB;EAEX,IAAIkH,IAAA,KAAStC,SAAA,EACTH,IAAA,CAAK4C,OAAO,CAAE1U,IAAA;IACV,IACIuU,IAAC,KAAS,UAAU,CAACvU,IAAA,CAAKsF,MAAM,IAC/BiP,IAAA,KAAS,UAAU,CAACvU,IAAA,CAAKmF,MAAM,EAEhC,MAAM,IAAIhI,KAAA,CACN,YAAYoX,IAAA,gBAAoBtK,IAAA,CAAKC,SAAS,CAC1ChB,IAAA,aACSlJ,IAAA,CAAKqN,cAAc,GAAG;EAE/C;EACJ,OAAOyE,IAAA;AACX;AAEO,SAASY,0CAAexO,KAAa;EACxC,IAAI+C,MAAA,GACA/C,KAAA,KAAU,EAAE,GAAG,IAAI,CAACA,KAAA,GAAQ,EAAE,GAAG,CAACA,KAAA,GAAQA,KAAI,EAAGxB,QAAQ,CAAC,GAAGuE,MAAM;EACvE,IAAI/C,KAAA,GAAQ,EAAE,EAAE+C,MAAA;EAChB,OAAOA,MAAC,GAAS,KAAM;AAC3B;AAEO,SAASmL,0CAAWhJ,MAAqB;EAC5C,OAAO;IACHlF,KAAA,EAAOkF,MAAA,CAAOlF,KAAK;IACnB2D,IAAA,EACIuB,MAAA,CAAOvB,IAAI,GACX4J,MAAA,CAAOrI,MAAA,CAAOlF,KAAK,CAACmB,IAAI,CAAC4B,MAAM,IAAI,IAAAkH,yCAAI,EAAEG;EACjD;AACJ;AAEO,SAASyF,0CACZY,MAAc,EACdC,YAAoB,EACpB3R,IAAa,EACb4R,UAA4C;EAE5C,IAAIvC,KAAA,GAAQsC,YAAA;EACZ,IAAIrC,OAAA,GAAU;EACd,IAAI1K,IAAA,GAAO,IAAAsG,yCAAI,EAAEO,OAAO;EACxB,KAAK,MAAM1O,IAAA,IAAQiD,IAAA,CAAK0C,MAAM,GAAGzE,GAAG,CAAElB,IAAA;IAClC,IAAI,CAACA,IAAA,CAAKsF,MAAM,EACZ,MAAM,IAAInI,KAAA,CACN,6BAA6B8M,IAAA,CAAKC,SAAS,CAACyK,MAAA,aACxC3U,IAAA,CAAKqN,cAAc,GACpB;IAEX,OAAOrN,IAAA;EACX,IAAI;IACAsS,KAAA,GAAQuC,UAAA,CAAWvC,KAAA,EAAOtS,IAAA,CAAKiG,QAAQ;IACvCsM,OAAA,IAAWvS,IAAA,CAAKqF,IAAI,CAAC4B,MAAM;IAC3BY,IAAA,IAAQ,IAAAsG,yCAAI,EAAES,SAAS;EAC3B;EACA/G,IAAA,IAAQ4J,MAAA,CAAOc,OAAA,IAAW,IAAApE,yCAAI,EAAEQ,UAAU;EAC1C,OAAOyD,yCAAA,CAAW;IAAElO,KAAA,EAAO,IAAArB,yCAAM,EAAEE,UAAU,CAACuP,KAAA;UAAQzK;EAAK;AAC/D;AAEO,SAASuM,yCACZrK,EAAW,EACX9G,IAAa;EAEb,IACI,CAAC8G,EAAA,CAAG1E,IAAI,CAAC4B,MAAM,IACf,IAAA5H,cAAA,CAAA+F,UAAS,EAAE2E,EAAA,CAAG1E,IAAI,CAAC6C,KAAK,CAAC,GAAG,IAAI5F,UAAA,CAAWC,IAAI,CAAC,CAAC,MAAM,KAAK,IAE5D,MAAM,IAAIpF,KAAA,CAAM,oBAAoB4M,EAAA,CAAGsD,cAAc,GAAG;EAC5D,IAAItD,EAAA,CAAG1E,IAAI,CAAC4B,MAAM,GAAG,GACjB,MAAM,IAAI9J,KAAA,CAAM,mBAAmB4M,EAAA,CAAGsD,cAAc,GAAG;EAC3D,MAAMyH,YAAA,GAAe,CAAC/K,EAAA,CAAG1E,IAAI,CAAC0E,EAAA,CAAG1E,IAAI,CAAC4B,MAAM,GAAG,EAAE,GAAG,IAAG,KAAM;EAC7D,MAAM8N,cAAA,GACF,IAAA1V,cAAA,CAAA2V,UAAS,EAAEjL,EAAA,CAAG1E,IAAI,CAAC6C,KAAK,CAAC,GAAG6B,EAAA,CAAG1E,IAAI,CAAC4B,MAAM,GAAG,IAAI,SAAS;EAC9D,IAAIY,IAAA;EACJ,IAAIiN,YAAA,KAAiB,GAAGjN,IAAA,GAAO,EAAE,MAC5B,IAAIiN,YAAA,KAAiB,GAAG;IACzBjN,IAAA,GAAO,IAAAsG,yCAAI,EAAEI,SAAS;IACtB,IAAIgE,OAAA,GAAU;IACd,KAAK,MAAMvS,IAAA,IAAQiD,IAAA,CAAK0C,MAAM,IAAI;MAC9B,IAAI,CAAC3F,IAAA,CAAKsF,MAAM,EACZ,MAAM,IAAInI,KAAA,CACN,yBAAyB6C,IAAA,CAAKqN,cAAc,GAAG;MAEvDkF,OAAA,IAAWvS,IAAA,CAAKqF,IAAI,CAAC4B,MAAM;MAC3BY,IAAA,IAAQ,IAAAsG,yCAAI,EAAEM,WAAW;IAC7B;IACA5G,IAAA,IAAQ4J,MAAA,CAAOc,OAAA,IAAW,IAAApE,yCAAI,EAAEK,YAAY;EAChD,OAAO,IAAIsG,YAAA,KAAiB,GAAG;IAC3BjN,IAAA,GAAO,IAAAsG,yCAAI,EAAE2B,OAAO;IACpB,MAAMmF,OAAA,GAAUhS,IAAA,CAAK0C,MAAM;IAC3B,IAAIsP,OAAA,CAAQhO,MAAM,EAAE;MAChB,MAAMlF,KAAA,GAAQkT,OAAO,CAAC,EAAE;MACxB,IAAI,CAAClT,KAAA,CAAMuD,MAAM,EACb,MAAM,IAAInI,KAAA,CACN,yBAAyB4E,KAAA,CAAMsL,cAAc,GAAG;MAExD,IAAI6H,OAAA,GAAUnT,KAAA,CAAMsD,IAAI,CAAC4B,MAAM;MAC/B,KAAK,MAAMjH,IAAA,IAAQiV,OAAA,CAAQ/M,KAAK,CAAC,IAAI;QACjC,IAAI,CAAClI,IAAA,CAAKsF,MAAM,EACZ,MAAM,IAAInI,KAAA,CACN,yBAAyB6C,IAAA,CAAKqN,cAAc,GAAG;QAEvDxF,IAAA,IACI,IAAAsG,yCAAI,EAAE4B,QAAQ,GACd,CAAC0B,MAAA,CAAOzR,IAAA,CAAKqF,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAOyD,OAAA,CAAO,IACtC,IAAA/G,yCAAI,EAAE6B,gBAAgB,GAC1ByB,MAAC,CAAOzR,IAAA,CAAKqF,IAAI,CAAC4B,MAAM,IAAIwK,MAAA,CAAOyD,OAAA,IAC/B,IAAA/G,yCAAI,EAAE8B,uBAAuB;QACrCiF,OAAA,IAAWlV,IAAA,CAAKqF,IAAI,CAAC4B,MAAM;MAC/B;IACJ;EACJ,OAAO,IAAI6N,YAAA,KAAiB,GAAG;IAC3BjN,IAAA,GAAO,IAAAsG,yCAAI,EAAEoC,UAAU;IACvB,IAAItJ,MAAA,GAAS;IACb,KAAK,MAAMjH,IAAA,IAAQiD,IAAA,CAAK0C,MAAM,IAAI;MAC9B,IAAI,CAAC3F,IAAA,CAAKsF,MAAM,EACZ,MAAM,IAAInI,KAAA,CACN,yBAAyB6C,IAAA,CAAKqN,cAAc,GAAG;MAEvDxF,IAAA,IAAQ,IAAAsG,yCAAI,EAAEsC,YAAY;MAC1BxJ,MAAA,IAAUjH,IAAA,CAAKqF,IAAI,CAAC4B,MAAM;IAC9B;IACAY,IAAA,IAAQ4J,MAAA,CAAOxK,MAAA,IAAU,IAAAkH,yCAAI,EAAEqC,aAAa;EAChD,OAAO,MAAM,IAAIrT,KAAA,CAAM,wBAAwB4M,EAAA,CAAGsD,cAAc,GAAG;EACnExF,IAAA,IAAQ4J,MAAA,CAAOsD,cAAA;EACf,IAAIlN,IAAA,IAAQ,EAAE,IAAI,GAAG,EACjB,MAAM,IAAI1K,KAAA,CAAM,mBAAmB4M,EAAA,CAAGsD,cAAc,GAAG;EAC3D,OAAO;IAAEnJ,KAAA,EAAO,IAAArB,yCAAM,EAAEkD,GAAG;IAAE8B,IAAA,EAAMA;EAAK;AAC5C;AAEO,SAASsN,0CACZpL,EAAW,EACX9G,IAAa,EACbmS,OAAmB;EAEnB,MAAM7H,MAAA,GAASxD,EAAA,CAAG9D,QAAQ;EAC1B,MAAMoP,OAAA,GACF/X,MAAA,CAAO2N,OAAO,EAAC,GAAAxN,yCAAO,GAAG6X,IAAI,CAAEC,KAAA,IAAUA,KAAK,CAAC,EAAE,KAAKhI,MAAA,IAAU,EAAE,IAClExD,EAAA,CAAGxE,MAAM;EACb,IAAI8P,OAAA,IAAWD,OAAA,CAAQd,SAAS,CAACA,SAAS,EAAE;IACxC,MAAMlT,MAAA,GAASgU,OAAA,CAAQd,SAAS,CAACA,SAAS,CAACe,OAAA,CAAQ,CAACpS,IAAA;IACpD,OAAO7B,MAAA;EACX,OAAO,OAAOgU,OAAA,CAAQd,SAAS,CAACH,OAAO,CAACpK,EAAA,EAAI9G,IAAA;AAChD;AH1gBO,MAAMuS,yCAAA,GAAe;EACxBC,IAAA,EAAOA,CAACC,iBAAA,EAAmBC,KAAA,EAAOC,QAAA;IAC9B,MAAMnM,MAAA,GAASkM,KAAA,CAAME,GAAG;IACxB,MAAM9T,KAAA,GAAQ4T,KAAA,CAAME,GAAG;IACvBF,KAAA,CAAM9L,IAAI,CAACJ,MAAA,EAAQ1H,KAAA;IACnB,OAAO,EAAE;EACb;EACAe,IAAA,EAAOA,CAAC4S,iBAAA,EAAmBC,KAAA,EAAOC,QAAA;IAC9B,MAAM7T,KAAA,GAAQ4T,KAAA,CAAME,GAAG;IACvB,MAAMpM,MAAA,GAASkM,KAAA,CAAME,GAAG;IACxBF,KAAA,CAAM9L,IAAI,CAAC,IAAAhH,yCAAM,EAAEC,IAAI,CAACf,KAAA,EAAO0H,MAAA;IAC/B,OAAO,EAAE;EACb;EACAqM,IAAA,EAAOA,CAACC,gBAAA,EAAkBJ,KAAA,EAAOC,QAAA;IAC7B,MAAMtI,IAAA,GAAOqI,KAAA,CAAME,GAAG;IACtB,MAAMjT,OAAA,GAAU0K,IAAA,CAAKvL,KAAK;IAC1B,MAAMkB,IAAA,GAAOqK,IAAA,CAAKtL,IAAI;IACtB,IAAIY,OAAA,CAAQ0C,MAAM,EAAE;MAChB,MAAM8D,MAAA,GAAS,IAAAkI,yCAAW,EAAE1O,OAAA,EAASK,IAAA;MACrC0S,KAAA,CAAM9L,IAAI,CAACT,MAAA,CAAOlF,KAAK;MACvB,OAAOkF,MAAA,CAAOvB,IAAI;IACtB;IACA,MAAMkC,EAAA,GAAKnH,OAAA,CAAQb,KAAK;IACxB,IAAIgI,EAAA,CAAG5E,MAAM,EAAE;MACX,MAAM,CAAC6Q,WAAA,EAAaC,SAAA,CAAU,GAAGlM,EAAA,CAAGjH,IAAI;MACxC,IAAIkT,WAAA,CAAY7Q,MAAM,IAAI,CAAC8Q,SAAA,CAAU7R,MAAM,EACvC,MAAM,IAAIjH,KAAA,CACN,sDAAsD4M,EAAA,CAAGsD,cAAc,GAAG;MAElF,MAAM6I,cAAA,GAAiBtT,OAAA,CAAQZ,IAAI;MACnC2T,KAAA,CAAM9L,IAAI,CAACmM,WAAA,EAAaE,cAAA;MACxBH,gBAAA,CAAiBlM,IAAI,CAAC2L,yCAAA,CAAatE,KAAK;MACxC,OAAO,IAAA/C,yCAAI,EAAE+C,KAAK;IACtB;IACA,IAAIiF,WAAA,GAAcvT,OAAA,CAAQZ,IAAI;IAC9B,IAAI,IAAA3C,cAAA,CAAA+F,UAAS,EAAE2E,EAAA,CAAG1E,IAAI,GAAE,GAAAjG,yCAAQ,IAAI;MAChCuW,KAAA,CAAM9L,IAAI,CAACsM,WAAA;MACX,OAAO,IAAAhI,yCAAI,EAAEgD,KAAK;IACtB;IACA4E,gBAAA,CAAiBlM,IAAI,CAAC2L,yCAAA,CAAatE,KAAK;IACxCyE,KAAA,CAAM9L,IAAI,CAACE,EAAA;IACX,OAAO,CAACoM,WAAA,CAAY/R,MAAM,EAAE;MACxBuR,KAAA,CAAM9L,IAAI,CAAC,IAAAhH,yCAAM,EAAEC,IAAI,CAACqT,WAAA,CAAYpU,KAAK,EAAEkB,IAAA;MAC3C8S,gBAAA,CAAiBlM,IAAI,CACjB2L,yCAAA,CAAa1S,IAAI,EACjB0S,yCAAA,CAAaM,IAAI,EACjBN,yCAAA,CAAaC,IAAI;MAErBU,WAAA,GAAcA,WAAA,CAAYnU,IAAI;IAClC;IACA2T,KAAA,CAAM9L,IAAI,CAAC,IAAAhH,yCAAM,EAAEkD,GAAG;IACtB,OAAO,EAAE;EACb;EACAmL,KAAA,EAAQA,CAAC6E,gBAAA,EAAkBJ,KAAA,EAAOP,OAAA;IAC9B,MAAMe,WAAA,GAAcR,KAAA,CAAME,GAAG;IAC7B,MAAM9L,EAAA,GAAK4L,KAAA,CAAME,GAAG;IACpB,IAAI9L,EAAA,CAAG5E,MAAM,EACT,MAAM,IAAIhI,KAAA,CAAM,6BAA6B4M,EAAA,CAAGsD,cAAc,GAAG;IACrE,IAAI,IAAAhO,cAAA,CAAA+F,UAAS,EAAE2E,EAAA,CAAG1E,IAAI,GAAE,GAAA9F,yCAAQ,IAAI;MAChC,MAAM0D,IAAA,GAAOkT,WAAA,CAAYxQ,MAAM;MAC/B,IAAI1C,IAAA,CAAKgE,MAAM,KAAK,GAChB,MAAM,IAAI9J,KAAA,CACN,uCAAuCgZ,WAAA,CAAY9I,cAAc,GAAG;MAE5EsI,KAAA,CAAM9L,IAAI,CAAC,IAAAhH,yCAAM,EAAEC,IAAI,CAACG,IAAI,CAAC,EAAE,EAAEA,IAAI,CAAC,EAAE;MACxC8S,gBAAA,CAAiBlM,IAAI,CAAC2L,yCAAA,CAAaM,IAAI;MACvC,OAAO,IAAA3H,yCAAI,EAAE+C,KAAK;IACtB;IACA,MAAM9H,MAAA,GAAS,IAAA+L,yCAAU,EAAEpL,EAAA,EAAIoM,WAAA,EAAaf,OAAA;IAC5CO,KAAA,CAAM9L,IAAI,CAACT,MAAA,CAAOlF,KAAK;IACvB,OAAOkF,MAAA,CAAOvB,IAAI;EACtB;AACJ;AI3EO,SAASuO,0CAAYxT,OAAiB;EACzC,MAAMyT,SAAA,GAA2B,EAAE;EACnC,IAAIzT,OAAO,CAAC,EAAE,IAAI,MACd,OAAO,IAAAC,yCAAM,EAAES,SAAS,CAAChB,UAAA,CAAWC,IAAI,CAAC,CAACK,OAAO,CAAC,EAAE,CAAC,QACpD,IAAIA,OAAO,CAAC,EAAE,IAAI,MAAMyT,SAAA,CAAUxM,IAAI,CAACjH,OAAO,CAAC,EAAE,GAAG,WACpD,IAAIA,OAAO,CAAC,EAAE,IAAI,MAAM;IACzByT,SAAA,CAAUxM,IAAI,CAACjH,OAAO,CAAC,EAAE,GAAG;IAC5BA,OAAA,CAAQkR,KAAK;IACb,IAAI,CAAClR,OAAA,CAAQqE,MAAM,EACf,MAAM,KAAI,GAAA/J,yCAAU,EAAE;IAC1BmZ,SAAA,CAAUxM,IAAI,CAACjH,OAAO,CAAC,EAAE;EAC7B,OAAO,IAAIA,OAAO,CAAC,EAAE,IAAI,MAAM;IAC3ByT,SAAA,CAAUxM,IAAI,CAACjH,OAAO,CAAC,EAAE,GAAG;IAC5B,KAAK,IAAIhF,CAAA,GAAI,GAAGA,CAAA,GAAI,GAAGA,CAAA,IAAK;MACxBgF,OAAA,CAAQkR,KAAK;MACb,IAAI,CAAClR,OAAA,CAAQqE,MAAM,EACf,MAAM,KAAI,GAAA/J,yCAAU,EAAE;MAC1BmZ,SAAA,CAAUxM,IAAI,CAACjH,OAAO,CAAC,EAAE;IAC7B;EACJ,OAAO,IAAIA,OAAO,CAAC,EAAE,IAAI,MAAM;IAC3ByT,SAAA,CAAUxM,IAAI,CAACjH,OAAO,CAAC,EAAE,GAAG;IAC5B,KAAK,IAAIhF,CAAA,GAAI,GAAGA,CAAA,GAAI,GAAGA,CAAA,IAAK;MACxBgF,OAAA,CAAQkR,KAAK;MACb,IAAI,CAAClR,OAAA,CAAQqE,MAAM,EACf,MAAM,KAAI,GAAA/J,yCAAU,EAAE;MAC1BmZ,SAAA,CAAUxM,IAAI,CAACjH,OAAO,CAAC,EAAE;IAC7B;EACJ,OAAO,IAAIA,OAAO,CAAC,EAAE,IAAI,MAAM;IAC3ByT,SAAA,CAAUxM,IAAI,CAACjH,OAAO,CAAC,EAAE,GAAG;IAC5B,KAAK,IAAIhF,CAAA,GAAI,GAAGA,CAAA,GAAI,GAAGA,CAAA,IAAK;MACxBgF,OAAA,CAAQkR,KAAK;MACb,IAAI,CAAClR,OAAA,CAAQqE,MAAM,EACf,MAAM,KAAI,GAAA/J,yCAAU,EAAE;MAC1BmZ,SAAA,CAAUxM,IAAI,CAACjH,OAAO,CAAC,EAAE;IAC7B;EACJ,OAAO,IAAIA,OAAO,CAAC,EAAE,KAAK,MAAM;IAC5BA,OAAA,CAAQkR,KAAK;IACb,IAAI,CAAClR,OAAA,CAAQqE,MAAM,EACf,MAAM,KAAI,GAAA/J,yCAAU,EAAE;IAC1B,MAAM6E,KAAA,GAAQqU,yCAAA,CAAYxT,OAAA;IAC1BA,OAAA,CAAQkR,KAAK;IACb,IAAI,CAAClR,OAAA,CAAQqE,MAAM,EACf,MAAM,KAAI,GAAA/J,yCAAU,EAAE;IAC1B,MAAM8E,IAAA,GAAOoU,yCAAA,CAAYxT,OAAA;IACzB,OAAO,IAAAC,yCAAM,EAAEC,IAAI,CAACf,KAAA,EAAOC,IAAA;EAC/B,OAAO,MAAM,KAAI,GAAA9E,yCAAU,EAAE;EAC7B,MAAM4L,IAAA,GAAO,IAAAzJ,cAAA,CAAAiX,SAAQ,EAAEhU,UAAA,CAAWC,IAAI,CAAC8T,SAAA;EACvC,IAAIlE,KAAA,GAAuB,EAAE;EAC7B,KAAK,IAAIvU,CAAA,GAAI,GAAGA,CAAA,GAAIkL,IAAA,EAAMlL,CAAA,IAAK;IAC3BgF,OAAA,CAAQkR,KAAK;IACb,IAAI,CAAClR,OAAA,CAAQqE,MAAM,EACf,MAAM,KAAI,GAAA/J,yCAAU,EAAE;IAE1BiV,KAAA,CAAMtI,IAAI,CAACjH,OAAO,CAAC,EAAE;EACzB;EACA,OAAO,IAAAC,yCAAM,EAAES,SAAS,CAAChB,UAAA,CAAWC,IAAI,CAAC4P,KAAA;AAC7C;AE5DO,MAAMoE,yCAAA;EACFC,IAAA;EACAC,MAAA;EAEPrZ,YAAYsZ,MAAc,EAAErV,KAAa,EAAE;IACvCqV,MAAA,GAASA,MAAA,CAAOC,UAAU,CAAC,QAAQ;IACnC,IAAIH,IAAA,GAAO;IACX,IAAIC,MAAA,GAAS;IACb,KAAK,IAAI7Y,CAAA,GAAI,GAAGA,CAAA,GAAIyD,KAAA,EAAOzD,CAAA,IACvB,IAAI8Y,MAAM,CAAC9Y,CAAA,CAAE,KAAK,MAAM;MACpB4Y,IAAA;MACAC,MAAA,GAAS;IACb,OACIA,MAAA;IAGR,IAAI,CAACD,IAAI,GAAGA,IAAA;IACZ,IAAI,CAACC,MAAM,GAAGA,MAAA;EAClB;EAEO/T,SAAA,EAAmB;IACtB,OAAO,GAAG,IAAI,CAAC8T,IAAI,IAAI,IAAI,CAACC,MAAM,EAAE;EACxC;AACJ;ADjBO,SAASG,0CAAKC,MAAe;EAChCA,MAAA,CAAO/C,KAAK;EACZ,OAAO+C,MAAM,CAAC,EAAE;AACpB;AAEO,SAASC,0CAAOJ,MAAc,EAAEG,MAAe;EAClD,MAAME,KAAA,GAAQF,MAAM,CAAC,EAAE;EACvB,IAAI,CAACD,yCAAA,CAAKC,MAAA,GACN,MAAM,KAAI,GAAA3Z,yCAAU,EAChB,+BAA+B,KAAI,GAAAqZ,yCAAO,EAAEG,MAAA,EAAQK,KAAA,CAAM1V,KAAK,IAAI;AAE/E;AAEO,SAAS2V,0CAAQC,IAAY;EAChC,OAAO,oGAAoGC,IAAI,CAC3GD,IAAA;AAER;AAEO,SAASE,0CAAkBC,IAAY,EAAE/V,KAAa;EACzD,OAAO,MAAM;IACT,OAAOA,KAAA,GAAQ+V,IAAA,CAAKnQ,MAAM,IAAI+P,yCAAA,CAAQI,IAAI,CAAC/V,KAAA,CAAM,GAAGA,KAAA;IACpD,IAAIA,KAAA,IAAS+V,IAAA,CAAKnQ,MAAM,IAAImQ,IAAI,CAAC/V,KAAA,CAAM,KAAK,KAAK;IACjD,OAAOA,KAAA,GAAQ+V,IAAA,CAAKnQ,MAAM,IAAI,CAAC,OAAOsC,QAAQ,CAAC6N,IAAI,CAAC/V,KAAA,CAAM,GAAGA,KAAA;EACjE;EACA,OAAOA,KAAA;AACX;AAEO,SAASgW,0CAAuBD,IAAY,EAAE/V,KAAa;EAC9D,MAAMiW,KAAA,GAAQjW,KAAA;EACd,OAAOA,KAAA,GAAQ+V,IAAA,CAAKnQ,MAAM,IAAI,CAAC+P,yCAAA,CAAQI,IAAI,CAAC/V,KAAA,CAAM,KAAK+V,IAAI,CAAC/V,KAAA,CAAM,KAAK,KACnEA,KAAA;EACJ,OAAO;IAAE+V,IAAA,EAAMA,IAAA,CAAKlP,KAAK,CAACoP,KAAA,EAAOjW,KAAA;WAAQA;EAAM;AACnD;AAEO,SAASkW,0CAAab,MAAc,EAAEG,MAAe;EACxD,IAAIE,KAAA,GAAQF,MAAM,CAAC,EAAE;EACrB,IAAIE,KAAA,CAAMK,IAAI,KAAK,KACf,OAAO,IAAAvU,yCAAM,EAAES,SAAS,CAAChB,UAAA,CAAWC,IAAI,CAAC,EAAE,GAAGiV,EAAE,CAC5C,KAAI,GAAAjB,yCAAO,EAAEG,MAAA,EAAQK,KAAA,CAAM1V,KAAK;EAExC,MAAMoW,SAAA,GAAYV,KAAA,CAAM1V,KAAK;EAC7B,MAAMU,KAAA,GAAQ2V,yCAAA,CAAahB,MAAA,EAAQG,MAAA;EACnCC,yCAAA,CAAOJ,MAAA,EAAQG,MAAA;EACfE,KAAA,GAAQF,MAAM,CAAC,EAAE;EACjB,IAAI7U,IAAA;EACJ,IAAI+U,KAAA,CAAMK,IAAI,KAAK,KAAK;IACpB,MAAMO,QAAA,GAAWZ,KAAA,CAAM1V,KAAK;IAC5ByV,yCAAA,CAAOJ,MAAA,EAAQG,MAAA;IACfE,KAAA,GAAQF,MAAM,CAAC,EAAE;IACjB7U,IAAA,GAAO0V,yCAAA,CAAahB,MAAA,EAAQG,MAAA;IAC5BC,yCAAA,CAAOJ,MAAA,EAAQG,MAAA;IACfE,KAAA,GAAQF,MAAM,CAAC,EAAE;IACjB,IAAIE,KAAA,CAAMK,IAAI,KAAK,KACf,MAAM,KAAI,GAAAla,yCAAU,EAChB,6BAA6B,KAAI,GAAAqZ,yCAAO,EAAEG,MAAA,EAAQiB,QAAA,IAAY;EAE1E,OAAO3V,IAAA,GAAOuV,yCAAA,CAAab,MAAA,EAAQG,MAAA;EACnC,OAAO,IAAAhU,yCAAM,EAAEC,IAAI,CAACf,KAAA,EAAOC,IAAA,EAAMwV,EAAE,CAAC,KAAI,GAAAjB,yCAAO,EAAEG,MAAA,EAAQe,SAAA;AAC7D;AAEO,SAASG,0CAAYlB,MAAc,EAAEK,KAAY;EACpD,OAAO,6BAA6BG,IAAI,CAACH,KAAA,CAAMK,IAAI,IAC7C,IAAAvU,yCAAM,EAAEE,UAAU,CAAC0O,MAAA,CAAOsF,KAAA,CAAMK,IAAI,CAACT,UAAU,CAAC,KAAK,MAAMa,EAAE,CACzD,KAAI,GAAAjB,yCAAO,EAAEG,MAAA,EAAQK,KAAA,CAAM1V,KAAK,KAEpC;AACV;AAEO,SAASwW,0CAAYnB,MAAc,EAAEK,KAAY;EACpD,IACIA,KAAA,CAAMK,IAAI,CAACnQ,MAAM,IAAI,KACrB8P,KAAA,CAAMK,IAAI,CAAClP,KAAK,CAAC,GAAG,GAAG4P,WAAW,OAAO,MAC3C;IACE,IAAIC,GAAA,GAAMhB,KAAA,CAAMK,IAAI,CAAClP,KAAK,CAAC;IAC3B,IAAI6P,GAAA,CAAI9Q,MAAM,GAAG,MAAM,GAAG8Q,GAAA,GAAM,IAAIA,GAAA,EAAK;IACzC,IAAI;MACA,OAAO,IAAAlV,yCAAM,EAAEmV,OAAO,CAACD,GAAA,EAAKP,EAAE,CAAC,KAAI,GAAAjB,yCAAO,EAAEG,MAAA,EAAQK,KAAA,CAAM1V,KAAK;IACnE,EAAE,OAAO4W,CAAA,EAAG;MACR,MAAM,KAAI,GAAA/a,yCAAU,EAChB,eAAe+M,IAAA,CAAKC,SAAS,CAAC6M,KAAA,CAAMK,IAAI,QAAQ,KAAI,GAAAb,yCAAO,EACvDG,MAAA,EACAK,KAAA,CAAM1V,KAAK,IACX;IAEZ;EACJ,OAAO,OAAO;AAClB;AAEO,SAAS6W,0CAAexB,MAAc,EAAEK,KAAY;EACvD,IAAIA,KAAA,CAAMK,IAAI,CAACnQ,MAAM,GAAG,GAAG,OAAO;EAClC,MAAMkK,KAAA,GAAQ4F,KAAA,CAAMK,IAAI,CAAC,EAAE;EAC3B,IAAI,CAAC,MAAM7N,QAAQ,CAAC4H,KAAA,GAAQ,OAAO;EACnC,IAAI4F,KAAA,CAAMK,IAAI,CAACL,KAAA,CAAMK,IAAI,CAACnQ,MAAM,GAAG,EAAE,KAAKkK,KAAA,EACtC,MAAM,KAAI,GAAAjU,yCAAU,EAChB,uBAAuB+M,IAAA,CAAKC,SAAS,CACjC6M,KAAA,CAAMK,IAAI,QACN,KAAI,GAAAb,yCAAO,EAAEG,MAAA,EAAQK,KAAA,CAAM1V,KAAK,IAAI;EAEpD,OAAO,IAAAwB,yCAAM,EAAEQ,QAAQ,CAAC0T,KAAA,CAAMK,IAAI,CAAClP,KAAK,CAAC,GAAG6O,KAAA,CAAMK,IAAI,CAACnQ,MAAM,GAAG,IAAIuQ,EAAE,CAClE,KAAI,GAAAjB,yCAAO,EAAEG,MAAA,EAAQK,KAAA,CAAM1V,KAAK;AAExC;AAEO,SAAS8W,0CAAezB,MAAc,EAAEK,KAAY;EACvD,IAAIK,IAAA,GAAOL,KAAA,CAAMK,IAAI;EACrB,IAAIA,IAAA,CAAKtJ,UAAU,CAAC,MAAMsJ,IAAA,GAAOA,IAAA,CAAKlP,KAAK,CAAC;EAC5C,MAAMmN,OAAA,GAA8B,IAAA5X,yCAAO,EAAE2Z,IAAA,CAA8B;EAC3E,OAAO,CACH/B,OAAA,KAAYpD,SAAA,GACN,IAAApP,yCAAM,EAAEQ,QAAQ,CAAC+T,IAAA,IACjB,IAAAvU,yCAAM,EAAEE,UAAU,CAACsS,OAAA,CAAO,EAClCmC,EAAE,CAAC,KAAI,GAAAjB,yCAAO,EAAEG,MAAA,EAAQK,KAAA,CAAM1V,KAAK;AACzC;AAEO,SAASqW,0CAAahB,MAAc,EAAEG,MAAe;EACxD,MAAME,KAAA,GAAQF,MAAM,CAAC,EAAE;EACvB,IAAIE,KAAA,CAAMK,IAAI,KAAK,KAAK;IACpBN,yCAAA,CAAOJ,MAAA,EAAQG,MAAA;IACf,OAAOU,yCAAA,CAAab,MAAA,EAAQG,MAAA;EAChC;EACA,MAAMzV,MAAA,GACFwW,yCAAA,CAAYlB,MAAA,EAAQK,KAAA,KACpBc,yCAAA,CAAYnB,MAAA,EAAQK,KAAA,KACpBmB,yCAAA,CAAexB,MAAA,EAAQK,KAAA,KACvBoB,yCAAA,CAAezB,MAAA,EAAQK,KAAA;EAC3B,IAAI,CAAC3V,MAAA,EACD,MAAM,KAAI,GAAAlE,yCAAU,EAChB,sBAAsB+M,IAAA,CAAKC,SAAS,CAAC6M,KAAA,CAAMK,IAAI,QAAQ,KAAI,GAAAb,yCAAO,EAC9DG,MAAA,EACAK,KAAA,CAAM1V,KAAK,IACX;EAEZ,OAAOD,MAAA;AACX;AAEO,UAAUgX,0CAAY1B,MAAc;EACvC,IAAIrV,KAAA,GAAQ;EACZ,OAAOA,KAAA,GAAQqV,MAAA,CAAOzP,MAAM,EAAE;IAC1B5F,KAAA,GAAQ8V,yCAAA,CAAkBT,MAAA,EAAQrV,KAAA;IAClC,IAAIA,KAAA,IAASqV,MAAA,CAAOzP,MAAM,EAAE;IAC5B,MAAMgQ,IAAA,GAAOP,MAAM,CAACrV,KAAA,CAAM;IAC1B,IAAI,MAAMkI,QAAQ,CAAC0N,IAAA,GAAO;MACtB,MAAM;QAAEG,IAAA,EAAMH,IAAA;eAAM5V;MAAM;MAC1BA,KAAA;MACA;IACJ;IACA,IAAI,MAAMkI,QAAQ,CAAC0N,IAAA,GAAO;MACtB,MAAMK,KAAA,GAAQjW,KAAA;MACd,MAAM8P,KAAA,GAAQuF,MAAM,CAACrV,KAAA,CAAM;MAC3BA,KAAA;MACA,OAAOA,KAAA,GAAQqV,MAAA,CAAOzP,MAAM,IAAIyP,MAAM,CAACrV,KAAA,CAAM,KAAK8P,KAAA,EAAO9P,KAAA;MACzD,IAAIA,KAAA,GAAQqV,MAAA,CAAOzP,MAAM,EAAE;QACvB,MAAM;UAAEmQ,IAAA,EAAMV,MAAA,CAAOxO,KAAK,CAACoP,KAAA,EAAOjW,KAAA,GAAQ;UAAIA,KAAA,EAAOiW;QAAM;QAC3DjW,KAAA;QACA;MACJ,OACI,MAAM,KAAI,GAAAnE,yCAAU,EAChB,0BAA0B,KAAI,GAAAqZ,yCAAO,EAAEG,MAAA,EAAQrV,KAAA,IAAS;IAEpE;IACA,MAAM0V,KAAA,GAAQM,yCAAA,CAAuBX,MAAA,EAAQrV,KAAA;IAC7C,MAAM;MAAE+V,IAAA,EAAML,KAAA,CAAMK,IAAI;aAAE/V;IAAM;IAChCA,KAAA,GAAQ0V,KAAA,CAAM1V,KAAK;EACvB;AACJ;AlB1HO,MAAMwB,yCAAA;EACT,OAAcgF,IAAA,GAAO;EACrB,OAAc4K,IAAA,GAAO5P,yCAAA,CAAQS,SAAS,CAAChB,UAAA,CAAWC,IAAI,CAAC,CAAC,EAAE;EAC1D,OAAc0R,KAAA,GAAQpR,yCAAA,CAAQS,SAAS,CAAChB,UAAA,CAAWC,IAAI,CAAC,EAAE;EAC1D,OAAcwD,GAAA,GAAMlD,yCAAA,CAAQoR,KAAK;EAEjB/P,KAAA;EACTmU,QAAA;EAEP,IAAWhT,KAAA,EAAmB;IAC1B,IAAI,CAAC,IAAI,CAACC,MAAM,EACZ,MAAM,IAAInI,KAAA,CAAM,gBAAgB,IAAI,CAACkQ,cAAc,GAAG;IAC1D,OAAO,IAAI,CAACnJ,KAAK;EACrB;EAEA,IAAWpB,KAAA,EAAa;IACpB,IAAI,CAAC,IAAI,CAACqC,MAAM,EACZ,MAAM,IAAIhI,KAAA,CAAM,gBAAgB,IAAI,CAACkQ,cAAc,GAAG;IAC1D,OAAO,IAAI,CAACnJ,KAAK;EACrB;EAEA,IAAWnC,MAAA,EAAiB;IACxB,OAAO,IAAI,CAACe,IAAI,CAAC,EAAE;EACvB;EAEA,IAAWd,KAAA,EAAgB;IACvB,OAAO,IAAI,CAACc,IAAI,CAAC,EAAE;EACvB;EAEA,IAAWwC,OAAA,EAAS;IAChB,OAAO,IAAI,CAACpB,KAAK,YAAY5B,UAAA;EACjC;EAEA,IAAW6C,OAAA,EAAS;IAChB,OAAOqP,KAAA,CAAMC,OAAO,CAAC,IAAI,CAACvQ,KAAK;EACnC;EAEA,IAAWE,OAAA,EAAkB;IACzB,OAAO,IAAI,CAACkB,MAAM,IAAI,IAAI,CAACpB,KAAK,CAAC+C,MAAM,KAAK;EAChD;EAEA,OAAcnE,KAAKf,KAAc,EAAEC,IAAa,EAAW;IACvD,OAAO,IAAIa,yCAAA,CAAQ,CAACd,KAAA,EAAOC,IAAA,CAAK;EACpC;EAEA,OAAcsB,UAAU6O,KAAiB,EAAW;IAChD,OAAO,IAAItP,yCAAA,CAAQsP,KAAA;EACvB;EAEA,OAAcmG,kBAAkBC,aAA4B,EAAW;IACnE,OAAO,IAAI1V,yCAAA,CAAQ0V,aAAA,CAAchF,OAAO;EAC5C;EAEA,OAAciF,eAAeC,UAAsB,EAAW;IAC1D,OAAO,IAAI5V,yCAAA,CAAQ4V,UAAA,CAAWlF,OAAO;EACzC;EAEA,OAAcyE,QAAQD,GAAW,EAAW;IACxC,OAAO,IAAIlV,yCAAA,CAAQ,IAAAxD,cAAA,CAAA2Y,OAAM,EAAED,GAAA;EAC/B;EAEA,OAAc/F,SAAS9N,KAAc,EAAW;IAC5C,OAAOA,KAAA,GAAQrB,yCAAA,CAAQ4P,IAAI,GAAG5P,yCAAA,CAAQoR,KAAK;EAC/C;EAEA,OAAcN,QAAQzP,KAAa,EAAW;IAC1C,OAAO,IAAIrB,yCAAA,CAAQ,IAAAxD,cAAA,CAAAqZ,SAAQ,EAAExU,KAAA;EACjC;EAEA,OAAcnB,WAAWmB,KAAa,EAAW;IAC7C,OAAO,IAAIrB,yCAAA,CAAQ,IAAAxD,cAAA,CAAAC,YAAW,EAAE4E,KAAA;EACpC;EAEA,OAAcb,SAAS+T,IAAY,EAAW;IAC1C,OAAO,IAAIvU,yCAAA,CAAQ,IAAI2B,WAAA,GAAcC,MAAM,CAAC2S,IAAA;EAChD;EAEA,OAAcvT,WAAW6S,MAAc,EAAW;IAC9C,MAAMiC,MAAA,GAAS,IAAAP,yCAAU,EAAE1B,MAAA;IAC3B,MAAMG,MAAA,GAAS,C,GAAI8B,MAAA,CAAO;IAC1B,IAAI9B,MAAA,CAAO5P,MAAM,EAAE,OAAO,IAAAyQ,yCAAW,EAAEhB,MAAA,EAAQG,MAAA,OAC1C,MAAM,KAAI,GAAA3Z,yCAAU,EAAE;EAC/B;EAEA,OAAcgG,SAAS0V,QAAmB,EAAW;IACjD,IAAIxX,MAAA,GAASyB,yCAAA,CAAQkD,GAAG;IACxB,KAAK,MAAMnD,OAAA,IAAWgW,QAAA,CAASC,OAAO,IAClCzX,MAAA,GAASyB,yCAAA,CAAQC,IAAI,CAACF,OAAA,EAASxB,MAAA;IACnC,OAAOA,MAAA;EACX;EAEA,OAAc0X,YAAY3G,KAAiB,EAAW;IAClD,MAAMvP,OAAA,GAAU,C,GAAIuP,KAAA,CAAM;IAC1B,IAAI,CAACvP,OAAA,CAAQqE,MAAM,EAAE,MAAM,KAAI,GAAA/J,yCAAU,EAAE;IAC3C,OAAO,IAAAkZ,yCAAU,EAAExT,OAAA;EACvB;EAEA,OAAcmW,eAAehB,GAAW,EAAW;IAC/C,OAAOlV,yCAAA,CAAQiW,WAAW,CAAC,IAAAzZ,cAAA,CAAA2Y,OAAM,EAAED,GAAA;EACvC;EAEA3a,YAAY8G,KAAY,EAAE;IACtB,IAAI,CAACA,KAAK,GAAGA,KAAA;EACjB;EAEA,IAAWmJ,eAAA,EAAyB;IAChC,OAAO,IAAI,CAACgL,QAAQ,GAAG,OAAO,IAAI,CAACA,QAAQ,EAAE,GAAG;EACpD;EAEOb,GAAGa,QAAkB,EAAQ;IAChC,IAAI,CAACA,QAAQ,GAAGA,QAAA;IAChB,OAAO,IAAI;EACf;EAEOW,MAAM/V,IAAe,EAAW;IACnC,OAAOJ,yCAAA,CAAQgB,UAAU,CACrB,iMACFD,GAAG,CAACf,yCAAA,CAAQC,IAAI,CAAC,IAAI,EAAED,yCAAA,CAAQK,QAAQ,CAACD,IAAA,IAAQiB,KAAK;EAC3D;EAEO+U,QAAA,EAAuC;IAC1C,MAAMC,sBAAA,GAAyBrW,yCAAA,CAAQgB,UAAU,CAC7C;IAEJ,MAAMsV,kBAAA,GAAqBtW,yCAAA,CAAQgB,UAAU,CACzC;IAGJ,IAAIzC,MAAA,GAAS,IAAA2D,yCAAI,EAAEmU,sBAAA,EAAwB,IAAI;IAC/C,IAAI,CAAC9X,MAAA,EAAQ,OAAO;IAEpB,MAAMgY,EAAA,GAAKhY,MAAA,CAAOiY,QAAQ;IAC1B,IAAIC,IAAA,GAAOlY,MAAA,CAAOkY,IAAI;IAEtB,MAAMrW,IAAA,GAAuB,EAAE;IAE/B,OAAO,MAAM;MACT7B,MAAA,GAAS,IAAA2D,yCAAI,EAAEoU,kBAAA,EAAoBG,IAAA;MACnC,IAAI,CAAClY,MAAA,EAAQ;MAEb6B,IAAA,CAAK4G,IAAI,CAACzI,MAAA,CAAOmY,IAAI;MACrBD,IAAA,GAAOlY,MAAA,CAAOkY,IAAI;IACtB;IAEA,IAAIA,IAAA,CAAKhU,MAAM,IAAIgU,IAAA,CAAKrT,QAAQ,OAAO,EAAE,EAAE,OAAO,CAACmT,EAAA,EAAInW,IAAA,CAAK;IAC5D,OAAO;EACX;EAEOuW,KAAA,EAAmB;IACtB,OAAO,IAAI,CAAClU,MAAM,GACZ,IAAAjG,cAAA,CAAAgT,OAAM,EAAE,IAAAhT,cAAA,CAAAoa,WAAU,EAAEnX,UAAA,CAAWC,IAAI,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC8C,IAAI,KACnD,IAAAhG,cAAA,CAAAgT,OAAM,EACF,IAAAhT,cAAA,CAAAoa,WAAU,EACNnX,UAAA,CAAWC,IAAI,CAAC,CAAC,EAAE,GACnB,IAAI,CAACR,KAAK,CAACyX,IAAI,IACf,IAAI,CAACxX,IAAI,CAACwX,IAAI;EAGhC;EAEOE,QAAA,EAAkB;IACrB,OAAO,IAAAra,cAAA,CAAA8M,KAAI,EAAE,IAAI,CAACqN,IAAI;EAC1B;EAEOG,OAAO/W,OAAgB,EAAW;IACrC,IAAIxB,MAAA,GAAkB,IAAI;IAC1B,IAAI,IAAI,CAACkE,MAAM,IAAI,IAAI,CAACvD,KAAK,CAACoD,MAAM,IAAI,IAAI,CAACpD,KAAK,CAACwD,MAAM,OAAO,OAC5DnE,MAAA,GAASyB,yCAAA,CAAQK,QAAQ,CAAC,CACtBL,yCAAA,CAAQQ,QAAQ,CAAC,QACjBR,yCAAA,CAAQkD,GAAG,EACX,IAAI,CACP;IACL,MAAMiC,KAAA,GAAQ5G,MAAA,CAAOuE,MAAM;IAC3BqC,KAAA,CAAM4R,MAAM,CAAC,GAAG,GAAGhX,OAAA;IACnB,OAAOC,yCAAA,CAAQK,QAAQ,CAAC8E,KAAA;EAC5B;EAEO6R,UAAUjB,QAAmB,EAAW;IAC3C,IAAIxX,MAAA,GAAkB,IAAI;IAC1B,KAAK,MAAMwB,OAAA,IAAWgW,QAAA,CAASC,OAAO,IAClCzX,MAAA,GAASA,MAAA,CAAOuY,MAAM,CAAC/W,OAAA;IAC3B,OAAOxB,MAAA;EACX;EAEO0Y,QAAQ1E,OAAA,GAAmC,CAAC,CAAC,EAAiB;IACjE,MAAM2E,WAAA,GAA8B;MAChCC,MAAA,EAAQ;MACR1F,SAAA,EAAW,IAAAD,yCAAmB;MAC9B4F,gBAAA,EAAkB,CAAC;MACnB,GAAG7E;IACP;IACA,IAAI2E,WAAA,CAAYC,MAAM,EAClBD,WAAA,CAAYzF,SAAS,CAACH,OAAO,GAAG,CAAC+F,SAAA,EAAWjX,IAAA;MACxC,MAAM,IAAI9F,KAAA,CACN,yBAAyB8F,IAAA,CAAKoK,cAAc,GAAG;IAEvD;IACJ,SAAS8M,kBAAkBlX,IAAa;MACpC,MAAMmX,QAAA,GAAWnX,IAAA,CAAKlB,KAAK,CAACwD,MAAM;MAClC,KAAK,MAAM,CAAC8U,IAAA,EAAMC,KAAA,CAAM,IAAIhd,MAAA,CAAO2N,OAAO,CACtC8O,WAAA,CAAYE,gBAAgB,GAC7B;QACC,IAAIG,QAAA,IAAYE,KAAA,EACZ,OAAO;UACHpW,KAAA,EAAOrB,yCAAA,CAAQQ,QAAQ,CAAC,GAAGgX,IAAA,IAAQD,QAAA,EAAU;UAC7CvS,IAAA,EAAM;QACV;MACR;MACA,MAAM,IAAI1K,KAAA,CAAM,cAAcid,QAAA,GAAWnX,IAAA,CAAKoK,cAAc,GAAG;IACnE;IACA,SAASkN,OAAOtX,IAAa;MACzB,MAAMmX,QAAA,GAAWnX,IAAA,CAAKlB,KAAK,CAACwD,MAAM;MAClC,IAAImR,MAAA,GAAwB;MAC5B,KAAK,MAAM,CAAC2D,IAAA,EAAMC,KAAA,CAAM,IAAIhd,MAAA,CAAO2N,OAAO,CACtC8O,WAAA,CAAYE,gBAAgB,GAC7B;QACC,KAAK,MAAM,CAACO,IAAA,EAAMC,OAAA,CAAQ,IAAInd,MAAA,CAAO2N,OAAO,CAACqP,KAAA,GACzC,IAAIF,QAAA,KAAa,GAAGC,IAAA,IAAQG,IAAA,EAAM,EAAE9D,MAAA,GAAS+D,OAAA;MAErD;MACA,IAAI/D,MAAA,KAAW,MACX,MAAM,IAAIvZ,KAAA,CACN,cAAcid,QAAA,GAAWnX,IAAA,CAAKoK,cAAc,GAAG;MAEvD,OAAO;QAAEnJ,KAAA,EAAOrB,yCAAA,CAAQgB,UAAU,CAAC6S,MAAA;QAAS7O,IAAA,EAAM;MAAG;IACzD;IACA;IACA,SAAS6S,QAAQ/N,KAAc;MAC3B,OAAO;QAAEzI,KAAA,EAAOrB,yCAAA,CAAQkD,GAAG;QAAE8B,IAAA,EAAM;MAAG;IAC1C;IAEA,SAASD,WAAWhF,OAAgB,EAAEK,IAAa;MAC/C,OAAOL,OAAA,CAAQgB,GAAG,CAACX,IAAA,EAAM8W,WAAA;IAC7B;IACA,MAAMnV,QAAA,GAAW;MACb2H,GAAA,EAAK,IAAA0B,yCAAQ,EAAErG,UAAA;MACf+S,GAAA,EAAK,IAAAhT,yCAAQ,EAAEC,UAAA;MACfgT,mBAAA,EAAqBT,iBAAA;MACrBU,KAAA,EAAON,MAAA;MACPO,MAAA,EAAQJ;IACZ;IACApd,MAAA,CAAOuO,MAAM,CAACkO,WAAA,CAAYzF,SAAS,CAACA,SAAS,EAAE1P,QAAA;IAC/C,OAAOgD,UAAA,CACH/E,yCAAA,CAAQgB,UAAU,CAAC,wBACnBhB,yCAAA,CAAQK,QAAQ,CAAC,CAAC,IAAI,CAAC;EAE/B;EAEOU,IACH2N,WAAoB,EACpB6D,OAAA,GAA+B,CAAC,CAAC,EACpB;IACb,MAAM2E,WAAA,GAA0B;MAC5BC,MAAA,EAAQ;MACR1F,SAAA,EAAW,IAAAD,yCAAmB;MAC9B,GAAGe;IACP;IACA,IAAI2E,WAAA,CAAYC,MAAM,EAClBD,WAAA,CAAYzF,SAAS,CAACH,OAAO,GAAG,CAAC+F,SAAA,EAAWjX,IAAA;MACxC,MAAM,IAAI9F,KAAA,CACN,yBAAyB8F,IAAA,CAAKoK,cAAc,GAAG;IAEvD;IACJ,MAAM0I,gBAAA,GAAuC,CAAC,IAAAP,yCAAW,EAAEM,IAAI,CAAC;IAChE,MAAMH,KAAA,GAAwB,CAAC9S,yCAAA,CAAQC,IAAI,CAAC,IAAI,EAAEyO,WAAA,EAAa;IAC/D,IAAI1J,IAAA,GAAO,EAAE;IACb,OAAOkO,gBAAA,CAAiB9O,MAAM,EAAE;MAC5B,MAAM8T,WAAA,GAAchF,gBAAA,CAAiBF,GAAG;MACxChO,IAAA,IAAQkT,WAAA,CAAYhF,gBAAA,EAAkBJ,KAAA,EAAOoE,WAAA;MAC7C,IAAIA,WAAA,CAAYiB,OAAO,KAAK/I,SAAA,IAAapK,IAAA,GAAOkS,WAAA,CAAYiB,OAAO,EAC/D,MAAM,IAAI7d,KAAA,CACN,oBAAoB4c,WAAA,CAAYiB,OAAO,GACnCrF,KAAK,CAACA,KAAA,CAAM1O,MAAM,GAAG,EAAE,CAACoG,cAAc,GACvC;IAEf;IACA,OAAO;MACHnJ,KAAA,EAAOyR,KAAK,CAACA,KAAA,CAAM1O,MAAM,GAAG,EAAE;YAC9BY;IACJ;EACJ;EAEO0L,QAAA,EAAsB;IACzB,IAAI,IAAI,CAACpO,MAAM,EACX,MAAM,IAAIhI,KAAA,CACN,kBAAkB,IAAI,CAACuF,QAAQ,YAC3B,IAAI,CAAC2K,cAAc,GACpB;IAEX,OAAO,IAAI,CAAChI,IAAI;EACpB;EAEO4V,gBAAA,EAAiC;IACpC,IAAI,IAAI,CAAC9V,MAAM,IAAK,IAAI,CAACE,IAAI,CAAC4B,MAAM,KAAK,MAAM,IAAI,CAAC5B,IAAI,CAAC4B,MAAM,KAAK,IAChE,MAAM,IAAI9J,KAAA,CACN,kBAAkB,IAAI,CAACuF,QAAQ,sBAC3B,IAAI,CAAC2K,cAAc,GACpB;IAEX,OAAO,IAAI,CAAChI,IAAI,CAAC4B,MAAM,KAAK,KACtB,IAAA5H,cAAA,CAAAoU,aAAY,EAAEyH,WAAW,CAAC,IAAI,CAAC7V,IAAI,IACnC,IAAAhG,cAAA,CAAAoU,aAAY,EAAE0H,WAAW,CAAC,IAAI,CAAC9V,IAAI;EAC7C;EAEO+V,aAAA,EAA2B;IAC9B,IAAI,IAAI,CAACjW,MAAM,EACX,MAAM,IAAIhI,KAAA,CACN,kBAAkB,IAAI,CAACuF,QAAQ,oBAC3B,IAAI,CAAC2K,cAAc,GACpB;IAEX,OAAO,IAAAhO,cAAA,CAAAgU,UAAS,EAAE/P,SAAS,CAAC,IAAI,CAAC+B,IAAI;EACzC;EAEO8G,MAAA,EAAgB;IACnB,IAAI,IAAI,CAAChH,MAAM,EACX,MAAM,IAAIhI,KAAA,CACN,kBAAkB,IAAI,CAACuF,QAAQ,YAC3B,IAAI,CAAC2K,cAAc,GACpB;IAEX,OAAO,IAAAhO,cAAA,CAAA8M,KAAI,EAAE,IAAI,CAAC9G,IAAI;EAC1B;EAEOgW,OAAA,EAAkB;IACrB,IAAI,IAAI,CAAClW,MAAM,EACX,MAAM,IAAIhI,KAAA,CACN,kBAAkB,IAAI,CAACuF,QAAQ,aAC3B,IAAI,CAAC2K,cAAc,GACpB;IAEX,OAAO,CAAC,IAAI,CAACjJ,MAAM;EACvB;EAEOwP,MAAA,EAAgB;IACnB,IAAI,IAAI,CAACzO,MAAM,EACX,MAAM,IAAIhI,KAAA,CACN,kBAAkB,IAAI,CAACuF,QAAQ,YAC3B,IAAI,CAAC2K,cAAc,GACpB;IAEX,OAAO,IAAAhO,cAAA,CAAAiX,SAAQ,EAAE,IAAI,CAACjR,IAAI;EAC9B;EAEOY,SAAA,EAAmB;IACtB,IAAI,IAAI,CAACd,MAAM,EACX,MAAM,IAAIhI,KAAA,CACN,kBAAkB,IAAI,CAACuF,QAAQ,eAC3B,IAAI,CAAC2K,cAAc,GACpB;IAEX,OAAO,IAAAhO,cAAA,CAAAic,YAAW,EAAE,IAAI,CAACjW,IAAI;EACjC;EAEOE,OAAA,EAAiB;IACpB,IAAI,IAAI,CAACJ,MAAM,EACX,MAAM,IAAIhI,KAAA,CACN,kBAAkB,IAAI,CAACuF,QAAQ,aAC3B,IAAI,CAAC2K,cAAc,GACpB;IAEX,OAAO,IAAIkO,WAAA,GAAcC,MAAM,CAAC,IAAI,CAACnW,IAAI;EAC7C;EAEOoW,SAASC,YAAA,GAAwB,IAAI,EAAU;IAClD,IAAI,IAAI,CAACpW,MAAM,EAAE;MACb,IAAI,IAAI,CAAClB,MAAM,EAAE,OAAO,UACnB,IAAI,IAAI,CAACF,KAAK,CAAC+C,MAAM,GAAG,GACzB,IAAI;QACA,MAAM0U,MAAA,GAAS,IAAI,CAACpW,MAAM;QAC1B,KAAK,IAAI3H,CAAA,GAAI,GAAGA,CAAA,GAAI+d,MAAA,CAAO1U,MAAM,EAAErJ,CAAA,IAAK;UACpC,IAAI,CAAC,IAAAuB,yCAAQ,EAAEoK,QAAQ,CAACoS,MAAM,CAAC/d,CAAA,CAAE,GAC7B,OAAO,KAAK,IAAI,CAACuO,KAAK,IAAI;QAClC;QACA,IAAIwP,MAAA,CAAOpS,QAAQ,CAAC,QAAQoS,MAAA,CAAOpS,QAAQ,CAAC,MACxC,OAAO,KAAK,IAAI,CAAC4C,KAAK,IAAI;QAC9B,MAAMgF,KAAA,GAAQwK,MAAA,CAAOpS,QAAQ,CAAC,OAAO,MAAM;QAC3C,OAAO4H,KAAA,GAAQwK,MAAA,GAASxK,KAAA;MAC5B,EAAE,MAAM;QACJ,OAAO,KAAK,IAAI,CAAChF,KAAK,IAAI;MAC9B,OACG,IAAI,IAAA9M,cAAA,CAAA+F,UAAS,EAAE,IAAA/F,cAAA,CAAAqZ,SAAQ,EAAE,IAAArZ,cAAA,CAAAiX,SAAQ,EAAE,IAAI,CAACjR,IAAI,IAAI,IAAI,CAACA,IAAI,GAC5D,OAAO,IAAAhG,cAAA,CAAAiX,SAAQ,EAAE,IAAI,CAACjR,IAAI,EAAE3C,QAAQ,QACnC,OAAO,KAAK,IAAI,CAACyJ,KAAK,IAAI;IACnC,OAAO;MACH,IAAI/K,MAAA,GAAS;MACb,IAAIsa,YAAA,IAAgB,IAAI,CAAC3Z,KAAK,CAACuD,MAAM,EAAE;QACnC,MAAMpB,KAAA,GAAQ,IAAI,CAACnC,KAAK,CAACkE,QAAQ;QACjC,MAAMoP,OAAA,GAAU/X,MAAA,CAAOqL,IAAI,EAAC,GAAAlL,yCAAO,GAAG6X,IAAI,CACrCD,OAAA,IACG,IAAA5X,yCAAO,EAAE4X,OAAA,CAAiC,KAAKnR,KAAA;QAEvD9C,MAAA,IAAUiU,OAAA,GAAUA,OAAA,GAAU,IAAI,CAACtT,KAAK,CAAC0Z,QAAQ,CAACC,YAAA;MACtD,OAAOta,MAAA,IAAU,IAAI,CAACW,KAAK,CAAC0Z,QAAQ,CAACC,YAAA;MACrC,IAAIxG,OAAA,GAAU,IAAI,CAACpS,IAAI,CAAC,EAAE;MAC1B,OAAOoS,OAAA,CAAQ/P,MAAM,EAAE;QACnB/D,MAAA,IAAU,IAAI8T,OAAA,CAAQnT,KAAK,CAAC0Z,QAAQ,CAACC,YAAA,GAAe;QACpDxG,OAAA,GAAUA,OAAA,CAAQpS,IAAI,CAAC,EAAE;MAC7B;MACA1B,MAAA,IACI,CAAC8T,OAAA,CAAQ9Q,MAAM,GAAG,KAAK,MAAM8Q,OAAA,CAAQuG,QAAQ,CAACC,YAAA,GAAe,IAC7D;MACJ,OAAOta,MAAA;IACX;EACJ;EAEOuE,OAAOqU,MAAA,GAAkB,KAAK,EAAa;IAC9C,MAAM5Y,MAAA,GAAyB,EAAE;IACjC,IAAI8T,OAAA,GAAmB,IAAI;IAC3B,OAAOA,OAAA,CAAQ/P,MAAM,EAAE;MACnB,MAAMnF,IAAA,GAAOkV,OAAA,CAAQnT,KAAK;MAC1BX,MAAA,CAAOyI,IAAI,CAAC7J,IAAA;MACZkV,OAAA,GAAUA,OAAA,CAAQlT,IAAI;IAC1B;IACA,IAAI,CAACkT,OAAA,CAAQ9Q,MAAM,IAAI4V,MAAA,EACnB,MAAM,IAAI7c,KAAA,CAAM,uBAAuB,IAAI,CAACkQ,cAAc,GAAG;IACjE,OAAOjM,MAAA;EACX;EAEOwa,UAAA,EAAwB;IAC3B,IAAI,IAAI,CAACtW,MAAM,EAAE;MACb,IAAI,IAAI,CAAClB,MAAM,EAAE,OAAO9B,UAAA,CAAWC,IAAI,CAAC,CAAC,KAAK,OACzC,IAAI,IAAI,CAAC8C,IAAI,CAAC4B,MAAM,KAAK,KAAK,IAAI,CAAC5B,IAAI,CAAC,EAAE,IAAI,MAC/C,OAAO,IAAI,CAACA,IAAI,MACf;QACD,MAAMyD,IAAA,GAAO,IAAI,CAACzD,IAAI,CAAC4B,MAAM;QAC7B,MAAM7F,MAAA,GAAwB,EAAE;QAChC,IAAI0H,IAAA,GAAO,MAAM1H,MAAA,CAAOyI,IAAI,CAAC,OAAOf,IAAA,OAC/B,IAAIA,IAAA,GAAO,QAAQ;UACpB1H,MAAA,CAAOyI,IAAI,CAAC,OAAQf,IAAA,IAAQ;UAC5B1H,MAAA,CAAOyI,IAAI,CAACf,IAAC,IAAQ,IAAK;QAC9B,OAAO,IAAIA,IAAA,GAAO,UAAU;UACxB1H,MAAA,CAAOyI,IAAI,CAAC,OAAQf,IAAA,IAAQ;UAC5B1H,MAAA,CAAOyI,IAAI,CAACf,IAAC,IAAQ,IAAK;UAC1B1H,MAAA,CAAOyI,IAAI,CAACf,IAAC,IAAQ,IAAK;QAC9B,OAAO,IAAIA,IAAA,GAAO,WAAW;UACzB1H,MAAA,CAAOyI,IAAI,CAAC,OAAQf,IAAA,IAAQ;UAC5B1H,MAAA,CAAOyI,IAAI,CAACf,IAAC,IAAQ,KAAM;UAC3B1H,MAAA,CAAOyI,IAAI,CAACf,IAAC,IAAQ,IAAK;UAC1B1H,MAAA,CAAOyI,IAAI,CAACf,IAAC,IAAQ,IAAK;QAC9B,OAAO,IAAIA,IAAA,GAAO,aAAa;UAC3B1H,MAAA,CAAOyI,IAAI,CAAC,OAAQf,IAAA,IAAQ;UAC5B1H,MAAA,CAAOyI,IAAI,CAACf,IAAC,IAAQ,KAAM;UAC3B1H,MAAA,CAAOyI,IAAI,CAACf,IAAC,IAAQ,KAAM;UAC3B1H,MAAA,CAAOyI,IAAI,CAACf,IAAC,IAAQ,IAAK;UAC1B1H,MAAA,CAAOyI,IAAI,CAACf,IAAC,IAAQ,IAAK;QAC9B,OACI,MAAM,IAAI+S,UAAA,CACN,oBAAoB,IAAI,CAACnZ,QAAQ,mDAC7B,IAAI,CAAC2K,cAAc,GACpB;QAEX,KAAK,MAAMgE,IAAA,IAAQ,IAAI,CAAChM,IAAI,EAAEjE,MAAA,CAAOyI,IAAI,CAACwH,IAAA;QAC1C,OAAO/O,UAAA,CAAWC,IAAI,CAACnB,MAAA;MAC3B;IACJ,OAAO;MACH,MAAMA,MAAA,GAAS,CAAC,KAAK;MACrB,KAAK,MAAMiQ,IAAA,IAAQ,IAAI,CAACtP,KAAK,CAAC6Z,SAAS,IAAIxa,MAAA,CAAOyI,IAAI,CAACwH,IAAA;MACvD,KAAK,MAAMA,IAAA,IAAQ,IAAI,CAACrP,IAAI,CAAC4Z,SAAS,IAAIxa,MAAA,CAAOyI,IAAI,CAACwH,IAAA;MACtD,OAAO/O,UAAA,CAAWC,IAAI,CAACnB,MAAA;IAC3B;EACJ;EAEO0a,aAAA,EAAuB;IAC1B,OAAO,IAAAzc,cAAA,CAAA8M,KAAI,EAAE,IAAI,CAACyP,SAAS;EAC/B;EAEOvb,OAAO6D,KAAc,EAAW;IACnC,OACI,IAAI,CAACoB,MAAM,KAAKpB,KAAA,CAAMoB,MAAM,KAC3B,IAAI,CAACA,MAAM,GACN,IAAAjG,cAAA,CAAA+F,UAAS,EAAE,IAAI,CAACC,IAAI,EAAEnB,KAAA,CAAMmB,IAAI,IAChC,IAAI,CAACtD,KAAK,CAAC1B,MAAM,CAAC6D,KAAA,CAAMnC,KAAK,KAC7B,IAAI,CAACC,IAAI,CAAC3B,MAAM,CAAC6D,KAAA,CAAMlC,IAAI;EAEzC;EAEOU,SAAA,EAAmB;IACtB,OAAO,IAAI,CAAC+Y,QAAQ;EACxB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}